{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Enola AI Documentation","text":"<p>This documentation covers the modules and packages of the Enola AI project.</p>"},{"location":"reference/enola.step/","title":"Step","text":""},{"location":"reference/enola_types/","title":"Enola Types","text":""},{"location":"reference/enola_types/#enola.enola_types.ApiDataModel","title":"<code>ApiDataModel</code>","text":"<p>Represents API data related to a step.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the API call.</p> <code>method</code> <code>str</code> <p>The HTTP method used (e.g., GET, POST).</p> <code>url</code> <code>str</code> <p>The URL of the API endpoint.</p> <code>body</code> <code>str</code> <p>The request body sent.</p> <code>header</code> <code>str</code> <p>The request headers sent.</p> <code>payload</code> <code>str</code> <p>The response payload received.</p> <code>description</code> <code>str</code> <p>A description of the API call.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class ApiDataModel:\n    \"\"\"\n    Represents API data related to a step.\n\n    Attributes:\n        name (str): The name of the API call.\n        method (str): The HTTP method used (e.g., GET, POST).\n        url (str): The URL of the API endpoint.\n        body (str): The request body sent.\n        header (str): The request headers sent.\n        payload (str): The response payload received.\n        description (str): A description of the API call.\n    \"\"\"\n\n    def __init__(self, name: str, method: str, url: str, body: str, header: str, payload: str, description: str):\n        \"\"\"\n        Initializes a new instance of ApiDataModel.\n\n        Args:\n            name (str): The name of the API call.\n            method (str): The HTTP method used (e.g., GET, POST).\n            url (str): The URL of the API endpoint.\n            body (str): The request body sent.\n            header (str): The request headers sent.\n            payload (str): The response payload received.\n            description (str): A description of the API call.\n        \"\"\"\n        self.name = name\n        self.method = method\n        self.url = url\n        self.description = description\n        self.body = body\n        self.header = header\n        self.payload = payload\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the ApiDataModel instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the ApiDataModel.\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"method\": self.method,\n            \"url\": self.url,\n            \"description\": self.description,\n            \"body\": self.body,\n            \"header\": self.header,\n            \"payload\": self.payload\n        }\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ApiDataModel.__init__","title":"<code>__init__(name, method, url, body, header, payload, description)</code>","text":"<p>Initializes a new instance of ApiDataModel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the API call.</p> required <code>method</code> <code>str</code> <p>The HTTP method used (e.g., GET, POST).</p> required <code>url</code> <code>str</code> <p>The URL of the API endpoint.</p> required <code>body</code> <code>str</code> <p>The request body sent.</p> required <code>header</code> <code>str</code> <p>The request headers sent.</p> required <code>payload</code> <code>str</code> <p>The response payload received.</p> required <code>description</code> <code>str</code> <p>A description of the API call.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self, name: str, method: str, url: str, body: str, header: str, payload: str, description: str):\n    \"\"\"\n    Initializes a new instance of ApiDataModel.\n\n    Args:\n        name (str): The name of the API call.\n        method (str): The HTTP method used (e.g., GET, POST).\n        url (str): The URL of the API endpoint.\n        body (str): The request body sent.\n        header (str): The request headers sent.\n        payload (str): The response payload received.\n        description (str): A description of the API call.\n    \"\"\"\n    self.name = name\n    self.method = method\n    self.url = url\n    self.description = description\n    self.body = body\n    self.header = header\n    self.payload = payload\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ApiDataModel.to_json","title":"<code>to_json()</code>","text":"<p>Converts the ApiDataModel instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the ApiDataModel.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the ApiDataModel instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the ApiDataModel.\n    \"\"\"\n    return {\n        \"name\": self.name,\n        \"method\": self.method,\n        \"url\": self.url,\n        \"description\": self.description,\n        \"body\": self.body,\n        \"header\": self.header,\n        \"payload\": self.payload\n    }\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.DataListModel","title":"<code>DataListModel</code>","text":"<p>Represents a data item in the agent's data list.</p> <p>Attributes:</p> Name Type Description <code>kind</code> <code>KindType</code> <p>Indicates whether the data is received or sent.</p> <code>name</code> <code>str</code> <p>The name of the data item.</p> <code>data_type</code> <code>DataType</code> <p>The type of the data item.</p> <code>value</code> <code>Any</code> <p>The value of the data item.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class DataListModel:\n    \"\"\"\n    Represents a data item in the agent's data list.\n\n    Attributes:\n        kind (KindType): Indicates whether the data is received or sent.\n        name (str): The name of the data item.\n        data_type (DataType): The type of the data item.\n        value (Any): The value of the data item.\n    \"\"\"\n\n    def __init__(self, kind: 'KindType', name: str, data_type: 'DataType', value: Any):\n        \"\"\"\n        Initializes a new instance of DataListModel.\n\n        Args:\n            kind (KindType): Indicates whether the data is received or sent.\n            name (str): The name of the data item.\n            data_type (DataType): The type of the data item.\n            value (Any): The value of the data item.\n        \"\"\"\n        self.kind = kind\n        self.name = name\n        self.data_type = data_type\n        self.value = value\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the DataListModel instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the DataListModel.\n        \"\"\"\n        return {\n            \"kind\": self.kind.value,\n            \"name\": self.name,\n            \"data_type\": self.data_type.value,\n            \"value\": self.value\n        }\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.DataListModel.__init__","title":"<code>__init__(kind, name, data_type, value)</code>","text":"<p>Initializes a new instance of DataListModel.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>KindType</code> <p>Indicates whether the data is received or sent.</p> required <code>name</code> <code>str</code> <p>The name of the data item.</p> required <code>data_type</code> <code>DataType</code> <p>The type of the data item.</p> required <code>value</code> <code>Any</code> <p>The value of the data item.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self, kind: 'KindType', name: str, data_type: 'DataType', value: Any):\n    \"\"\"\n    Initializes a new instance of DataListModel.\n\n    Args:\n        kind (KindType): Indicates whether the data is received or sent.\n        name (str): The name of the data item.\n        data_type (DataType): The type of the data item.\n        value (Any): The value of the data item.\n    \"\"\"\n    self.kind = kind\n    self.name = name\n    self.data_type = data_type\n    self.value = value\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.DataListModel.to_json","title":"<code>to_json()</code>","text":"<p>Converts the DataListModel instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the DataListModel.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the DataListModel instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the DataListModel.\n    \"\"\"\n    return {\n        \"kind\": self.kind.value,\n        \"name\": self.name,\n        \"data_type\": self.data_type.value,\n        \"value\": self.value\n    }\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EnolaSenderModel","title":"<code>EnolaSenderModel</code>","text":"<p>Represents the sender information for Enola tracking.</p> <p>Attributes:</p> Name Type Description <code>app_id</code> <code>str</code> <p>ID of the application.</p> <code>app_name</code> <code>str</code> <p>Name of the application.</p> <code>user_id</code> <code>str</code> <p>ID of the user.</p> <code>user_name</code> <code>str</code> <p>Name of the user.</p> <code>session_id</code> <code>str</code> <p>ID of the session.</p> <code>session_name</code> <code>str</code> <p>Name of the session.</p> <code>channel_id</code> <code>str</code> <p>ID of the channel.</p> <code>channel_name</code> <code>str</code> <p>Name of the channel.</p> <code>client_id</code> <code>str</code> <p>ID of the client.</p> <code>product_id</code> <code>str</code> <p>ID of the product.</p> <code>external_id</code> <code>str</code> <p>External ID for tracking.</p> <code>batch_id</code> <code>str</code> <p>ID of the batch if batch tracking is used.</p> <code>ip</code> <code>str</code> <p>IP address of the sender.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class EnolaSenderModel:\n    \"\"\"\n    Represents the sender information for Enola tracking.\n\n    Attributes:\n        app_id (str): ID of the application.\n        app_name (str): Name of the application.\n        user_id (str): ID of the user.\n        user_name (str): Name of the user.\n        session_id (str): ID of the session.\n        session_name (str): Name of the session.\n        channel_id (str): ID of the channel.\n        channel_name (str): Name of the channel.\n        client_id (str): ID of the client.\n        product_id (str): ID of the product.\n        external_id (str): External ID for tracking.\n        batch_id (str): ID of the batch if batch tracking is used.\n        ip (str): IP address of the sender.\n    \"\"\"\n\n    def __init__(\n        self,\n        app_id: str,\n        app_name: str,\n        user_id: str,\n        user_name: str,\n        session_id: str,\n        session_name: str,\n        channel_id: str,\n        channel_name: str,\n        client_id: str,\n        product_id: str,\n        external_id: str,\n        batch_id: str,\n        ip: str,\n    ):\n        \"\"\"\n        Initializes a new instance of EnolaSenderModel.\n\n        Args:\n            app_id (str): ID of the application.\n            app_name (str): Name of the application.\n            user_id (str): ID of the user.\n            user_name (str): Name of the user.\n            session_id (str): ID of the session.\n            session_name (str): Name of the session.\n            channel_id (str): ID of the channel.\n            channel_name (str): Name of the channel.\n            client_id (str): ID of the client.\n            product_id (str): ID of the product.\n            external_id (str): External ID for tracking.\n            batch_id (str): ID of the batch if batch tracking is used.\n            ip (str): IP address of the sender.\n        \"\"\"\n        self.app_id = app_id\n        self.app_name = app_name\n        self.user_id = user_id\n        self.user_name = user_name\n        self.session_id = session_id\n        self.session_name = session_name\n        self.channel_id = channel_id\n        self.channel_name = channel_name\n        self.client_id = client_id\n        self.product_id = product_id\n        self.external_id = external_id\n        self.batch_id = batch_id\n        self.ip = ip\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EnolaSenderModel.__init__","title":"<code>__init__(app_id, app_name, user_id, user_name, session_id, session_name, channel_id, channel_name, client_id, product_id, external_id, batch_id, ip)</code>","text":"<p>Initializes a new instance of EnolaSenderModel.</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>ID of the application.</p> required <code>app_name</code> <code>str</code> <p>Name of the application.</p> required <code>user_id</code> <code>str</code> <p>ID of the user.</p> required <code>user_name</code> <code>str</code> <p>Name of the user.</p> required <code>session_id</code> <code>str</code> <p>ID of the session.</p> required <code>session_name</code> <code>str</code> <p>Name of the session.</p> required <code>channel_id</code> <code>str</code> <p>ID of the channel.</p> required <code>channel_name</code> <code>str</code> <p>Name of the channel.</p> required <code>client_id</code> <code>str</code> <p>ID of the client.</p> required <code>product_id</code> <code>str</code> <p>ID of the product.</p> required <code>external_id</code> <code>str</code> <p>External ID for tracking.</p> required <code>batch_id</code> <code>str</code> <p>ID of the batch if batch tracking is used.</p> required <code>ip</code> <code>str</code> <p>IP address of the sender.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(\n    self,\n    app_id: str,\n    app_name: str,\n    user_id: str,\n    user_name: str,\n    session_id: str,\n    session_name: str,\n    channel_id: str,\n    channel_name: str,\n    client_id: str,\n    product_id: str,\n    external_id: str,\n    batch_id: str,\n    ip: str,\n):\n    \"\"\"\n    Initializes a new instance of EnolaSenderModel.\n\n    Args:\n        app_id (str): ID of the application.\n        app_name (str): Name of the application.\n        user_id (str): ID of the user.\n        user_name (str): Name of the user.\n        session_id (str): ID of the session.\n        session_name (str): Name of the session.\n        channel_id (str): ID of the channel.\n        channel_name (str): Name of the channel.\n        client_id (str): ID of the client.\n        product_id (str): ID of the product.\n        external_id (str): External ID for tracking.\n        batch_id (str): ID of the batch if batch tracking is used.\n        ip (str): IP address of the sender.\n    \"\"\"\n    self.app_id = app_id\n    self.app_name = app_name\n    self.user_id = user_id\n    self.user_name = user_name\n    self.session_id = session_id\n    self.session_name = session_name\n    self.channel_id = channel_id\n    self.channel_name = channel_name\n    self.client_id = client_id\n    self.product_id = product_id\n    self.external_id = external_id\n    self.batch_id = batch_id\n    self.ip = ip\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ErrOrWarnKind","title":"<code>ErrOrWarnKind</code>","text":"<p>               Bases: <code>Enum</code></p> <p>EXTERNAL: external agent call generate an unexpected error or warning</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class ErrOrWarnKind(Enum):\n    \"\"\"\n    EXTERNAL: external agent call generate an unexpected error or warning\n    \"\"\"\n    EXTERNAL = \"EXTERNAL\"\n    \"\"\"\n    INTERNAL_CONTROLLED: internal agent call generate an unexpected error or warning\n    \"\"\"\n    INTERNAL_CONTROLLED = \"INTERNAL_CONTROLLED\"\n    \"\"\"\n    INTERNAL_TOUSER: controlled error or warning to send to user\n    \"\"\"\n    INTERNAL_TOUSER = \"INTERNAL_TOUSER\"\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ErrOrWarnKind.EXTERNAL","title":"<code>EXTERNAL = 'EXTERNAL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>INTERNAL_CONTROLLED: internal agent call generate an unexpected error or warning</p>"},{"location":"reference/enola_types/#enola.enola_types.ErrOrWarnKind.INTERNAL_CONTROLLED","title":"<code>INTERNAL_CONTROLLED = 'INTERNAL_CONTROLLED'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>INTERNAL_TOUSER: controlled error or warning to send to user</p>"},{"location":"reference/enola_types/#enola.enola_types.EvalType","title":"<code>EvalType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of evaluation types.</p> <p>Attributes:</p> Name Type Description <code>AUTO</code> <code>str</code> <p>Automatic evaluation.</p> <code>USER</code> <code>str</code> <p>User evaluation.</p> <code>INTERNAL</code> <code>str</code> <p>Internal evaluation.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class EvalType(Enum):\n    \"\"\"\n    Enumeration of evaluation types.\n\n    Attributes:\n        AUTO (str): Automatic evaluation.\n        USER (str): User evaluation.\n        INTERNAL (str): Internal evaluation.\n    \"\"\"\n    AUTO = \"AUTO\"\n    USER = \"USER\"\n    INTERNAL = \"INTERNAL\"\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationDetailModel","title":"<code>EvaluationDetailModel</code>","text":"<p>Represents the details of an individual evaluation.</p> <p>Attributes:</p> Name Type Description <code>eval_id</code> <code>str</code> <p>Evaluation identifier.</p> <code>value</code> <code>float</code> <p>Evaluation value.</p> <code>level</code> <code>int</code> <p>Evaluation level.</p> <code>comment</code> <code>str</code> <p>Evaluation comment.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class EvaluationDetailModel:\n    \"\"\"\n    Represents the details of an individual evaluation.\n\n    Attributes:\n        eval_id (str): Evaluation identifier.\n        value (float): Evaluation value.\n        level (int): Evaluation level.\n        comment (str): Evaluation comment.\n    \"\"\"\n\n    def __init__(self, eval_id: str, comment: str, value: Optional[float] = None, level: Optional[int] = None):\n        \"\"\"\n        Initializes a new instance of EvaluationDetailModel.\n\n        Args:\n            eval_id (str): Evaluation identifier.\n            comment (str): Evaluation comment.\n            value (float, optional): Evaluation value.\n            level (int, optional): Evaluation level.\n        \"\"\"\n        self.eval_id = eval_id\n        self.value = value\n        self.level = level\n        self.comment = comment\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationDetailModel.__init__","title":"<code>__init__(eval_id, comment, value=None, level=None)</code>","text":"<p>Initializes a new instance of EvaluationDetailModel.</p> <p>Parameters:</p> Name Type Description Default <code>eval_id</code> <code>str</code> <p>Evaluation identifier.</p> required <code>comment</code> <code>str</code> <p>Evaluation comment.</p> required <code>value</code> <code>float</code> <p>Evaluation value.</p> <code>None</code> <code>level</code> <code>int</code> <p>Evaluation level.</p> <code>None</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self, eval_id: str, comment: str, value: Optional[float] = None, level: Optional[int] = None):\n    \"\"\"\n    Initializes a new instance of EvaluationDetailModel.\n\n    Args:\n        eval_id (str): Evaluation identifier.\n        comment (str): Evaluation comment.\n        value (float, optional): Evaluation value.\n        level (int, optional): Evaluation level.\n    \"\"\"\n    self.eval_id = eval_id\n    self.value = value\n    self.level = level\n    self.comment = comment\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationModel","title":"<code>EvaluationModel</code>","text":"<p>Represents an evaluation model containing evaluation details and results.</p> <p>Attributes:</p> Name Type Description <code>enola_id</code> <code>str</code> <p>The Enola execution ID associated with the evaluation.</p> <code>eval_type</code> <code>str</code> <p>The type of evaluation (e.g., 'AUTO', 'USER', 'INTERNAL').</p> <code>evals</code> <code>List[EvaluationDetailModel]</code> <p>A list of evaluation details.</p> <code>enola_sender</code> <code>EnolaSenderModel</code> <p>The sender information for the evaluation.</p> <code>result_score</code> <code>Optional[ResultScore]</code> <p>The result score data, if applicable.</p> <code>result_llm</code> <code>Optional[ResultLLM]</code> <p>The result from a language model, if applicable.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class EvaluationModel:\n    \"\"\"\n    Represents an evaluation model containing evaluation details and results.\n\n    Attributes:\n        enola_id (str): The Enola execution ID associated with the evaluation.\n        eval_type (str): The type of evaluation (e.g., 'AUTO', 'USER', 'INTERNAL').\n        evals (List[EvaluationDetailModel]): A list of evaluation details.\n        enola_sender (EnolaSenderModel): The sender information for the evaluation.\n        result_score (Optional[ResultScore]): The result score data, if applicable.\n        result_llm (Optional[ResultLLM]): The result from a language model, if applicable.\n    \"\"\"\n\n    def __init__(\n        self,\n        enola_id: str,\n        eval_type: 'EvalType',\n        enola_sender: 'EnolaSenderModel',\n        result_score: Optional['ResultScore'] = None,\n        result_llm: Optional['ResultLLM'] = None,\n    ):\n        \"\"\"\n        Initializes a new instance of EvaluationModel.\n\n        Args:\n            enola_id (str): The Enola execution ID associated with the evaluation.\n            eval_type (EvalType): The type of evaluation.\n            enola_sender (EnolaSenderModel): The sender information for the evaluation.\n            result_score (ResultScore, optional): The result score data.\n            result_llm (ResultLLM, optional): The result from a language model.\n        \"\"\"\n        self.enola_id = enola_id\n        self.eval_type = eval_type.value\n        self.evals: List['EvaluationDetailModel'] = []\n        self.enola_sender = enola_sender\n        self.result_score = result_score\n        self.result_llm = result_llm\n\n    def add_eval(self, eval_detail: 'EvaluationDetailModel') -&gt; None:\n        \"\"\"\n        Adds an evaluation detail to the evaluation model.\n\n        Args:\n            eval_detail (EvaluationDetailModel): The evaluation detail to add.\n        \"\"\"\n        self.evals.append(eval_detail)\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the EvaluationModel instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the EvaluationModel.\n        \"\"\"\n        results_json = None\n        if self.result_score is not None:\n            results_json = self.result_score.to_json()\n        elif self.result_llm is not None:\n            results_json = self.result_llm.to_json()\n\n        result = {\n            \"enolaId\": self.enola_id,\n            \"evalType\": self.eval_type,\n            \"sender\": {\n                \"app_id\": self.enola_sender.app_id,\n                \"app_name\": self.enola_sender.app_name,\n                \"user_id\": self.enola_sender.user_id,\n                \"user_name\": self.enola_sender.user_name,\n                \"session_id\": self.enola_sender.session_id,\n                \"session_name\": self.enola_sender.session_name,\n                \"channel_id\": self.enola_sender.channel_id,\n                \"channel_name\": self.enola_sender.channel_name,\n                \"ip\": self.enola_sender.ip,\n            },\n            \"results\": results_json,\n            \"evals\": {\n                item.eval_id: {\n                    \"value\": item.value,\n                    \"level\": item.level,\n                    \"comment\": item.comment,\n                }\n                for item in self.evals\n            },\n        }\n        return result\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__.get(key)\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationModel.__init__","title":"<code>__init__(enola_id, eval_type, enola_sender, result_score=None, result_llm=None)</code>","text":"<p>Initializes a new instance of EvaluationModel.</p> <p>Parameters:</p> Name Type Description Default <code>enola_id</code> <code>str</code> <p>The Enola execution ID associated with the evaluation.</p> required <code>eval_type</code> <code>EvalType</code> <p>The type of evaluation.</p> required <code>enola_sender</code> <code>EnolaSenderModel</code> <p>The sender information for the evaluation.</p> required <code>result_score</code> <code>ResultScore</code> <p>The result score data.</p> <code>None</code> <code>result_llm</code> <code>ResultLLM</code> <p>The result from a language model.</p> <code>None</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(\n    self,\n    enola_id: str,\n    eval_type: 'EvalType',\n    enola_sender: 'EnolaSenderModel',\n    result_score: Optional['ResultScore'] = None,\n    result_llm: Optional['ResultLLM'] = None,\n):\n    \"\"\"\n    Initializes a new instance of EvaluationModel.\n\n    Args:\n        enola_id (str): The Enola execution ID associated with the evaluation.\n        eval_type (EvalType): The type of evaluation.\n        enola_sender (EnolaSenderModel): The sender information for the evaluation.\n        result_score (ResultScore, optional): The result score data.\n        result_llm (ResultLLM, optional): The result from a language model.\n    \"\"\"\n    self.enola_id = enola_id\n    self.eval_type = eval_type.value\n    self.evals: List['EvaluationDetailModel'] = []\n    self.enola_sender = enola_sender\n    self.result_score = result_score\n    self.result_llm = result_llm\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationModel.add_eval","title":"<code>add_eval(eval_detail)</code>","text":"<p>Adds an evaluation detail to the evaluation model.</p> <p>Parameters:</p> Name Type Description Default <code>eval_detail</code> <code>EvaluationDetailModel</code> <p>The evaluation detail to add.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def add_eval(self, eval_detail: 'EvaluationDetailModel') -&gt; None:\n    \"\"\"\n    Adds an evaluation detail to the evaluation model.\n\n    Args:\n        eval_detail (EvaluationDetailModel): The evaluation detail to add.\n    \"\"\"\n    self.evals.append(eval_detail)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationModel.to_json","title":"<code>to_json()</code>","text":"<p>Converts the EvaluationModel instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the EvaluationModel.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the EvaluationModel instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the EvaluationModel.\n    \"\"\"\n    results_json = None\n    if self.result_score is not None:\n        results_json = self.result_score.to_json()\n    elif self.result_llm is not None:\n        results_json = self.result_llm.to_json()\n\n    result = {\n        \"enolaId\": self.enola_id,\n        \"evalType\": self.eval_type,\n        \"sender\": {\n            \"app_id\": self.enola_sender.app_id,\n            \"app_name\": self.enola_sender.app_name,\n            \"user_id\": self.enola_sender.user_id,\n            \"user_name\": self.enola_sender.user_name,\n            \"session_id\": self.enola_sender.session_id,\n            \"session_name\": self.enola_sender.session_name,\n            \"channel_id\": self.enola_sender.channel_id,\n            \"channel_name\": self.enola_sender.channel_name,\n            \"ip\": self.enola_sender.ip,\n        },\n        \"results\": results_json,\n        \"evals\": {\n            item.eval_id: {\n                \"value\": item.value,\n                \"level\": item.level,\n                \"comment\": item.comment,\n            }\n            for item in self.evals\n        },\n    }\n    return result\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationResponseModel","title":"<code>EvaluationResponseModel</code>","text":"<p>Represents the response model for an evaluation submission.</p> <p>Attributes:</p> Name Type Description <code>enola_id</code> <code>Optional[str]</code> <p>The Enola execution ID.</p> <code>agent_deploy_id</code> <code>Optional[str]</code> <p>The agent deployment ID.</p> <code>enola_eval_id</code> <code>Optional[str]</code> <p>The Enola evaluation ID.</p> <code>successfull</code> <code>Optional[bool]</code> <p>Indicates if the evaluation submission was successful.</p> <code>message</code> <code>str</code> <p>Response message.</p> <code>args</code> <code>Dict[str, Any]</code> <p>Additional arguments or data.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class EvaluationResponseModel:\n    \"\"\"\n    Represents the response model for an evaluation submission.\n\n    Attributes:\n        enola_id (Optional[str]): The Enola execution ID.\n        agent_deploy_id (Optional[str]): The agent deployment ID.\n        enola_eval_id (Optional[str]): The Enola evaluation ID.\n        successfull (Optional[bool]): Indicates if the evaluation submission was successful.\n        message (str): Response message.\n        args (Dict[str, Any]): Additional arguments or data.\n    \"\"\"\n\n    def __init__(\n        self,\n        enola_id: str = \"\",\n        agent_deploy_id: str = \"\",\n        enola_eval_id: str = \"\",\n        successfull: Optional[bool] = True,\n        message: str = \"\",\n        **args,\n    ):\n        \"\"\"\n        Initializes a new instance of EvaluationResponseModel.\n\n        Args:\n            enola_id (str, optional): The Enola execution ID.\n            agent_deploy_id (str, optional): The agent deployment ID.\n            enola_eval_id (str, optional): The Enola evaluation ID.\n            successfull (bool, optional): Indicates if the evaluation submission was successful.\n            message (str, optional): Response message.\n            **args: Additional keyword arguments.\n        \"\"\"\n        self.enola_id = enola_id or args.get(\"enolaId\")\n        self.agent_deploy_id = agent_deploy_id or args.get(\"agentDeployId\")\n        self.enola_eval_id = enola_eval_id or args.get(\"enolaEvalId\")\n        self.successfull = successfull if successfull != \"\" else args.get(\"IsSuccessfull\")\n        self.message = message\n        self.args = args\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the EvaluationResponseModel instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the EvaluationResponseModel.\n        \"\"\"\n        return {\n            \"enolaId\": self.enola_id,\n            \"agentDeployId\": self.agent_deploy_id,\n            \"enolaEvalId\": self.enola_eval_id,\n            \"successfull\": self.successfull,\n            \"message\": self.message,\n            \"args\": self.args,\n        }\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__.get(key)\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationResponseModel.__init__","title":"<code>__init__(enola_id='', agent_deploy_id='', enola_eval_id='', successfull=True, message='', **args)</code>","text":"<p>Initializes a new instance of EvaluationResponseModel.</p> <p>Parameters:</p> Name Type Description Default <code>enola_id</code> <code>str</code> <p>The Enola execution ID.</p> <code>''</code> <code>agent_deploy_id</code> <code>str</code> <p>The agent deployment ID.</p> <code>''</code> <code>enola_eval_id</code> <code>str</code> <p>The Enola evaluation ID.</p> <code>''</code> <code>successfull</code> <code>bool</code> <p>Indicates if the evaluation submission was successful.</p> <code>True</code> <code>message</code> <code>str</code> <p>Response message.</p> <code>''</code> <code>**args</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(\n    self,\n    enola_id: str = \"\",\n    agent_deploy_id: str = \"\",\n    enola_eval_id: str = \"\",\n    successfull: Optional[bool] = True,\n    message: str = \"\",\n    **args,\n):\n    \"\"\"\n    Initializes a new instance of EvaluationResponseModel.\n\n    Args:\n        enola_id (str, optional): The Enola execution ID.\n        agent_deploy_id (str, optional): The agent deployment ID.\n        enola_eval_id (str, optional): The Enola evaluation ID.\n        successfull (bool, optional): Indicates if the evaluation submission was successful.\n        message (str, optional): Response message.\n        **args: Additional keyword arguments.\n    \"\"\"\n    self.enola_id = enola_id or args.get(\"enolaId\")\n    self.agent_deploy_id = agent_deploy_id or args.get(\"agentDeployId\")\n    self.enola_eval_id = enola_eval_id or args.get(\"enolaEvalId\")\n    self.successfull = successfull if successfull != \"\" else args.get(\"IsSuccessfull\")\n    self.message = message\n    self.args = args\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationResponseModel.to_json","title":"<code>to_json()</code>","text":"<p>Converts the EvaluationResponseModel instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the EvaluationResponseModel.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the EvaluationResponseModel instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the EvaluationResponseModel.\n    \"\"\"\n    return {\n        \"enolaId\": self.enola_id,\n        \"agentDeployId\": self.agent_deploy_id,\n        \"enolaEvalId\": self.enola_eval_id,\n        \"successfull\": self.successfull,\n        \"message\": self.message,\n        \"args\": self.args,\n    }\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationResultModel","title":"<code>EvaluationResultModel</code>","text":"<p>Represents the result of an evaluation process.</p> <p>Attributes:</p> Name Type Description <code>total_evals</code> <code>int</code> <p>Total number of evaluations processed.</p> <code>total_errors</code> <code>int</code> <p>Total number of errors encountered.</p> <code>total_success</code> <code>int</code> <p>Total number of successful evaluations.</p> <code>errors</code> <code>List[Any]</code> <p>List of errors.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class EvaluationResultModel:\n    \"\"\"\n    Represents the result of an evaluation process.\n\n    Attributes:\n        total_evals (int): Total number of evaluations processed.\n        total_errors (int): Total number of errors encountered.\n        total_success (int): Total number of successful evaluations.\n        errors (List[Any]): List of errors.\n    \"\"\"\n\n    def __init__(self, total_evals: int, total_errors: int, total_success: int, errors: List[Any]):\n        \"\"\"\n        Initializes a new instance of EvaluationResultModel.\n\n        Args:\n            total_evals (int): Total number of evaluations processed.\n            total_errors (int): Total number of errors encountered.\n            total_success (int): Total number of successful evaluations.\n            errors (List[Any]): List of errors.\n        \"\"\"\n        self.total_evals = total_evals\n        self.total_errors = total_errors\n        self.total_success = total_success\n        self.errors = errors\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationResultModel.__init__","title":"<code>__init__(total_evals, total_errors, total_success, errors)</code>","text":"<p>Initializes a new instance of EvaluationResultModel.</p> <p>Parameters:</p> Name Type Description Default <code>total_evals</code> <code>int</code> <p>Total number of evaluations processed.</p> required <code>total_errors</code> <code>int</code> <p>Total number of errors encountered.</p> required <code>total_success</code> <code>int</code> <p>Total number of successful evaluations.</p> required <code>errors</code> <code>List[Any]</code> <p>List of errors.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self, total_evals: int, total_errors: int, total_success: int, errors: List[Any]):\n    \"\"\"\n    Initializes a new instance of EvaluationResultModel.\n\n    Args:\n        total_evals (int): Total number of evaluations processed.\n        total_errors (int): Total number of errors encountered.\n        total_success (int): Total number of successful evaluations.\n        errors (List[Any]): List of errors.\n    \"\"\"\n    self.total_evals = total_evals\n    self.total_errors = total_errors\n    self.total_success = total_success\n    self.errors = errors\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ExecutionDataFilter","title":"<code>ExecutionDataFilter</code>","text":"<p>Represents a data filter for execution queries.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the data field.</p> <code>value</code> <code>Any</code> <p>Value to filter on.</p> <code>type</code> <code>DataType</code> <p>Type of the data field.</p> <code>compare</code> <code>CompareType</code> <p>Comparison operator to use.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class ExecutionDataFilter:\n    \"\"\"\n    Represents a data filter for execution queries.\n\n    Attributes:\n        name (str): Name of the data field.\n        value (Any): Value to filter on.\n        type (DataType): Type of the data field.\n        compare (CompareType): Comparison operator to use.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        value: Any,\n        type: 'DataType' = 'DataType.TEXT',\n        compare: 'CompareType' = 'CompareType.EQUAL',\n    ):\n        \"\"\"\n        Initializes a new instance of ExecutionDataFilter.\n\n        Args:\n            name (str): Name of the data field.\n            value (Any): Value to filter on.\n            type (DataType, optional): Type of the data field.\n            compare (CompareType, optional): Comparison operator to use.\n        \"\"\"\n        self.name = name\n        self.value = value\n        self.type = type\n        self.compare = compare\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the ExecutionDataFilter instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the ExecutionDataFilter.\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"value\": self.value,\n            \"type\": self.type.value,\n            \"compare\": self.compare.value,\n        }\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ExecutionDataFilter.__init__","title":"<code>__init__(name, value, type='DataType.TEXT', compare='CompareType.EQUAL')</code>","text":"<p>Initializes a new instance of ExecutionDataFilter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the data field.</p> required <code>value</code> <code>Any</code> <p>Value to filter on.</p> required <code>type</code> <code>DataType</code> <p>Type of the data field.</p> <code>'DataType.TEXT'</code> <code>compare</code> <code>CompareType</code> <p>Comparison operator to use.</p> <code>'CompareType.EQUAL'</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    value: Any,\n    type: 'DataType' = 'DataType.TEXT',\n    compare: 'CompareType' = 'CompareType.EQUAL',\n):\n    \"\"\"\n    Initializes a new instance of ExecutionDataFilter.\n\n    Args:\n        name (str): Name of the data field.\n        value (Any): Value to filter on.\n        type (DataType, optional): Type of the data field.\n        compare (CompareType, optional): Comparison operator to use.\n    \"\"\"\n    self.name = name\n    self.value = value\n    self.type = type\n    self.compare = compare\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ExecutionDataFilter.to_json","title":"<code>to_json()</code>","text":"<p>Converts the ExecutionDataFilter instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the ExecutionDataFilter.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the ExecutionDataFilter instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the ExecutionDataFilter.\n    \"\"\"\n    return {\n        \"name\": self.name,\n        \"value\": self.value,\n        \"type\": self.type.value,\n        \"compare\": self.compare.value,\n    }\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ExecutionEvalFilter","title":"<code>ExecutionEvalFilter</code>","text":"<p>Represents a filter for execution evaluations.</p> <p>Attributes:</p> Name Type Description <code>eval_id</code> <code>List[str]</code> <p>List of evaluation IDs.</p> <code>include</code> <code>bool</code> <p>Indicates if the evaluations should be included or excluded.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class ExecutionEvalFilter:\n    \"\"\"\n    Represents a filter for execution evaluations.\n\n    Attributes:\n        eval_id (List[str]): List of evaluation IDs.\n        include (bool): Indicates if the evaluations should be included or excluded.\n    \"\"\"\n\n    def __init__(self, eval_id: List[str], include: bool = True):\n        \"\"\"\n        Initializes a new instance of ExecutionEvalFilter.\n\n        Args:\n            eval_id (List[str]): List of evaluation IDs.\n            include (bool, optional): Indicates if the evaluations should be included or excluded.\n        \"\"\"\n        self.eval_id = eval_id\n        self.include = include\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ExecutionEvalFilter.__init__","title":"<code>__init__(eval_id, include=True)</code>","text":"<p>Initializes a new instance of ExecutionEvalFilter.</p> <p>Parameters:</p> Name Type Description Default <code>eval_id</code> <code>List[str]</code> <p>List of evaluation IDs.</p> required <code>include</code> <code>bool</code> <p>Indicates if the evaluations should be included or excluded.</p> <code>True</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self, eval_id: List[str], include: bool = True):\n    \"\"\"\n    Initializes a new instance of ExecutionEvalFilter.\n\n    Args:\n        eval_id (List[str]): List of evaluation IDs.\n        include (bool, optional): Indicates if the evaluations should be included or excluded.\n    \"\"\"\n    self.eval_id = eval_id\n    self.include = include\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ExecutionModel","title":"<code>ExecutionModel</code>","text":"<p>Represents an execution model containing data and status.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>List[Any]</code> <p>The execution data.</p> <code>successfull</code> <code>bool</code> <p>Indicates if the execution was successful.</p> <code>message</code> <code>str</code> <p>Response message.</p> <code>args</code> <code>Dict[str, Any]</code> <p>Additional arguments.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class ExecutionModel:\n    \"\"\"\n    Represents an execution model containing data and status.\n\n    Attributes:\n        data (List[Any]): The execution data.\n        successfull (bool): Indicates if the execution was successful.\n        message (str): Response message.\n        args (Dict[str, Any]): Additional arguments.\n    \"\"\"\n\n    def __init__(self, data: List[Any], successfull: bool, message: str, **args):\n        \"\"\"\n        Initializes a new instance of ExecutionModel.\n\n        Args:\n            data (List[Any]): The execution data.\n            successfull (bool): Indicates if the execution was successful.\n            message (str): Response message.\n            **args: Additional keyword arguments.\n        \"\"\"\n        self.data = data\n        self.successfull = successfull\n        self.message = message\n        self.args = args\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ExecutionModel.__init__","title":"<code>__init__(data, successfull, message, **args)</code>","text":"<p>Initializes a new instance of ExecutionModel.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>List[Any]</code> <p>The execution data.</p> required <code>successfull</code> <code>bool</code> <p>Indicates if the execution was successful.</p> required <code>message</code> <code>str</code> <p>Response message.</p> required <code>**args</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self, data: List[Any], successfull: bool, message: str, **args):\n    \"\"\"\n    Initializes a new instance of ExecutionModel.\n\n    Args:\n        data (List[Any]): The execution data.\n        successfull (bool): Indicates if the execution was successful.\n        message (str): Response message.\n        **args: Additional keyword arguments.\n    \"\"\"\n    self.data = data\n    self.successfull = successfull\n    self.message = message\n    self.args = args\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ExecutionQueryModel","title":"<code>ExecutionQueryModel</code>","text":"<p>Represents a query model for fetching executions.</p> <p>Attributes:</p> Name Type Description <code>date_from</code> <code>str</code> <p>Start date for the query.</p> <code>date_to</code> <code>str</code> <p>End date for the query.</p> <code>chamber_id_list</code> <code>List[str]</code> <p>List of chamber IDs.</p> <code>agent_id_list</code> <code>List[str]</code> <p>List of agent IDs.</p> <code>agent_deploy_id_list</code> <code>List[str]</code> <p>List of agent deployment IDs.</p> <code>user_id_list</code> <code>List[str]</code> <p>List of user IDs.</p> <code>session_id_list</code> <code>List[str]</code> <p>List of session IDs.</p> <code>channel_id_list</code> <code>List[str]</code> <p>List of channel IDs.</p> <code>data_filter_list</code> <code>List[ExecutionDataFilter]</code> <p>List of data filters.</p> <code>eval_id_user</code> <code>ExecutionEvalFilter</code> <p>User evaluation filter.</p> <code>eval_id_internal</code> <code>ExecutionEvalFilter</code> <p>Internal evaluation filter.</p> <code>eval_id_auto</code> <code>ExecutionEvalFilter</code> <p>Automatic evaluation filter.</p> <code>environment_id</code> <code>Environtment</code> <p>Environment identifier.</p> <code>is_test_plan</code> <code>bool</code> <p>Indicates if it's a test plan.</p> <code>finished</code> <code>bool</code> <p>Indicates if the execution is finished.</p> <code>limit</code> <code>int</code> <p>Limit of records per page.</p> <code>page_number</code> <code>int</code> <p>Page number for pagination.</p> <code>include_tags</code> <code>bool</code> <p>Include tags in the response.</p> <code>include_data</code> <code>bool</code> <p>Include data in the response.</p> <code>include_errors</code> <code>bool</code> <p>Include errors in the response.</p> <code>include_evals</code> <code>bool</code> <p>Include evaluations in the response.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class ExecutionQueryModel:\n    \"\"\"\n    Represents a query model for fetching executions.\n\n    Attributes:\n        date_from (str): Start date for the query.\n        date_to (str): End date for the query.\n        chamber_id_list (List[str]): List of chamber IDs.\n        agent_id_list (List[str]): List of agent IDs.\n        agent_deploy_id_list (List[str]): List of agent deployment IDs.\n        user_id_list (List[str]): List of user IDs.\n        session_id_list (List[str]): List of session IDs.\n        channel_id_list (List[str]): List of channel IDs.\n        data_filter_list (List[ExecutionDataFilter]): List of data filters.\n        eval_id_user (ExecutionEvalFilter): User evaluation filter.\n        eval_id_internal (ExecutionEvalFilter): Internal evaluation filter.\n        eval_id_auto (ExecutionEvalFilter): Automatic evaluation filter.\n        environment_id (Environtment): Environment identifier.\n        is_test_plan (bool): Indicates if it's a test plan.\n        finished (bool): Indicates if the execution is finished.\n        limit (int): Limit of records per page.\n        page_number (int): Page number for pagination.\n        include_tags (bool): Include tags in the response.\n        include_data (bool): Include data in the response.\n        include_errors (bool): Include errors in the response.\n        include_evals (bool): Include evaluations in the response.\n    \"\"\"\n\n    def __init__(\n        self,\n        date_from: str,\n        date_to: str,\n        chamber_id_list: List[str] = None,\n        agent_id_list: List[str] = None,\n        agent_deploy_id_list: List[str] = None,\n        user_id_list: List[str] = None,\n        session_id_list: List[str] = None,\n        channel_id_list: List[str] = None,\n        data_filter_list: List[ExecutionDataFilter] = None,\n        eval_id_user: Optional[ExecutionEvalFilter] = None,\n        eval_id_internal: Optional[ExecutionEvalFilter] = None,\n        eval_id_auto: Optional[ExecutionEvalFilter] = None,\n        environment_id: Optional['Environtment'] = None,\n        is_test_plan: Optional[bool] = None,\n        finished: Optional[bool] = None,\n        limit: int = 100,\n        page_number: int = 1,\n        include_tags: bool = False,\n        include_data: bool = False,\n        include_errors: bool = False,\n        include_evals: bool = False,\n    ):\n        \"\"\"\n        Initializes a new instance of ExecutionQueryModel.\n\n        Args:\n            date_from (str): Start date for the query.\n            date_to (str): End date for the query.\n            chamber_id_list (List[str], optional): List of chamber IDs.\n            agent_id_list (List[str], optional): List of agent IDs.\n            agent_deploy_id_list (List[str], optional): List of agent deployment IDs.\n            user_id_list (List[str], optional): List of user IDs.\n            session_id_list (List[str], optional): List of session IDs.\n            channel_id_list (List[str], optional): List of channel IDs.\n            data_filter_list (List[ExecutionDataFilter], optional): List of data filters.\n            eval_id_user (ExecutionEvalFilter, optional): User evaluation filter.\n            eval_id_internal (ExecutionEvalFilter, optional): Internal evaluation filter.\n            eval_id_auto (ExecutionEvalFilter, optional): Automatic evaluation filter.\n            environment_id (Environtment, optional): Environment identifier.\n            is_test_plan (bool, optional): Indicates if it's a test plan.\n            finished (bool, optional): Indicates if the execution is finished.\n            limit (int, optional): Limit of records per page.\n            page_number (int, optional): Page number for pagination.\n            include_tags (bool, optional): Include tags in the response.\n            include_data (bool, optional): Include data in the response.\n            include_errors (bool, optional): Include errors in the response.\n            include_evals (bool, optional): Include evaluations in the response.\n        \"\"\"\n        self.date_from = date_from\n        self.date_to = date_to\n        self.chamber_id_list = chamber_id_list or []\n        self.agent_id_list = agent_id_list or []\n        self.agent_deploy_id_list = agent_deploy_id_list or []\n        self.user_id_list = user_id_list or []\n        self.session_id_list = session_id_list or []\n        self.channel_id_list = channel_id_list or []\n        self.data_filter_list = data_filter_list or []\n        self.eval_id_user = eval_id_user\n        self.eval_id_internal = eval_id_internal\n        self.eval_id_auto = eval_id_auto\n        self.environment_id = environment_id\n        self.is_test_plan = is_test_plan\n        self.finished = finished\n        self.limit = limit\n        self.page_number = page_number\n        self.include_tags = include_tags\n        self.include_data = include_data\n        self.include_errors = include_errors\n        self.include_evals = include_evals\n\n        if not date_from:\n            raise ValueError(\"date_from is empty.\")\n        if not date_to:\n            raise ValueError(\"date_to is empty.\")\n        if limit &lt;= 0:\n            raise ValueError(\"limit must be greater than 0.\")\n        if page_number &lt; 0:\n            raise ValueError(\"page_number must be 0 or greater.\")\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ExecutionQueryModel.__init__","title":"<code>__init__(date_from, date_to, chamber_id_list=None, agent_id_list=None, agent_deploy_id_list=None, user_id_list=None, session_id_list=None, channel_id_list=None, data_filter_list=None, eval_id_user=None, eval_id_internal=None, eval_id_auto=None, environment_id=None, is_test_plan=None, finished=None, limit=100, page_number=1, include_tags=False, include_data=False, include_errors=False, include_evals=False)</code>","text":"<p>Initializes a new instance of ExecutionQueryModel.</p> <p>Parameters:</p> Name Type Description Default <code>date_from</code> <code>str</code> <p>Start date for the query.</p> required <code>date_to</code> <code>str</code> <p>End date for the query.</p> required <code>chamber_id_list</code> <code>List[str]</code> <p>List of chamber IDs.</p> <code>None</code> <code>agent_id_list</code> <code>List[str]</code> <p>List of agent IDs.</p> <code>None</code> <code>agent_deploy_id_list</code> <code>List[str]</code> <p>List of agent deployment IDs.</p> <code>None</code> <code>user_id_list</code> <code>List[str]</code> <p>List of user IDs.</p> <code>None</code> <code>session_id_list</code> <code>List[str]</code> <p>List of session IDs.</p> <code>None</code> <code>channel_id_list</code> <code>List[str]</code> <p>List of channel IDs.</p> <code>None</code> <code>data_filter_list</code> <code>List[ExecutionDataFilter]</code> <p>List of data filters.</p> <code>None</code> <code>eval_id_user</code> <code>ExecutionEvalFilter</code> <p>User evaluation filter.</p> <code>None</code> <code>eval_id_internal</code> <code>ExecutionEvalFilter</code> <p>Internal evaluation filter.</p> <code>None</code> <code>eval_id_auto</code> <code>ExecutionEvalFilter</code> <p>Automatic evaluation filter.</p> <code>None</code> <code>environment_id</code> <code>Environtment</code> <p>Environment identifier.</p> <code>None</code> <code>is_test_plan</code> <code>bool</code> <p>Indicates if it's a test plan.</p> <code>None</code> <code>finished</code> <code>bool</code> <p>Indicates if the execution is finished.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Limit of records per page.</p> <code>100</code> <code>page_number</code> <code>int</code> <p>Page number for pagination.</p> <code>1</code> <code>include_tags</code> <code>bool</code> <p>Include tags in the response.</p> <code>False</code> <code>include_data</code> <code>bool</code> <p>Include data in the response.</p> <code>False</code> <code>include_errors</code> <code>bool</code> <p>Include errors in the response.</p> <code>False</code> <code>include_evals</code> <code>bool</code> <p>Include evaluations in the response.</p> <code>False</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(\n    self,\n    date_from: str,\n    date_to: str,\n    chamber_id_list: List[str] = None,\n    agent_id_list: List[str] = None,\n    agent_deploy_id_list: List[str] = None,\n    user_id_list: List[str] = None,\n    session_id_list: List[str] = None,\n    channel_id_list: List[str] = None,\n    data_filter_list: List[ExecutionDataFilter] = None,\n    eval_id_user: Optional[ExecutionEvalFilter] = None,\n    eval_id_internal: Optional[ExecutionEvalFilter] = None,\n    eval_id_auto: Optional[ExecutionEvalFilter] = None,\n    environment_id: Optional['Environtment'] = None,\n    is_test_plan: Optional[bool] = None,\n    finished: Optional[bool] = None,\n    limit: int = 100,\n    page_number: int = 1,\n    include_tags: bool = False,\n    include_data: bool = False,\n    include_errors: bool = False,\n    include_evals: bool = False,\n):\n    \"\"\"\n    Initializes a new instance of ExecutionQueryModel.\n\n    Args:\n        date_from (str): Start date for the query.\n        date_to (str): End date for the query.\n        chamber_id_list (List[str], optional): List of chamber IDs.\n        agent_id_list (List[str], optional): List of agent IDs.\n        agent_deploy_id_list (List[str], optional): List of agent deployment IDs.\n        user_id_list (List[str], optional): List of user IDs.\n        session_id_list (List[str], optional): List of session IDs.\n        channel_id_list (List[str], optional): List of channel IDs.\n        data_filter_list (List[ExecutionDataFilter], optional): List of data filters.\n        eval_id_user (ExecutionEvalFilter, optional): User evaluation filter.\n        eval_id_internal (ExecutionEvalFilter, optional): Internal evaluation filter.\n        eval_id_auto (ExecutionEvalFilter, optional): Automatic evaluation filter.\n        environment_id (Environtment, optional): Environment identifier.\n        is_test_plan (bool, optional): Indicates if it's a test plan.\n        finished (bool, optional): Indicates if the execution is finished.\n        limit (int, optional): Limit of records per page.\n        page_number (int, optional): Page number for pagination.\n        include_tags (bool, optional): Include tags in the response.\n        include_data (bool, optional): Include data in the response.\n        include_errors (bool, optional): Include errors in the response.\n        include_evals (bool, optional): Include evaluations in the response.\n    \"\"\"\n    self.date_from = date_from\n    self.date_to = date_to\n    self.chamber_id_list = chamber_id_list or []\n    self.agent_id_list = agent_id_list or []\n    self.agent_deploy_id_list = agent_deploy_id_list or []\n    self.user_id_list = user_id_list or []\n    self.session_id_list = session_id_list or []\n    self.channel_id_list = channel_id_list or []\n    self.data_filter_list = data_filter_list or []\n    self.eval_id_user = eval_id_user\n    self.eval_id_internal = eval_id_internal\n    self.eval_id_auto = eval_id_auto\n    self.environment_id = environment_id\n    self.is_test_plan = is_test_plan\n    self.finished = finished\n    self.limit = limit\n    self.page_number = page_number\n    self.include_tags = include_tags\n    self.include_data = include_data\n    self.include_errors = include_errors\n    self.include_evals = include_evals\n\n    if not date_from:\n        raise ValueError(\"date_from is empty.\")\n    if not date_to:\n        raise ValueError(\"date_to is empty.\")\n    if limit &lt;= 0:\n        raise ValueError(\"limit must be greater than 0.\")\n    if page_number &lt; 0:\n        raise ValueError(\"page_number must be 0 or greater.\")\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ExecutionResponseModel","title":"<code>ExecutionResponseModel</code>","text":"<p>Represents the response model for an execution.</p> <p>Attributes:</p> Name Type Description <code>enola_id</code> <code>str</code> <p>Enola execution ID.</p> <code>enola_id_related</code> <code>str</code> <p>Related Enola execution ID.</p> <code>agent_deploy_id</code> <code>str</code> <p>Agent deployment ID.</p> <code>agent_deploy_name</code> <code>str</code> <p>Agent deployment name.</p> <code>agent_id</code> <code>str</code> <p>Agent ID.</p> <code>agent_name</code> <code>str</code> <p>Agent name.</p> <code>name</code> <code>str</code> <p>Execution name.</p> <code>start_dt</code> <code>str</code> <p>Start date and time of execution.</p> <code>end_dt</code> <code>str</code> <p>End date and time of execution.</p> <code>duration_ms</code> <code>int</code> <p>Duration in milliseconds.</p> <code>num_tracking</code> <code>str</code> <p>Number of tracking entries.</p> <code>is_test</code> <code>bool</code> <p>Indicates if the execution is a test.</p> <code>environment_id</code> <code>str</code> <p>Environment identifier.</p> <code>app_id</code> <code>str</code> <p>Application ID.</p> <code>app_name</code> <code>str</code> <p>Application name.</p> <code>user_id</code> <code>str</code> <p>User ID.</p> <code>user_name</code> <code>str</code> <p>User name.</p> <code>session_id</code> <code>str</code> <p>Session ID.</p> <code>session_name</code> <code>str</code> <p>Session name.</p> <code>channel</code> <code>str</code> <p>Channel ID.</p> <code>channel_name</code> <code>str</code> <p>Channel name.</p> <code>message_input</code> <code>str</code> <p>Input message.</p> <code>message_output</code> <code>str</code> <p>Output message.</p> <code>tag_json</code> <code>json</code> <p>JSON representation of tags.</p> <code>file_info_json</code> <code>json</code> <p>JSON representation of file information.</p> <code>data_json</code> <code>json</code> <p>JSON representation of data.</p> <code>error_or_warning_json</code> <code>json</code> <p>JSON representation of errors or warnings.</p> <code>step_api_data_json</code> <code>json</code> <p>JSON representation of API data.</p> <code>info_json</code> <code>json</code> <p>JSON representation of additional info.</p> <code>evals</code> <code>json</code> <p>JSON representation of evaluations.</p> <code>ip</code> <code>str</code> <p>IP address.</p> <code>num_iter</code> <code>int</code> <p>Number of iterations.</p> <code>external_id</code> <code>str</code> <p>External code API identifier.</p> <code>successfull</code> <code>bool</code> <p>Indicates if the execution was successful.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class ExecutionResponseModel:\n    \"\"\"\n    Represents the response model for an execution.\n\n    Attributes:\n        enola_id (str): Enola execution ID.\n        enola_id_related (str): Related Enola execution ID.\n        agent_deploy_id (str): Agent deployment ID.\n        agent_deploy_name (str): Agent deployment name.\n        agent_id (str): Agent ID.\n        agent_name (str): Agent name.\n        name (str): Execution name.\n        start_dt (str): Start date and time of execution.\n        end_dt (str): End date and time of execution.\n        duration_ms (int): Duration in milliseconds.\n        num_tracking (str): Number of tracking entries.\n        is_test (bool): Indicates if the execution is a test.\n        environment_id (str): Environment identifier.\n        app_id (str): Application ID.\n        app_name (str): Application name.\n        user_id (str): User ID.\n        user_name (str): User name.\n        session_id (str): Session ID.\n        session_name (str): Session name.\n        channel (str): Channel ID.\n        channel_name (str): Channel name.\n        message_input (str): Input message.\n        message_output (str): Output message.\n        tag_json (json): JSON representation of tags.\n        file_info_json (json): JSON representation of file information.\n        data_json (json): JSON representation of data.\n        error_or_warning_json (json): JSON representation of errors or warnings.\n        step_api_data_json (json): JSON representation of API data.\n        info_json (json): JSON representation of additional info.\n        evals (json): JSON representation of evaluations.\n        ip (str): IP address.\n        num_iter (int): Number of iterations.\n        external_id (str): External code API identifier.\n        successfull (bool): Indicates if the execution was successful.\n    \"\"\"\n\n    def __init__(\n        self,\n        agentExecId: str,\n        agentExecIdRelated: str,\n        agentDeployId: str,\n        agentDeployName: str,\n        agentId: str,\n        agentName: str,\n        agentExecName: str,\n        agentExecStartDT: str,\n        agentExecEndDT: str,\n        agentExecDurationMs: int,\n        agentExecNumTracking: str,\n        agentExecIsTest: bool,\n        environmentId: str,\n        agentExecCliAppId: str,\n        agentExecCliAppName: str,\n        agentExecCliUserId: str,\n        agentExecCliUserName: str,\n        agentExecCliSessionId: str,\n        agentExecCliSessionName: str,\n        agentExecCliChannel: str,\n        agentExecCliChannelName: str,\n        agentExecMessageInput: str,\n        agentExecMessageOutput: str,\n        agentExecTagJson: json,\n        agentExecFileInfoJson: json,\n        agentExecDataJson: json,\n        agentExecErrorOrWarningJson: json,\n        agentExecStepApiDataJson: json,\n        agentExecInfoJson: json,\n        agentExecEvals: json,\n        agentExecCliIP: str,\n        agentExecCliNumIter: int,\n        agentExecCliCodeApi: str,\n        agentExecSuccessfull: bool,\n        **args,\n    ):\n        \"\"\"\n        Initializes a new instance of ExecutionResponseModel.\n\n        Args:\n            All parameters correspond to execution response fields.\n            **args: Additional keyword arguments.\n        \"\"\"\n        self.enola_id = agentExecId\n        self.enola_id_related = agentExecIdRelated\n        self.agent_deploy_id = agentDeployId\n        self.agent_deploy_name = agentDeployName\n        self.agent_id = agentId\n        self.agent_name = agentName\n        self.name = agentExecName\n        self.start_dt = agentExecStartDT\n        self.end_dt = agentExecEndDT\n        self.duration_ms = agentExecDurationMs\n        self.num_tracking = agentExecNumTracking\n        self.is_test = agentExecIsTest\n        self.environment_id = environmentId\n        self.app_id = agentExecCliAppId\n        self.app_name = agentExecCliAppName\n        self.user_id = agentExecCliUserId\n        self.user_name = agentExecCliUserName\n        self.session_id = agentExecCliSessionId\n        self.session_name = agentExecCliSessionName\n        self.channel = agentExecCliChannel\n        self.channel_name = agentExecCliChannelName\n        self.message_input = agentExecMessageInput\n        self.message_output = agentExecMessageOutput\n        self.tag_json = agentExecTagJson\n        self.file_info_json = agentExecFileInfoJson\n        self.data_json = agentExecDataJson\n        self.error_or_warning_json = agentExecErrorOrWarningJson\n        self.step_api_data_json = agentExecStepApiDataJson\n        self.info_json = agentExecInfoJson\n        self.evals = agentExecEvals\n        self.ip = agentExecCliIP\n        self.num_iter = agentExecCliNumIter\n        self.external_id = agentExecCliCodeApi\n        self.successfull = agentExecSuccessfull\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ExecutionResponseModel.__init__","title":"<code>__init__(agentExecId, agentExecIdRelated, agentDeployId, agentDeployName, agentId, agentName, agentExecName, agentExecStartDT, agentExecEndDT, agentExecDurationMs, agentExecNumTracking, agentExecIsTest, environmentId, agentExecCliAppId, agentExecCliAppName, agentExecCliUserId, agentExecCliUserName, agentExecCliSessionId, agentExecCliSessionName, agentExecCliChannel, agentExecCliChannelName, agentExecMessageInput, agentExecMessageOutput, agentExecTagJson, agentExecFileInfoJson, agentExecDataJson, agentExecErrorOrWarningJson, agentExecStepApiDataJson, agentExecInfoJson, agentExecEvals, agentExecCliIP, agentExecCliNumIter, agentExecCliCodeApi, agentExecSuccessfull, **args)</code>","text":"<p>Initializes a new instance of ExecutionResponseModel.</p> <p>Parameters:</p> Name Type Description Default <code>**args</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(\n    self,\n    agentExecId: str,\n    agentExecIdRelated: str,\n    agentDeployId: str,\n    agentDeployName: str,\n    agentId: str,\n    agentName: str,\n    agentExecName: str,\n    agentExecStartDT: str,\n    agentExecEndDT: str,\n    agentExecDurationMs: int,\n    agentExecNumTracking: str,\n    agentExecIsTest: bool,\n    environmentId: str,\n    agentExecCliAppId: str,\n    agentExecCliAppName: str,\n    agentExecCliUserId: str,\n    agentExecCliUserName: str,\n    agentExecCliSessionId: str,\n    agentExecCliSessionName: str,\n    agentExecCliChannel: str,\n    agentExecCliChannelName: str,\n    agentExecMessageInput: str,\n    agentExecMessageOutput: str,\n    agentExecTagJson: json,\n    agentExecFileInfoJson: json,\n    agentExecDataJson: json,\n    agentExecErrorOrWarningJson: json,\n    agentExecStepApiDataJson: json,\n    agentExecInfoJson: json,\n    agentExecEvals: json,\n    agentExecCliIP: str,\n    agentExecCliNumIter: int,\n    agentExecCliCodeApi: str,\n    agentExecSuccessfull: bool,\n    **args,\n):\n    \"\"\"\n    Initializes a new instance of ExecutionResponseModel.\n\n    Args:\n        All parameters correspond to execution response fields.\n        **args: Additional keyword arguments.\n    \"\"\"\n    self.enola_id = agentExecId\n    self.enola_id_related = agentExecIdRelated\n    self.agent_deploy_id = agentDeployId\n    self.agent_deploy_name = agentDeployName\n    self.agent_id = agentId\n    self.agent_name = agentName\n    self.name = agentExecName\n    self.start_dt = agentExecStartDT\n    self.end_dt = agentExecEndDT\n    self.duration_ms = agentExecDurationMs\n    self.num_tracking = agentExecNumTracking\n    self.is_test = agentExecIsTest\n    self.environment_id = environmentId\n    self.app_id = agentExecCliAppId\n    self.app_name = agentExecCliAppName\n    self.user_id = agentExecCliUserId\n    self.user_name = agentExecCliUserName\n    self.session_id = agentExecCliSessionId\n    self.session_name = agentExecCliSessionName\n    self.channel = agentExecCliChannel\n    self.channel_name = agentExecCliChannelName\n    self.message_input = agentExecMessageInput\n    self.message_output = agentExecMessageOutput\n    self.tag_json = agentExecTagJson\n    self.file_info_json = agentExecFileInfoJson\n    self.data_json = agentExecDataJson\n    self.error_or_warning_json = agentExecErrorOrWarningJson\n    self.step_api_data_json = agentExecStepApiDataJson\n    self.info_json = agentExecInfoJson\n    self.evals = agentExecEvals\n    self.ip = agentExecCliIP\n    self.num_iter = agentExecCliNumIter\n    self.external_id = agentExecCliCodeApi\n    self.successfull = agentExecSuccessfull\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.FileInfoModel","title":"<code>FileInfoModel</code>","text":"<p>Represents information about a file related to a step.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the file.</p> <code>url</code> <code>str</code> <p>The URL where the file is located.</p> <code>type</code> <code>str</code> <p>The type of the file (e.g., 'image/png').</p> <code>size</code> <code>int</code> <p>The size of the file in kilobytes.</p> <code>description</code> <code>str</code> <p>A description of the file.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class FileInfoModel:\n    \"\"\"\n    Represents information about a file related to a step.\n\n    Attributes:\n        name (str): The name of the file.\n        url (str): The URL where the file is located.\n        type (str): The type of the file (e.g., 'image/png').\n        size (int): The size of the file in kilobytes.\n        description (str): A description of the file.\n    \"\"\"\n\n    def __init__(self, name: str, url: str, type: str, sizeKb: int, description: str):\n        \"\"\"\n        Initializes a new instance of FileInfoModel.\n\n        Args:\n            name (str): The name of the file.\n            url (str): The URL where the file is located.\n            type (str): The type of the file (e.g., 'image/png').\n            sizeKb (int): The size of the file in kilobytes.\n            description (str): A description of the file.\n        \"\"\"\n        self.name = name\n        self.url = url\n        self.type = type\n        self.size = sizeKb\n        self.description = description\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the FileInfoModel instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the FileInfoModel.\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"url\": self.url,\n            \"type\": self.type,\n            \"size\": self.size,\n            \"description\": self.description\n        }\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.FileInfoModel.__init__","title":"<code>__init__(name, url, type, sizeKb, description)</code>","text":"<p>Initializes a new instance of FileInfoModel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the file.</p> required <code>url</code> <code>str</code> <p>The URL where the file is located.</p> required <code>type</code> <code>str</code> <p>The type of the file (e.g., 'image/png').</p> required <code>sizeKb</code> <code>int</code> <p>The size of the file in kilobytes.</p> required <code>description</code> <code>str</code> <p>A description of the file.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self, name: str, url: str, type: str, sizeKb: int, description: str):\n    \"\"\"\n    Initializes a new instance of FileInfoModel.\n\n    Args:\n        name (str): The name of the file.\n        url (str): The URL where the file is located.\n        type (str): The type of the file (e.g., 'image/png').\n        sizeKb (int): The size of the file in kilobytes.\n        description (str): A description of the file.\n    \"\"\"\n    self.name = name\n    self.url = url\n    self.type = type\n    self.size = sizeKb\n    self.description = description\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.FileInfoModel.to_json","title":"<code>to_json()</code>","text":"<p>Converts the FileInfoModel instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the FileInfoModel.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the FileInfoModel instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the FileInfoModel.\n    \"\"\"\n    return {\n        \"name\": self.name,\n        \"url\": self.url,\n        \"type\": self.type,\n        \"size\": self.size,\n        \"description\": self.description\n    }\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Info","title":"<code>Info</code>","text":"<p>Represents an information item, which can be a tag or extra information.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>The type of information ('tag' or 'info').</p> <code>key</code> <code>str</code> <p>The key of the information item.</p> <code>value</code> <code>Any</code> <p>The value of the information item.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class Info:\n    \"\"\"\n    Represents an information item, which can be a tag or extra information.\n\n    Attributes:\n        type (str): The type of information ('tag' or 'info').\n        key (str): The key of the information item.\n        value (Any): The value of the information item.\n    \"\"\"\n\n    def __init__(self, type: str, key: str, value: Any):\n        \"\"\"\n        Initializes a new instance of Info.\n\n        Args:\n            type (str): The type of information ('tag' or 'info').\n            key (str): The key of the information item.\n            value (Any): The value of the information item.\n        \"\"\"\n        self.type = type\n        self.key = key\n        if self.is_numeric(value):\n            self.value = value\n        elif self.is_string(value):\n            if self.is_dict(value):\n                self.value = json.dumps(value)\n            else:\n                self.value = value\n        else:\n            self.value = value\n\n    def is_numeric(self, value: Any) -&gt; bool:\n        \"\"\"\n        Checks if the value is numeric.\n\n        Args:\n            value (Any): The value to check.\n\n        Returns:\n            bool: True if the value is numeric, False otherwise.\n        \"\"\"\n        return isinstance(value, (int, float, complex))\n\n    def is_string(self, value: Any) -&gt; bool:\n        \"\"\"\n        Checks if the value is a string.\n\n        Args:\n            value (Any): The value to check.\n\n        Returns:\n            bool: True if the value is a string, False otherwise.\n        \"\"\"\n        return isinstance(value, str)\n\n    def is_dict(self, value: Any) -&gt; bool:\n        \"\"\"\n        Checks if the value is a dictionary.\n\n        Args:\n            value (Any): The value to check.\n\n        Returns:\n            bool: True if the value is a dictionary, False otherwise.\n        \"\"\"\n        return isinstance(value, dict)\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the Info instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the Info.\n        \"\"\"\n        return {\n            \"type\": self.type,\n            \"key\": self.key,\n            \"value\": self.value\n        }\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Info.__init__","title":"<code>__init__(type, key, value)</code>","text":"<p>Initializes a new instance of Info.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>The type of information ('tag' or 'info').</p> required <code>key</code> <code>str</code> <p>The key of the information item.</p> required <code>value</code> <code>Any</code> <p>The value of the information item.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self, type: str, key: str, value: Any):\n    \"\"\"\n    Initializes a new instance of Info.\n\n    Args:\n        type (str): The type of information ('tag' or 'info').\n        key (str): The key of the information item.\n        value (Any): The value of the information item.\n    \"\"\"\n    self.type = type\n    self.key = key\n    if self.is_numeric(value):\n        self.value = value\n    elif self.is_string(value):\n        if self.is_dict(value):\n            self.value = json.dumps(value)\n        else:\n            self.value = value\n    else:\n        self.value = value\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Info.is_dict","title":"<code>is_dict(value)</code>","text":"<p>Checks if the value is a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value is a dictionary, False otherwise.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def is_dict(self, value: Any) -&gt; bool:\n    \"\"\"\n    Checks if the value is a dictionary.\n\n    Args:\n        value (Any): The value to check.\n\n    Returns:\n        bool: True if the value is a dictionary, False otherwise.\n    \"\"\"\n    return isinstance(value, dict)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Info.is_numeric","title":"<code>is_numeric(value)</code>","text":"<p>Checks if the value is numeric.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value is numeric, False otherwise.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def is_numeric(self, value: Any) -&gt; bool:\n    \"\"\"\n    Checks if the value is numeric.\n\n    Args:\n        value (Any): The value to check.\n\n    Returns:\n        bool: True if the value is numeric, False otherwise.\n    \"\"\"\n    return isinstance(value, (int, float, complex))\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Info.is_string","title":"<code>is_string(value)</code>","text":"<p>Checks if the value is a string.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value is a string, False otherwise.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def is_string(self, value: Any) -&gt; bool:\n    \"\"\"\n    Checks if the value is a string.\n\n    Args:\n        value (Any): The value to check.\n\n    Returns:\n        bool: True if the value is a string, False otherwise.\n    \"\"\"\n    return isinstance(value, str)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Info.to_json","title":"<code>to_json()</code>","text":"<p>Converts the Info instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the Info.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the Info instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the Info.\n    \"\"\"\n    return {\n        \"type\": self.type,\n        \"key\": self.key,\n        \"value\": self.value\n    }\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ResultLLM","title":"<code>ResultLLM</code>","text":"<p>Represents the result of a language model evaluation.</p> <p>Attributes:</p> Name Type Description <code>message_output_best</code> <code>str</code> <p>The best output message from the model.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class ResultLLM:\n    \"\"\"\n    Represents the result of a language model evaluation.\n\n    Attributes:\n        message_output_best (str): The best output message from the model.\n    \"\"\"\n\n    def __init__(self, message_output_best: str):\n        \"\"\"\n        Initializes a new instance of ResultLLM.\n\n        Args:\n            message_output_best (str): The best output message from the model.\n        \"\"\"\n        self.message_output_best = message_output_best\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the ResultLLM instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the ResultLLM.\n        \"\"\"\n        return {\n            \"scoreValueReal\": 0,\n            \"scoreGroupReal\": \"\",\n            \"scoreClusterReal\": \"\",\n            \"scoreValueDif\": 0,\n            \"scoreGroupDif\": \"\",\n            \"scoreClusterDif\": \"\",\n            \"messageOutputBest\": self.message_output_best,\n        }\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ResultLLM.__init__","title":"<code>__init__(message_output_best)</code>","text":"<p>Initializes a new instance of ResultLLM.</p> <p>Parameters:</p> Name Type Description Default <code>message_output_best</code> <code>str</code> <p>The best output message from the model.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self, message_output_best: str):\n    \"\"\"\n    Initializes a new instance of ResultLLM.\n\n    Args:\n        message_output_best (str): The best output message from the model.\n    \"\"\"\n    self.message_output_best = message_output_best\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ResultLLM.to_json","title":"<code>to_json()</code>","text":"<p>Converts the ResultLLM instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the ResultLLM.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the ResultLLM instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the ResultLLM.\n    \"\"\"\n    return {\n        \"scoreValueReal\": 0,\n        \"scoreGroupReal\": \"\",\n        \"scoreClusterReal\": \"\",\n        \"scoreValueDif\": 0,\n        \"scoreGroupDif\": \"\",\n        \"scoreClusterDif\": \"\",\n        \"messageOutputBest\": self.message_output_best,\n    }\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ResultScore","title":"<code>ResultScore</code>","text":"<p>Represents the result of a score evaluation.</p> <p>Attributes:</p> Name Type Description <code>score_value_real</code> <code>float</code> <p>Actual score value.</p> <code>score_group_real</code> <code>str</code> <p>Actual score group.</p> <code>score_cluster_real</code> <code>str</code> <p>Actual score cluster.</p> <code>score_value_dif</code> <code>float</code> <p>Difference in score value.</p> <code>score_group_dif</code> <code>str</code> <p>Difference in score group.</p> <code>score_cluster_dif</code> <code>str</code> <p>Difference in score cluster.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class ResultScore:\n    \"\"\"\n    Represents the result of a score evaluation.\n\n    Attributes:\n        score_value_real (float): Actual score value.\n        score_group_real (str): Actual score group.\n        score_cluster_real (str): Actual score cluster.\n        score_value_dif (float): Difference in score value.\n        score_group_dif (str): Difference in score group.\n        score_cluster_dif (str): Difference in score cluster.\n    \"\"\"\n\n    def __init__(\n        self,\n        value_actual: float,\n        group_actual: str,\n        cluster_actual: str,\n        value_dif: float,\n        group_dif: str,\n        cluster_dif: str,\n    ):\n        \"\"\"\n        Initializes a new instance of ResultScore.\n\n        Args:\n            value_actual (float): Actual score value.\n            group_actual (str): Actual score group.\n            cluster_actual (str): Actual score cluster.\n            value_dif (float): Difference in score value.\n            group_dif (str): Difference in score group.\n            cluster_dif (str): Difference in score cluster.\n\n        Raises:\n            TypeError: If any of the parameters are not of the correct type.\n        \"\"\"\n        if not self.__check_types(value_actual):\n            raise TypeError(\"value_actual must be int, float, or str\")\n        if not self.__check_types(value_dif):\n            raise TypeError(\"value_dif must be int, float, or str\")\n        if not self.__check_types(group_actual):\n            raise TypeError(\"group_actual must be int, float, or str\")\n        if not self.__check_types(group_dif):\n            raise TypeError(\"group_dif must be int, float, or str\")\n        if not self.__check_types(cluster_actual):\n            raise TypeError(\"cluster_actual must be int, float, or str\")\n        if not self.__check_types(cluster_dif):\n            raise TypeError(\"cluster_dif must be int, float, or str\")\n\n        self.score_value_real = value_actual\n        self.score_group_real = group_actual\n        self.score_cluster_real = cluster_actual\n        self.score_value_dif = value_dif\n        self.score_group_dif = group_dif\n        self.score_cluster_dif = cluster_dif\n\n    def __check_types(self, value: Any) -&gt; bool:\n        \"\"\"\n        Checks if the value is of an acceptable type.\n\n        Args:\n            value (Any): The value to check.\n\n        Returns:\n            bool: True if the value is int, float, or str; False otherwise.\n        \"\"\"\n        return isinstance(value, (int, float, str))\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the ResultScore instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the ResultScore.\n        \"\"\"\n        return {\n            \"scoreValueReal\": self.score_value_real,\n            \"scoreGroupReal\": self.score_group_real,\n            \"scoreClusterReal\": self.score_cluster_real,\n            \"scoreValueDif\": self.score_value_dif,\n            \"scoreGroupDif\": self.score_group_dif,\n            \"scoreClusterDif\": self.score_cluster_dif,\n            \"messageOutputBest\": \"\",\n        }\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ResultScore.__check_types","title":"<code>__check_types(value)</code>","text":"<p>Checks if the value is of an acceptable type.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value is int, float, or str; False otherwise.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __check_types(self, value: Any) -&gt; bool:\n    \"\"\"\n    Checks if the value is of an acceptable type.\n\n    Args:\n        value (Any): The value to check.\n\n    Returns:\n        bool: True if the value is int, float, or str; False otherwise.\n    \"\"\"\n    return isinstance(value, (int, float, str))\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ResultScore.__init__","title":"<code>__init__(value_actual, group_actual, cluster_actual, value_dif, group_dif, cluster_dif)</code>","text":"<p>Initializes a new instance of ResultScore.</p> <p>Parameters:</p> Name Type Description Default <code>value_actual</code> <code>float</code> <p>Actual score value.</p> required <code>group_actual</code> <code>str</code> <p>Actual score group.</p> required <code>cluster_actual</code> <code>str</code> <p>Actual score cluster.</p> required <code>value_dif</code> <code>float</code> <p>Difference in score value.</p> required <code>group_dif</code> <code>str</code> <p>Difference in score group.</p> required <code>cluster_dif</code> <code>str</code> <p>Difference in score cluster.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If any of the parameters are not of the correct type.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(\n    self,\n    value_actual: float,\n    group_actual: str,\n    cluster_actual: str,\n    value_dif: float,\n    group_dif: str,\n    cluster_dif: str,\n):\n    \"\"\"\n    Initializes a new instance of ResultScore.\n\n    Args:\n        value_actual (float): Actual score value.\n        group_actual (str): Actual score group.\n        cluster_actual (str): Actual score cluster.\n        value_dif (float): Difference in score value.\n        group_dif (str): Difference in score group.\n        cluster_dif (str): Difference in score cluster.\n\n    Raises:\n        TypeError: If any of the parameters are not of the correct type.\n    \"\"\"\n    if not self.__check_types(value_actual):\n        raise TypeError(\"value_actual must be int, float, or str\")\n    if not self.__check_types(value_dif):\n        raise TypeError(\"value_dif must be int, float, or str\")\n    if not self.__check_types(group_actual):\n        raise TypeError(\"group_actual must be int, float, or str\")\n    if not self.__check_types(group_dif):\n        raise TypeError(\"group_dif must be int, float, or str\")\n    if not self.__check_types(cluster_actual):\n        raise TypeError(\"cluster_actual must be int, float, or str\")\n    if not self.__check_types(cluster_dif):\n        raise TypeError(\"cluster_dif must be int, float, or str\")\n\n    self.score_value_real = value_actual\n    self.score_group_real = group_actual\n    self.score_cluster_real = cluster_actual\n    self.score_value_dif = value_dif\n    self.score_group_dif = group_dif\n    self.score_cluster_dif = cluster_dif\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ResultScore.to_json","title":"<code>to_json()</code>","text":"<p>Converts the ResultScore instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the ResultScore.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the ResultScore instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the ResultScore.\n    \"\"\"\n    return {\n        \"scoreValueReal\": self.score_value_real,\n        \"scoreGroupReal\": self.score_group_real,\n        \"scoreClusterReal\": self.score_cluster_real,\n        \"scoreValueDif\": self.score_value_dif,\n        \"scoreGroupDif\": self.score_group_dif,\n        \"scoreClusterDif\": self.score_cluster_dif,\n        \"messageOutputBest\": \"\",\n    }\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Step","title":"<code>Step</code>","text":"<p>Represents a step in the agent execution.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the step.</p> <code>enola_id</code> <code>str</code> <p>Enola ID of the step.</p> <code>agent_deploy_id</code> <code>str</code> <p>Agent deployment ID.</p> <code>step_id</code> <code>str</code> <p>Unique identifier for the step.</p> <code>message_input</code> <code>str</code> <p>Input message for the step.</p> <code>message_output</code> <code>str</code> <p>Output message from the step.</p> <code>num_iterations</code> <code>int</code> <p>Number of iterations.</p> <code>step_id_prev</code> <code>str</code> <p>Previous step ID.</p> <code>date_start</code> <code>str</code> <p>Start date and time of the step.</p> <code>date_end</code> <code>str</code> <p>End date and time of the step.</p> <code>agent_data_list</code> <code>List[DataListModel]</code> <p>List of agent data items.</p> <code>errOrWarn_list</code> <code>List[ErrorOrWarnModel]</code> <p>List of errors or warnings.</p> <code>extra_info_list</code> <code>List[Info]</code> <p>List of extra information items.</p> <code>file_info_list</code> <code>List[FileInfoModel]</code> <p>List of file information items.</p> <code>step_api_data_list</code> <code>List[ApiDataModel]</code> <p>List of API data items.</p> <code>step_type</code> <code>StepType</code> <p>Type of the step.</p> <code>successfull</code> <code>bool</code> <p>Indicates if the step was successful.</p> <code>num_errors</code> <code>int</code> <p>Number of errors.</p> <code>num_warnings</code> <code>int</code> <p>Number of warnings.</p> <code>score_value</code> <code>float</code> <p>Score value.</p> <code>score_group</code> <code>str</code> <p>Score group.</p> <code>score_cluster</code> <code>str</code> <p>Score cluster.</p> <code>video</code> <code>StepVideo</code> <p>Video-related information.</p> <code>audio</code> <code>StepAudio</code> <p>Audio-related information.</p> <code>image</code> <code>StepImage</code> <p>Image-related information.</p> <code>doc</code> <code>StepDoc</code> <p>Document-related information.</p> <code>token</code> <code>StepToken</code> <p>Token-related information.</p> <code>cost</code> <code>StepCost</code> <p>Cost-related information.</p> <code>income_total</code> <code>float</code> <p>Total income.</p> <code>duration_in_ms</code> <code>int</code> <p>Duration of the step in milliseconds.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class Step:\n    \"\"\"\n    Represents a step in the agent execution.\n\n    Attributes:\n        name (str): Name of the step.\n        enola_id (str): Enola ID of the step.\n        agent_deploy_id (str): Agent deployment ID.\n        step_id (str): Unique identifier for the step.\n        message_input (str): Input message for the step.\n        message_output (str): Output message from the step.\n        num_iterations (int): Number of iterations.\n        step_id_prev (str): Previous step ID.\n        date_start (str): Start date and time of the step.\n        date_end (str): End date and time of the step.\n        agent_data_list (List[DataListModel]): List of agent data items.\n        errOrWarn_list (List[ErrorOrWarnModel]): List of errors or warnings.\n        extra_info_list (List[Info]): List of extra information items.\n        file_info_list (List[FileInfoModel]): List of file information items.\n        step_api_data_list (List[ApiDataModel]): List of API data items.\n        step_type (StepType): Type of the step.\n        successfull (bool): Indicates if the step was successful.\n        num_errors (int): Number of errors.\n        num_warnings (int): Number of warnings.\n        score_value (float): Score value.\n        score_group (str): Score group.\n        score_cluster (str): Score cluster.\n        video (StepVideo): Video-related information.\n        audio (StepAudio): Audio-related information.\n        image (StepImage): Image-related information.\n        doc (StepDoc): Document-related information.\n        token (StepToken): Token-related information.\n        cost (StepCost): Cost-related information.\n        income_total (float): Total income.\n        duration_in_ms (int): Duration of the step in milliseconds.\n    \"\"\"\n\n    def __init__(self, name: str, message_input: str = \"\"):\n        \"\"\"\n        Initializes a new instance of Step.\n\n        Args:\n            name (str): Name of the step.\n            message_input (str, optional): Input message for the step.\n        \"\"\"\n        self.hf = HuemulFunctions()\n        self.name = name\n        self.enola_id = \"\"\n        self.agent_deploy_id = \"\"\n        self.step_id = \"\"\n        self.message_input = message_input\n        self.message_output = \"\"\n        self.num_iterations = 0\n        self.step_id_prev = \"\"\n        self.date_start = self.hf.get_date_for_api()\n        self.date_end = self.date_start\n        self.agent_data_list: List[DataListModel] = []  # only for first step\n        self.errOrWarn_list: List['ErrorOrWarnModel'] = []\n        self.extra_info_list: List[Info] = []\n        self.file_info_list: List[FileInfoModel] = []\n        self.step_api_data_list: List[ApiDataModel] = []\n        self.step_type: StepType = StepType.OTHER\n\n        self.successfull = False\n        self.num_errors = 0\n        self.num_warnings = 0\n\n        self.score_value = 0.0\n        self.score_group = \"\"\n        self.score_cluster = \"\"\n\n        self.video = StepVideo()\n        self.audio = StepAudio()\n        self.image = StepImage()\n        self.doc = StepDoc()\n        self.token = StepToken()\n        self.cost = StepCost()\n        self.income_total = 0.0\n        self.duration_in_ms = 0\n\n    def set_score(self, value: float, group: str, cluster: str, date: str = \"\") -&gt; None:\n        \"\"\"\n        Sets the score for the step.\n\n        Args:\n            value (float): Score value.\n            group (str): Score group.\n            cluster (str): Score cluster.\n            date (str, optional): Date of the score in ISO &amp; UTC format (e.g., 'yyyy-MM-ddTHH:mm:ss:SSSz'). Empty for current date.\n        \"\"\"\n        self.score_value = value\n        self.score_group = group\n        self.score_cluster = cluster\n        if date != \"\":\n            self.date_start = date\n            self.date_end = date\n\n    def add_api_data(\n        self,\n        bodyToSend: str,\n        payloadReceived: str,\n        name: str,\n        method: str,\n        url: str,\n        description: str = \"\",\n        headerToSend: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Adds API data related to the step.\n\n        Args:\n            bodyToSend (str): The request body sent.\n            payloadReceived (str): The response payload received.\n            name (str): The name of the API call.\n            method (str): The HTTP method used.\n            url (str): The URL of the API endpoint.\n            description (str, optional): A description of the API call.\n            headerToSend (str, optional): The request headers sent.\n        \"\"\"\n        self.step_api_data_list.append(\n            ApiDataModel(\n                name=name,\n                method=method,\n                url=url,\n                body=bodyToSend,\n                header=headerToSend,\n                payload=payloadReceived,\n                description=description,\n            )\n        )\n\n    def add_file_link(\n        self,\n        name: str,\n        url: str,\n        type: str,\n        size_kb: int,\n        description: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Adds file information related to the step.\n\n        Args:\n            name (str): The name of the file.\n            url (str): The URL where the file is located.\n            type (str): The type of the file.\n            size_kb (int): The size of the file in kilobytes.\n            description (str, optional): A description of the file.\n        \"\"\"\n        self.file_info_list.append(\n            FileInfoModel(\n                name=name,\n                url=url,\n                type=type,\n                sizeKb=size_kb,\n                description=description,\n            )\n        )\n\n    def add_tag(self, key: str, value: Any) -&gt; None:\n        \"\"\"\n        Adds a tag to the step.\n\n        Args:\n            key (str): The key of the tag.\n            value (Any): The value of the tag.\n        \"\"\"\n        self.extra_info_list.append(Info(type=\"tag\", key=key, value=value))\n\n    def add_extra_info(self, key: str, value: Any) -&gt; None:\n        \"\"\"\n        Adds extra information to the step.\n\n        Args:\n            key (str): The key of the extra information.\n            value (Any): The value of the extra information.\n        \"\"\"\n        self.extra_info_list.append(Info(type=\"info\", key=key, value=value))\n\n    def add_error(self, id: str, message: str, kind: 'ErrOrWarnKind') -&gt; None:\n        \"\"\"\n        Adds an error to the step.\n\n        Args:\n            id (str): The error identifier.\n            message (str): The error message.\n            kind (ErrOrWarnKind): The kind of error.\n        \"\"\"\n        self.num_errors += 1\n        self.errOrWarn_list.append(\n            ErrorOrWarnModel(\n                id=id,\n                message=message,\n                error_type=ErrorType.ERROR,\n                kind=kind,\n            )\n        )\n\n    def add_warning(self, id: str, message: str, kind: 'ErrOrWarnKind') -&gt; None:\n        \"\"\"\n        Adds a warning to the step.\n\n        Args:\n            id (str): The warning identifier.\n            message (str): The warning message.\n            kind (ErrOrWarnKind): The kind of warning.\n        \"\"\"\n        self.num_warnings += 1\n        self.errOrWarn_list.append(\n            ErrorOrWarnModel(\n                id=id,\n                message=message,\n                error_type=ErrorType.WARNING,\n                kind=kind,\n            )\n        )\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the Step instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the Step.\n        \"\"\"\n        return {\n            \"stepId\": self.step_id,\n            \"stepIdPrev\": self.step_id_prev,\n            \"stepDateStart\": self.date_start,\n            \"stepDateEnd\": self.date_end,\n            \"agentDeployId\": self.agent_deploy_id,\n            \"agentExecName\": self.name,\n            \"agentExecDurationMs\": self.duration_in_ms,\n            \"agentExecSuccessfull\": self.successfull,\n            \"agentExecNumErrors\": self.num_errors,\n            \"agentExecNumWarnings\": self.num_warnings,\n            \"agentExecNumVideos\": self.video.num_videos,\n            \"agentExecSecVideos\": self.video.sec_videos,\n            \"agentExecSizeVideos\": self.video.size_videos,\n            \"agentExecNumAudio\": self.audio.num_audio,\n            \"agentExecSecAudio\": self.audio.sec_audio,\n            \"agentExecSizeAudio\": self.audio.size_audio,\n            \"agentExecNumImages\": self.image.num_images,\n            \"agentExecSizeImages\": self.image.size_images,\n            \"agentExecNumDocs\": self.doc.num_docs,\n            \"agentExecNumPages\": self.doc.num_pages,\n            \"agentExecSizeDocs\": self.doc.size_docs,\n            \"agentExecNumChar\": self.doc.num_char + self.token.num_char,\n            \"agentExecTokenInput\": self.token.token_input,\n            \"agentExecTokenOutput\": self.token.token_output,\n            \"agentExecTokenTotal\": self.token.token_total,\n            \"agentExecCostTokenInput\": self.cost.token_input,\n            \"agentExecCostTokenOutput\": self.cost.token_output,\n            \"agentExecCostTokenTotal\": self.cost.token_total,\n            \"agentExecCostVideos\": self.cost.videos,\n            \"agentExecCostAudio\": self.cost.audio,\n            \"agentExecCostImages\": self.cost.images,\n            \"agentExecCostDocs\": self.cost.docs,\n            \"agentExecCostInfra\": self.cost.infra,\n            \"agentExecCostOthers\": self.cost.others,\n            \"agentExecCostTotal\": self.cost.total,\n            \"agentExecIncomeTotal\": self.income_total,\n            \"agentExecScoreValue\": self.score_value,\n            \"agentExecScoreGroup\": self.score_group,\n            \"agentExecScoreCluster\": self.score_cluster,\n            \"agentExecType\": self.step_type.value,\n            \"agentExecMessageInput\": self.message_input,\n            \"agentExecMessageOutput\": self.message_output,\n            \"agentExecCliNumIter\": self.num_iterations,\n            \"agentData\": [item.to_json() for item in self.agent_data_list],\n            \"errorOrWarning\": [item.to_json() for item in self.errOrWarn_list],\n            \"extraInfo\": [item.to_json() for item in self.extra_info_list],\n            \"fileInfo\": [item.to_json() for item in self.file_info_list],\n            \"stepApiData\": [item.to_json() for item in self.step_api_data_list],\n        }\n\n    def __str__(self) -&gt; str:\n        duration_seconds = self.duration_in_ms / 1000\n        return f'Step: {self.name}, Duration: {duration_seconds} seconds'\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Step.__init__","title":"<code>__init__(name, message_input='')</code>","text":"<p>Initializes a new instance of Step.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the step.</p> required <code>message_input</code> <code>str</code> <p>Input message for the step.</p> <code>''</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self, name: str, message_input: str = \"\"):\n    \"\"\"\n    Initializes a new instance of Step.\n\n    Args:\n        name (str): Name of the step.\n        message_input (str, optional): Input message for the step.\n    \"\"\"\n    self.hf = HuemulFunctions()\n    self.name = name\n    self.enola_id = \"\"\n    self.agent_deploy_id = \"\"\n    self.step_id = \"\"\n    self.message_input = message_input\n    self.message_output = \"\"\n    self.num_iterations = 0\n    self.step_id_prev = \"\"\n    self.date_start = self.hf.get_date_for_api()\n    self.date_end = self.date_start\n    self.agent_data_list: List[DataListModel] = []  # only for first step\n    self.errOrWarn_list: List['ErrorOrWarnModel'] = []\n    self.extra_info_list: List[Info] = []\n    self.file_info_list: List[FileInfoModel] = []\n    self.step_api_data_list: List[ApiDataModel] = []\n    self.step_type: StepType = StepType.OTHER\n\n    self.successfull = False\n    self.num_errors = 0\n    self.num_warnings = 0\n\n    self.score_value = 0.0\n    self.score_group = \"\"\n    self.score_cluster = \"\"\n\n    self.video = StepVideo()\n    self.audio = StepAudio()\n    self.image = StepImage()\n    self.doc = StepDoc()\n    self.token = StepToken()\n    self.cost = StepCost()\n    self.income_total = 0.0\n    self.duration_in_ms = 0\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Step.add_api_data","title":"<code>add_api_data(bodyToSend, payloadReceived, name, method, url, description='', headerToSend='')</code>","text":"<p>Adds API data related to the step.</p> <p>Parameters:</p> Name Type Description Default <code>bodyToSend</code> <code>str</code> <p>The request body sent.</p> required <code>payloadReceived</code> <code>str</code> <p>The response payload received.</p> required <code>name</code> <code>str</code> <p>The name of the API call.</p> required <code>method</code> <code>str</code> <p>The HTTP method used.</p> required <code>url</code> <code>str</code> <p>The URL of the API endpoint.</p> required <code>description</code> <code>str</code> <p>A description of the API call.</p> <code>''</code> <code>headerToSend</code> <code>str</code> <p>The request headers sent.</p> <code>''</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def add_api_data(\n    self,\n    bodyToSend: str,\n    payloadReceived: str,\n    name: str,\n    method: str,\n    url: str,\n    description: str = \"\",\n    headerToSend: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Adds API data related to the step.\n\n    Args:\n        bodyToSend (str): The request body sent.\n        payloadReceived (str): The response payload received.\n        name (str): The name of the API call.\n        method (str): The HTTP method used.\n        url (str): The URL of the API endpoint.\n        description (str, optional): A description of the API call.\n        headerToSend (str, optional): The request headers sent.\n    \"\"\"\n    self.step_api_data_list.append(\n        ApiDataModel(\n            name=name,\n            method=method,\n            url=url,\n            body=bodyToSend,\n            header=headerToSend,\n            payload=payloadReceived,\n            description=description,\n        )\n    )\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Step.add_error","title":"<code>add_error(id, message, kind)</code>","text":"<p>Adds an error to the step.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The error identifier.</p> required <code>message</code> <code>str</code> <p>The error message.</p> required <code>kind</code> <code>ErrOrWarnKind</code> <p>The kind of error.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def add_error(self, id: str, message: str, kind: 'ErrOrWarnKind') -&gt; None:\n    \"\"\"\n    Adds an error to the step.\n\n    Args:\n        id (str): The error identifier.\n        message (str): The error message.\n        kind (ErrOrWarnKind): The kind of error.\n    \"\"\"\n    self.num_errors += 1\n    self.errOrWarn_list.append(\n        ErrorOrWarnModel(\n            id=id,\n            message=message,\n            error_type=ErrorType.ERROR,\n            kind=kind,\n        )\n    )\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Step.add_extra_info","title":"<code>add_extra_info(key, value)</code>","text":"<p>Adds extra information to the step.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the extra information.</p> required <code>value</code> <code>Any</code> <p>The value of the extra information.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def add_extra_info(self, key: str, value: Any) -&gt; None:\n    \"\"\"\n    Adds extra information to the step.\n\n    Args:\n        key (str): The key of the extra information.\n        value (Any): The value of the extra information.\n    \"\"\"\n    self.extra_info_list.append(Info(type=\"info\", key=key, value=value))\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Step.add_file_link","title":"<code>add_file_link(name, url, type, size_kb, description='')</code>","text":"<p>Adds file information related to the step.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the file.</p> required <code>url</code> <code>str</code> <p>The URL where the file is located.</p> required <code>type</code> <code>str</code> <p>The type of the file.</p> required <code>size_kb</code> <code>int</code> <p>The size of the file in kilobytes.</p> required <code>description</code> <code>str</code> <p>A description of the file.</p> <code>''</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def add_file_link(\n    self,\n    name: str,\n    url: str,\n    type: str,\n    size_kb: int,\n    description: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Adds file information related to the step.\n\n    Args:\n        name (str): The name of the file.\n        url (str): The URL where the file is located.\n        type (str): The type of the file.\n        size_kb (int): The size of the file in kilobytes.\n        description (str, optional): A description of the file.\n    \"\"\"\n    self.file_info_list.append(\n        FileInfoModel(\n            name=name,\n            url=url,\n            type=type,\n            sizeKb=size_kb,\n            description=description,\n        )\n    )\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Step.add_tag","title":"<code>add_tag(key, value)</code>","text":"<p>Adds a tag to the step.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the tag.</p> required <code>value</code> <code>Any</code> <p>The value of the tag.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def add_tag(self, key: str, value: Any) -&gt; None:\n    \"\"\"\n    Adds a tag to the step.\n\n    Args:\n        key (str): The key of the tag.\n        value (Any): The value of the tag.\n    \"\"\"\n    self.extra_info_list.append(Info(type=\"tag\", key=key, value=value))\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Step.add_warning","title":"<code>add_warning(id, message, kind)</code>","text":"<p>Adds a warning to the step.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The warning identifier.</p> required <code>message</code> <code>str</code> <p>The warning message.</p> required <code>kind</code> <code>ErrOrWarnKind</code> <p>The kind of warning.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def add_warning(self, id: str, message: str, kind: 'ErrOrWarnKind') -&gt; None:\n    \"\"\"\n    Adds a warning to the step.\n\n    Args:\n        id (str): The warning identifier.\n        message (str): The warning message.\n        kind (ErrOrWarnKind): The kind of warning.\n    \"\"\"\n    self.num_warnings += 1\n    self.errOrWarn_list.append(\n        ErrorOrWarnModel(\n            id=id,\n            message=message,\n            error_type=ErrorType.WARNING,\n            kind=kind,\n        )\n    )\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Step.set_score","title":"<code>set_score(value, group, cluster, date='')</code>","text":"<p>Sets the score for the step.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Score value.</p> required <code>group</code> <code>str</code> <p>Score group.</p> required <code>cluster</code> <code>str</code> <p>Score cluster.</p> required <code>date</code> <code>str</code> <p>Date of the score in ISO &amp; UTC format (e.g., 'yyyy-MM-ddTHH:mm:ss:SSSz'). Empty for current date.</p> <code>''</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def set_score(self, value: float, group: str, cluster: str, date: str = \"\") -&gt; None:\n    \"\"\"\n    Sets the score for the step.\n\n    Args:\n        value (float): Score value.\n        group (str): Score group.\n        cluster (str): Score cluster.\n        date (str, optional): Date of the score in ISO &amp; UTC format (e.g., 'yyyy-MM-ddTHH:mm:ss:SSSz'). Empty for current date.\n    \"\"\"\n    self.score_value = value\n    self.score_group = group\n    self.score_cluster = cluster\n    if date != \"\":\n        self.date_start = date\n        self.date_end = date\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Step.to_json","title":"<code>to_json()</code>","text":"<p>Converts the Step instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the Step.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the Step instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the Step.\n    \"\"\"\n    return {\n        \"stepId\": self.step_id,\n        \"stepIdPrev\": self.step_id_prev,\n        \"stepDateStart\": self.date_start,\n        \"stepDateEnd\": self.date_end,\n        \"agentDeployId\": self.agent_deploy_id,\n        \"agentExecName\": self.name,\n        \"agentExecDurationMs\": self.duration_in_ms,\n        \"agentExecSuccessfull\": self.successfull,\n        \"agentExecNumErrors\": self.num_errors,\n        \"agentExecNumWarnings\": self.num_warnings,\n        \"agentExecNumVideos\": self.video.num_videos,\n        \"agentExecSecVideos\": self.video.sec_videos,\n        \"agentExecSizeVideos\": self.video.size_videos,\n        \"agentExecNumAudio\": self.audio.num_audio,\n        \"agentExecSecAudio\": self.audio.sec_audio,\n        \"agentExecSizeAudio\": self.audio.size_audio,\n        \"agentExecNumImages\": self.image.num_images,\n        \"agentExecSizeImages\": self.image.size_images,\n        \"agentExecNumDocs\": self.doc.num_docs,\n        \"agentExecNumPages\": self.doc.num_pages,\n        \"agentExecSizeDocs\": self.doc.size_docs,\n        \"agentExecNumChar\": self.doc.num_char + self.token.num_char,\n        \"agentExecTokenInput\": self.token.token_input,\n        \"agentExecTokenOutput\": self.token.token_output,\n        \"agentExecTokenTotal\": self.token.token_total,\n        \"agentExecCostTokenInput\": self.cost.token_input,\n        \"agentExecCostTokenOutput\": self.cost.token_output,\n        \"agentExecCostTokenTotal\": self.cost.token_total,\n        \"agentExecCostVideos\": self.cost.videos,\n        \"agentExecCostAudio\": self.cost.audio,\n        \"agentExecCostImages\": self.cost.images,\n        \"agentExecCostDocs\": self.cost.docs,\n        \"agentExecCostInfra\": self.cost.infra,\n        \"agentExecCostOthers\": self.cost.others,\n        \"agentExecCostTotal\": self.cost.total,\n        \"agentExecIncomeTotal\": self.income_total,\n        \"agentExecScoreValue\": self.score_value,\n        \"agentExecScoreGroup\": self.score_group,\n        \"agentExecScoreCluster\": self.score_cluster,\n        \"agentExecType\": self.step_type.value,\n        \"agentExecMessageInput\": self.message_input,\n        \"agentExecMessageOutput\": self.message_output,\n        \"agentExecCliNumIter\": self.num_iterations,\n        \"agentData\": [item.to_json() for item in self.agent_data_list],\n        \"errorOrWarning\": [item.to_json() for item in self.errOrWarn_list],\n        \"extraInfo\": [item.to_json() for item in self.extra_info_list],\n        \"fileInfo\": [item.to_json() for item in self.file_info_list],\n        \"stepApiData\": [item.to_json() for item in self.step_api_data_list],\n    }\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepAudio","title":"<code>StepAudio</code>","text":"<p>Represents audio-related information for a step.</p> <p>Attributes:</p> Name Type Description <code>num_audio</code> <code>int</code> <p>Number of audio files processed.</p> <code>size_audio</code> <code>int</code> <p>Total size of audio files in kilobytes.</p> <code>sec_audio</code> <code>int</code> <p>Total duration of audio files in seconds.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class StepAudio:\n    \"\"\"\n    Represents audio-related information for a step.\n\n    Attributes:\n        num_audio (int): Number of audio files processed.\n        size_audio (int): Total size of audio files in kilobytes.\n        sec_audio (int): Total duration of audio files in seconds.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes a new instance of StepAudio.\n        \"\"\"\n        self.num_audio = 0\n        self.size_audio = 0\n        self.sec_audio = 0\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepAudio.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a new instance of StepAudio.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes a new instance of StepAudio.\n    \"\"\"\n    self.num_audio = 0\n    self.size_audio = 0\n    self.sec_audio = 0\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepCost","title":"<code>StepCost</code>","text":"<p>Represents the cost information for a step.</p> <p>Attributes:</p> Name Type Description <code>token_input</code> <code>float</code> <p>Cost of input tokens.</p> <code>token_output</code> <code>float</code> <p>Cost of output tokens.</p> <code>token_total</code> <code>float</code> <p>Total cost of tokens.</p> <code>videos</code> <code>float</code> <p>Cost associated with videos.</p> <code>audio</code> <code>float</code> <p>Cost associated with audio.</p> <code>images</code> <code>float</code> <p>Cost associated with images.</p> <code>docs</code> <code>float</code> <p>Cost associated with documents.</p> <code>infra</code> <code>float</code> <p>Infrastructure cost.</p> <code>others</code> <code>float</code> <p>Other costs.</p> <code>total</code> <code>float</code> <p>Total cost.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class StepCost:\n    \"\"\"\n    Represents the cost information for a step.\n\n    Attributes:\n        token_input (float): Cost of input tokens.\n        token_output (float): Cost of output tokens.\n        token_total (float): Total cost of tokens.\n        videos (float): Cost associated with videos.\n        audio (float): Cost associated with audio.\n        images (float): Cost associated with images.\n        docs (float): Cost associated with documents.\n        infra (float): Infrastructure cost.\n        others (float): Other costs.\n        total (float): Total cost.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes a new instance of StepCost.\n        \"\"\"\n        self.token_input = 0.0\n        self.token_output = 0.0\n        self.token_total = 0.0\n        self.videos = 0.0\n        self.audio = 0.0\n        self.images = 0.0\n        self.docs = 0.0\n        self.infra = 0.0\n        self.others = 0.0\n        self.total = 0.0\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepCost.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a new instance of StepCost.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes a new instance of StepCost.\n    \"\"\"\n    self.token_input = 0.0\n    self.token_output = 0.0\n    self.token_total = 0.0\n    self.videos = 0.0\n    self.audio = 0.0\n    self.images = 0.0\n    self.docs = 0.0\n    self.infra = 0.0\n    self.others = 0.0\n    self.total = 0.0\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepDoc","title":"<code>StepDoc</code>","text":"<p>Represents document-related information for a step.</p> <p>Attributes:</p> Name Type Description <code>num_docs</code> <code>int</code> <p>Number of documents processed.</p> <code>num_pages</code> <code>int</code> <p>Total number of pages in documents.</p> <code>size_docs</code> <code>int</code> <p>Total size of documents in kilobytes.</p> <code>num_char</code> <code>int</code> <p>Total number of characters in documents.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class StepDoc:\n    \"\"\"\n    Represents document-related information for a step.\n\n    Attributes:\n        num_docs (int): Number of documents processed.\n        num_pages (int): Total number of pages in documents.\n        size_docs (int): Total size of documents in kilobytes.\n        num_char (int): Total number of characters in documents.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes a new instance of StepDoc.\n        \"\"\"\n        self.num_docs = 0\n        self.num_pages = 0\n        self.size_docs = 0\n        self.num_char = 0\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepDoc.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a new instance of StepDoc.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes a new instance of StepDoc.\n    \"\"\"\n    self.num_docs = 0\n    self.num_pages = 0\n    self.size_docs = 0\n    self.num_char = 0\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepImage","title":"<code>StepImage</code>","text":"<p>Represents image-related information for a step.</p> <p>Attributes:</p> Name Type Description <code>num_images</code> <code>int</code> <p>Number of images processed.</p> <code>size_images</code> <code>int</code> <p>Total size of images in kilobytes.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class StepImage:\n    \"\"\"\n    Represents image-related information for a step.\n\n    Attributes:\n        num_images (int): Number of images processed.\n        size_images (int): Total size of images in kilobytes.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes a new instance of StepImage.\n        \"\"\"\n        self.num_images = 0\n        self.size_images = 0\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepImage.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a new instance of StepImage.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes a new instance of StepImage.\n    \"\"\"\n    self.num_images = 0\n    self.size_images = 0\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepToken","title":"<code>StepToken</code>","text":"<p>Represents token-related information for a step.</p> <p>Attributes:</p> Name Type Description <code>num_char</code> <code>int</code> <p>Number of characters processed.</p> <code>token_input</code> <code>int</code> <p>Number of input tokens.</p> <code>token_output</code> <code>int</code> <p>Number of output tokens.</p> <code>token_total</code> <code>int</code> <p>Total number of tokens.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class StepToken:\n    \"\"\"\n    Represents token-related information for a step.\n\n    Attributes:\n        num_char (int): Number of characters processed.\n        token_input (int): Number of input tokens.\n        token_output (int): Number of output tokens.\n        token_total (int): Total number of tokens.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes a new instance of StepToken.\n        \"\"\"\n        self.num_char = 0\n        self.token_input = 0\n        self.token_output = 0\n        self.token_total = 0\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepToken.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a new instance of StepToken.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes a new instance of StepToken.\n    \"\"\"\n    self.num_char = 0\n    self.token_input = 0\n    self.token_output = 0\n    self.token_total = 0\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepType","title":"<code>StepType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of step types.</p> <p>Attributes:</p> Name Type Description <code>TOKEN</code> <code>str</code> <p>Token-related step.</p> <code>VIDEO</code> <code>str</code> <p>Video-related step.</p> <code>AUDIO</code> <code>str</code> <p>Audio-related step.</p> <code>IMAGE</code> <code>str</code> <p>Image-related step.</p> <code>DOCUMENT</code> <code>str</code> <p>Document-related step.</p> <code>OTHER</code> <code>str</code> <p>Other types of step.</p> <code>SCORE</code> <code>str</code> <p>Score-related step.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class StepType(Enum):\n    \"\"\"\n    Enumeration of step types.\n\n    Attributes:\n        TOKEN (str): Token-related step.\n        VIDEO (str): Video-related step.\n        AUDIO (str): Audio-related step.\n        IMAGE (str): Image-related step.\n        DOCUMENT (str): Document-related step.\n        OTHER (str): Other types of step.\n        SCORE (str): Score-related step.\n    \"\"\"\n    TOKEN = \"TOKEN\"\n    VIDEO = \"VIDEO\"\n    AUDIO = \"AUDIO\"\n    IMAGE = \"IMAGE\"\n    DOCUMENT = \"DOCUMENT\"\n    OTHER = \"OTHER\"\n    SCORE = \"SCORE\"\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepVideo","title":"<code>StepVideo</code>","text":"<p>Represents video-related information for a step.</p> <p>Attributes:</p> Name Type Description <code>num_videos</code> <code>int</code> <p>Number of videos processed.</p> <code>size_videos</code> <code>int</code> <p>Total size of videos in kilobytes.</p> <code>sec_videos</code> <code>int</code> <p>Total duration of videos in seconds.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class StepVideo:\n    \"\"\"\n    Represents video-related information for a step.\n\n    Attributes:\n        num_videos (int): Number of videos processed.\n        size_videos (int): Total size of videos in kilobytes.\n        sec_videos (int): Total duration of videos in seconds.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes a new instance of StepVideo.\n        \"\"\"\n        self.num_videos = 0\n        self.size_videos = 0\n        self.sec_videos = 0\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.StepVideo.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a new instance of StepVideo.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes a new instance of StepVideo.\n    \"\"\"\n    self.num_videos = 0\n    self.size_videos = 0\n    self.sec_videos = 0\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingBatchDetailResponseModel","title":"<code>TrackingBatchDetailResponseModel</code>","text":"<p>Represents the detailed response model for batch tracking.</p> <p>Attributes:</p> Name Type Description <code>tracking_list</code> <code>List[TrackingResponseModel]</code> <p>List of tracking responses.</p> <code>agent_deploy_id</code> <code>str</code> <p>Agent deployment ID.</p> <code>successfull</code> <code>bool</code> <p>Indicates if the batch tracking was successful.</p> <code>message</code> <code>str</code> <p>Response message.</p> <code>args</code> <code>Dict[str, Any]</code> <p>Additional arguments.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class TrackingBatchDetailResponseModel:\n    \"\"\"\n    Represents the detailed response model for batch tracking.\n\n    Attributes:\n        tracking_list (List[TrackingResponseModel]): List of tracking responses.\n        agent_deploy_id (str): Agent deployment ID.\n        successfull (bool): Indicates if the batch tracking was successful.\n        message (str): Response message.\n        args (Dict[str, Any]): Additional arguments.\n    \"\"\"\n\n    def __init__(\n        self,\n        agent_deploy_id: str = \"\",\n        successfull: Optional[bool] = None,\n        message: str = \"\",\n        tracking_list: Optional[List[TrackingResponseModel]] = None,\n        **args,\n    ):\n        \"\"\"\n        Initializes a new instance of TrackingBatchDetailResponseModel.\n\n        Args:\n            agent_deploy_id (str, optional): Agent deployment ID.\n            successfull (bool, optional): Indicates if the batch tracking was successful.\n            message (str, optional): Response message.\n            tracking_list (List[TrackingResponseModel], optional): List of tracking responses.\n            **args: Additional keyword arguments.\n        \"\"\"\n        tracking_list_data = tracking_list or args.get(\"trackingList\", [])\n        self.tracking_list: List[TrackingResponseModel] = [\n            TrackingResponseModel(**item) if isinstance(item, dict) else item for item in tracking_list_data\n        ]\n        self.agent_deploy_id = agent_deploy_id or args.get(\"agentDeployId\", \"\")\n        self.successfull = successfull if successfull is not None else args.get(\"isSuccessful\", False)\n        self.message = message or args.get(\"message\", \"\")\n        self.args = args\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingBatchDetailResponseModel.__init__","title":"<code>__init__(agent_deploy_id='', successfull=None, message='', tracking_list=None, **args)</code>","text":"<p>Initializes a new instance of TrackingBatchDetailResponseModel.</p> <p>Parameters:</p> Name Type Description Default <code>agent_deploy_id</code> <code>str</code> <p>Agent deployment ID.</p> <code>''</code> <code>successfull</code> <code>bool</code> <p>Indicates if the batch tracking was successful.</p> <code>None</code> <code>message</code> <code>str</code> <p>Response message.</p> <code>''</code> <code>tracking_list</code> <code>List[TrackingResponseModel]</code> <p>List of tracking responses.</p> <code>None</code> <code>**args</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(\n    self,\n    agent_deploy_id: str = \"\",\n    successfull: Optional[bool] = None,\n    message: str = \"\",\n    tracking_list: Optional[List[TrackingResponseModel]] = None,\n    **args,\n):\n    \"\"\"\n    Initializes a new instance of TrackingBatchDetailResponseModel.\n\n    Args:\n        agent_deploy_id (str, optional): Agent deployment ID.\n        successfull (bool, optional): Indicates if the batch tracking was successful.\n        message (str, optional): Response message.\n        tracking_list (List[TrackingResponseModel], optional): List of tracking responses.\n        **args: Additional keyword arguments.\n    \"\"\"\n    tracking_list_data = tracking_list or args.get(\"trackingList\", [])\n    self.tracking_list: List[TrackingResponseModel] = [\n        TrackingResponseModel(**item) if isinstance(item, dict) else item for item in tracking_list_data\n    ]\n    self.agent_deploy_id = agent_deploy_id or args.get(\"agentDeployId\", \"\")\n    self.successfull = successfull if successfull is not None else args.get(\"isSuccessful\", False)\n    self.message = message or args.get(\"message\", \"\")\n    self.args = args\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingBatchHeadModel","title":"<code>TrackingBatchHeadModel</code>","text":"<p>Represents the header model for batch tracking.</p> <p>Attributes:</p> Name Type Description <code>enola_sender</code> <code>EnolaSenderModel</code> <p>The sender information.</p> <code>name</code> <code>str</code> <p>Name of the batch execution.</p> <code>period</code> <code>str</code> <p>Period of the batch execution.</p> <code>total_rows</code> <code>int</code> <p>Total number of rows in the batch.</p> <code>is_test</code> <code>bool</code> <p>Indicates if the batch execution is a test.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class TrackingBatchHeadModel:\n    \"\"\"\n    Represents the header model for batch tracking.\n\n    Attributes:\n        enola_sender (EnolaSenderModel): The sender information.\n        name (str): Name of the batch execution.\n        period (str): Period of the batch execution.\n        total_rows (int): Total number of rows in the batch.\n        is_test (bool): Indicates if the batch execution is a test.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        period: str,\n        total_rows: int,\n        is_test: bool,\n        enola_sender: 'EnolaSenderModel',\n    ):\n        \"\"\"\n        Initializes a new instance of TrackingBatchHeadModel.\n\n        Args:\n            name (str): Name of the batch execution.\n            period (str): Period of the batch execution.\n            total_rows (int): Total number of rows in the batch.\n            is_test (bool): Indicates if the batch execution is a test.\n            enola_sender (EnolaSenderModel): The sender information.\n        \"\"\"\n        self.enola_sender = enola_sender\n        self.name = name\n        self.period = period\n        self.total_rows = total_rows\n        self.is_test = is_test\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the TrackingBatchHeadModel instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the TrackingBatchHeadModel.\n        \"\"\"\n        return {\n            \"agentExecBatchCliAppId\": self.enola_sender.app_id,\n            \"agentExecBatchCliAppName\": self.enola_sender.app_name,\n            \"agentExecBatchCliUserId\": self.enola_sender.user_id,\n            \"agentExecBatchCliUserName\": self.enola_sender.user_name,\n            \"agentExecBatchCliSessionId\": self.enola_sender.session_id,\n            \"agentExecBatchCliChannel\": self.enola_sender.channel_id,\n            \"agentExecBatchCliChannelName\": self.enola_sender.channel_name,\n            \"agentExecBatchCliSessionName\": self.enola_sender.session_name,\n            \"agentExecBatchCliIP\": self.enola_sender.ip,\n            \"agentExecBatchName\": self.name,\n            \"agentExecBatchPeriodData\": self.period,\n            \"agentExecBatchIsTest\": self.is_test,\n            \"agentExecBatchNumRowsTotal\": self.total_rows,\n        }\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingBatchHeadModel.__init__","title":"<code>__init__(name, period, total_rows, is_test, enola_sender)</code>","text":"<p>Initializes a new instance of TrackingBatchHeadModel.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the batch execution.</p> required <code>period</code> <code>str</code> <p>Period of the batch execution.</p> required <code>total_rows</code> <code>int</code> <p>Total number of rows in the batch.</p> required <code>is_test</code> <code>bool</code> <p>Indicates if the batch execution is a test.</p> required <code>enola_sender</code> <code>EnolaSenderModel</code> <p>The sender information.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    period: str,\n    total_rows: int,\n    is_test: bool,\n    enola_sender: 'EnolaSenderModel',\n):\n    \"\"\"\n    Initializes a new instance of TrackingBatchHeadModel.\n\n    Args:\n        name (str): Name of the batch execution.\n        period (str): Period of the batch execution.\n        total_rows (int): Total number of rows in the batch.\n        is_test (bool): Indicates if the batch execution is a test.\n        enola_sender (EnolaSenderModel): The sender information.\n    \"\"\"\n    self.enola_sender = enola_sender\n    self.name = name\n    self.period = period\n    self.total_rows = total_rows\n    self.is_test = is_test\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingBatchHeadModel.to_json","title":"<code>to_json()</code>","text":"<p>Converts the TrackingBatchHeadModel instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the TrackingBatchHeadModel.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the TrackingBatchHeadModel instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the TrackingBatchHeadModel.\n    \"\"\"\n    return {\n        \"agentExecBatchCliAppId\": self.enola_sender.app_id,\n        \"agentExecBatchCliAppName\": self.enola_sender.app_name,\n        \"agentExecBatchCliUserId\": self.enola_sender.user_id,\n        \"agentExecBatchCliUserName\": self.enola_sender.user_name,\n        \"agentExecBatchCliSessionId\": self.enola_sender.session_id,\n        \"agentExecBatchCliChannel\": self.enola_sender.channel_id,\n        \"agentExecBatchCliChannelName\": self.enola_sender.channel_name,\n        \"agentExecBatchCliSessionName\": self.enola_sender.session_name,\n        \"agentExecBatchCliIP\": self.enola_sender.ip,\n        \"agentExecBatchName\": self.name,\n        \"agentExecBatchPeriodData\": self.period,\n        \"agentExecBatchIsTest\": self.is_test,\n        \"agentExecBatchNumRowsTotal\": self.total_rows,\n    }\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingBatchHeadResponseModel","title":"<code>TrackingBatchHeadResponseModel</code>","text":"<p>Represents the response model for batch tracking head.</p> <p>Attributes:</p> Name Type Description <code>batch_id</code> <code>str</code> <p>ID of the batch.</p> <code>agent_deploy_id</code> <code>str</code> <p>Agent deployment ID.</p> <code>successfull</code> <code>bool</code> <p>Indicates if the batch creation was successful.</p> <code>message</code> <code>str</code> <p>Response message.</p> <code>args</code> <code>Dict[str, Any]</code> <p>Additional arguments.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class TrackingBatchHeadResponseModel:\n    \"\"\"\n    Represents the response model for batch tracking head.\n\n    Attributes:\n        batch_id (str): ID of the batch.\n        agent_deploy_id (str): Agent deployment ID.\n        successfull (bool): Indicates if the batch creation was successful.\n        message (str): Response message.\n        args (Dict[str, Any]): Additional arguments.\n    \"\"\"\n\n    def __init__(\n        self,\n        batch_id: str = \"\",\n        agent_deploy_id: str = \"\",\n        successfull: Optional[bool] = None,\n        message: str = \"\",\n        **args,\n    ):\n        \"\"\"\n        Initializes a new instance of TrackingBatchHeadResponseModel.\n\n        Args:\n            batch_id (str, optional): ID of the batch.\n            agent_deploy_id (str, optional): Agent deployment ID.\n            successfull (bool, optional): Indicates if the batch creation was successful.\n            message (str, optional): Response message.\n            **args: Additional keyword arguments.\n        \"\"\"\n        self.batch_id = batch_id or args.get(\"agentExecBatchId\", \"\")\n        self.agent_deploy_id = agent_deploy_id or args.get(\"agentDeployId\", \"\")\n        self.successfull = successfull if successfull is not None else args.get(\"agentExecBatchSuccessfull\", False)\n        self.message = message or args.get(\"message\", \"\")\n        self.args = args\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the TrackingBatchHeadResponseModel instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the TrackingBatchHeadResponseModel.\n        \"\"\"\n        return {\n            \"batch_id\": self.batch_id,\n            \"agentDeployId\": self.agent_deploy_id,\n            \"successfull\": self.successfull,\n            \"message\": self.message,\n            \"args\": self.args,\n        }\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingBatchHeadResponseModel.__init__","title":"<code>__init__(batch_id='', agent_deploy_id='', successfull=None, message='', **args)</code>","text":"<p>Initializes a new instance of TrackingBatchHeadResponseModel.</p> <p>Parameters:</p> Name Type Description Default <code>batch_id</code> <code>str</code> <p>ID of the batch.</p> <code>''</code> <code>agent_deploy_id</code> <code>str</code> <p>Agent deployment ID.</p> <code>''</code> <code>successfull</code> <code>bool</code> <p>Indicates if the batch creation was successful.</p> <code>None</code> <code>message</code> <code>str</code> <p>Response message.</p> <code>''</code> <code>**args</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(\n    self,\n    batch_id: str = \"\",\n    agent_deploy_id: str = \"\",\n    successfull: Optional[bool] = None,\n    message: str = \"\",\n    **args,\n):\n    \"\"\"\n    Initializes a new instance of TrackingBatchHeadResponseModel.\n\n    Args:\n        batch_id (str, optional): ID of the batch.\n        agent_deploy_id (str, optional): Agent deployment ID.\n        successfull (bool, optional): Indicates if the batch creation was successful.\n        message (str, optional): Response message.\n        **args: Additional keyword arguments.\n    \"\"\"\n    self.batch_id = batch_id or args.get(\"agentExecBatchId\", \"\")\n    self.agent_deploy_id = agent_deploy_id or args.get(\"agentDeployId\", \"\")\n    self.successfull = successfull if successfull is not None else args.get(\"agentExecBatchSuccessfull\", False)\n    self.message = message or args.get(\"message\", \"\")\n    self.args = args\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingBatchHeadResponseModel.to_json","title":"<code>to_json()</code>","text":"<p>Converts the TrackingBatchHeadResponseModel instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the TrackingBatchHeadResponseModel.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the TrackingBatchHeadResponseModel instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the TrackingBatchHeadResponseModel.\n    \"\"\"\n    return {\n        \"batch_id\": self.batch_id,\n        \"agentDeployId\": self.agent_deploy_id,\n        \"successfull\": self.successfull,\n        \"message\": self.message,\n        \"args\": self.args,\n    }\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingModel","title":"<code>TrackingModel</code>","text":"<p>Represents a tracking model for agent execution.</p> <p>Attributes:</p> Name Type Description <code>enola_sender</code> <code>EnolaSenderModel</code> <p>The sender information.</p> <code>is_test</code> <code>bool</code> <p>Indicates if the execution is a test.</p> <code>step_list</code> <code>List[Step]</code> <p>List of steps in the execution.</p> <code>steps</code> <code>int</code> <p>Total number of steps.</p> <code>enola_id_prev</code> <code>str</code> <p>Previous Enola ID.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class TrackingModel:\n    \"\"\"\n    Represents a tracking model for agent execution.\n\n    Attributes:\n        enola_sender (EnolaSenderModel): The sender information.\n        is_test (bool): Indicates if the execution is a test.\n        step_list (List[Step]): List of steps in the execution.\n        steps (int): Total number of steps.\n        enola_id_prev (str): Previous Enola ID.\n    \"\"\"\n\n    def __init__(\n        self,\n        is_test: bool,\n        step_list: List['Step'],\n        steps: int,\n        enola_id_prev: str,\n        enola_sender: 'EnolaSenderModel',\n    ):\n        \"\"\"\n        Initializes a new instance of TrackingModel.\n\n        Args:\n            is_test (bool): Indicates if the execution is a test.\n            step_list (List[Step]): List of steps in the execution.\n            steps (int): Total number of steps.\n            enola_id_prev (str): Previous Enola ID.\n            enola_sender (EnolaSenderModel): The sender information.\n        \"\"\"\n        self.enola_sender = enola_sender\n        self.is_test = is_test\n        self.step_list = step_list\n        self.steps = steps\n        self.enola_id_prev = enola_id_prev\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the TrackingModel instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the TrackingModel.\n        \"\"\"\n        return {\n            \"app_id\": self.enola_sender.app_id,\n            \"app_name\": self.enola_sender.app_name,\n            \"user_id\": self.enola_sender.user_id,\n            \"user_name\": self.enola_sender.user_name,\n            \"session_id\": self.enola_sender.session_id,\n            \"channel_id\": self.enola_sender.channel_id,\n            \"session_name\": self.enola_sender.session_name,\n            \"client_id\": self.enola_sender.client_id,\n            \"product_id\": self.enola_sender.product_id,\n            \"agentExecBatchId\": self.enola_sender.batch_id,\n            \"ip\": self.enola_sender.ip,\n            \"code_api\": self.enola_sender.external_id,\n            \"isTest\": self.is_test,\n            \"step_list\": [step.to_json() for step in self.step_list],\n            \"steps\": self.steps,\n            \"enola_id_prev\": self.enola_id_prev,\n        }\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingModel.__init__","title":"<code>__init__(is_test, step_list, steps, enola_id_prev, enola_sender)</code>","text":"<p>Initializes a new instance of TrackingModel.</p> <p>Parameters:</p> Name Type Description Default <code>is_test</code> <code>bool</code> <p>Indicates if the execution is a test.</p> required <code>step_list</code> <code>List[Step]</code> <p>List of steps in the execution.</p> required <code>steps</code> <code>int</code> <p>Total number of steps.</p> required <code>enola_id_prev</code> <code>str</code> <p>Previous Enola ID.</p> required <code>enola_sender</code> <code>EnolaSenderModel</code> <p>The sender information.</p> required Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(\n    self,\n    is_test: bool,\n    step_list: List['Step'],\n    steps: int,\n    enola_id_prev: str,\n    enola_sender: 'EnolaSenderModel',\n):\n    \"\"\"\n    Initializes a new instance of TrackingModel.\n\n    Args:\n        is_test (bool): Indicates if the execution is a test.\n        step_list (List[Step]): List of steps in the execution.\n        steps (int): Total number of steps.\n        enola_id_prev (str): Previous Enola ID.\n        enola_sender (EnolaSenderModel): The sender information.\n    \"\"\"\n    self.enola_sender = enola_sender\n    self.is_test = is_test\n    self.step_list = step_list\n    self.steps = steps\n    self.enola_id_prev = enola_id_prev\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingModel.to_json","title":"<code>to_json()</code>","text":"<p>Converts the TrackingModel instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the TrackingModel.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the TrackingModel instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the TrackingModel.\n    \"\"\"\n    return {\n        \"app_id\": self.enola_sender.app_id,\n        \"app_name\": self.enola_sender.app_name,\n        \"user_id\": self.enola_sender.user_id,\n        \"user_name\": self.enola_sender.user_name,\n        \"session_id\": self.enola_sender.session_id,\n        \"channel_id\": self.enola_sender.channel_id,\n        \"session_name\": self.enola_sender.session_name,\n        \"client_id\": self.enola_sender.client_id,\n        \"product_id\": self.enola_sender.product_id,\n        \"agentExecBatchId\": self.enola_sender.batch_id,\n        \"ip\": self.enola_sender.ip,\n        \"code_api\": self.enola_sender.external_id,\n        \"isTest\": self.is_test,\n        \"step_list\": [step.to_json() for step in self.step_list],\n        \"steps\": self.steps,\n        \"enola_id_prev\": self.enola_id_prev,\n    }\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingResponseModel","title":"<code>TrackingResponseModel</code>","text":"<p>Represents the response model for tracking.</p> <p>Attributes:</p> Name Type Description <code>enola_id</code> <code>str</code> <p>Enola ID of the execution.</p> <code>agent_deploy_id</code> <code>str</code> <p>Agent deployment ID.</p> <code>url_evaluation_def_get</code> <code>str</code> <p>URL to get evaluation definitions.</p> <code>url_evaluation_post</code> <code>str</code> <p>URL to post evaluations.</p> <code>successfull</code> <code>bool</code> <p>Indicates if the tracking was successful.</p> <code>message</code> <code>str</code> <p>Response message.</p> <code>args</code> <code>Dict[str, Any]</code> <p>Additional arguments.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class TrackingResponseModel:\n    \"\"\"\n    Represents the response model for tracking.\n\n    Attributes:\n        enola_id (str): Enola ID of the execution.\n        agent_deploy_id (str): Agent deployment ID.\n        url_evaluation_def_get (str): URL to get evaluation definitions.\n        url_evaluation_post (str): URL to post evaluations.\n        successfull (bool): Indicates if the tracking was successful.\n        message (str): Response message.\n        args (Dict[str, Any]): Additional arguments.\n    \"\"\"\n\n    def __init__(\n        self,\n        successfull: Optional[bool] = None,\n        enola_id: str = \"\",\n        agent_deploy_id: str = \"\",\n        message: str = \"\",\n        url_evaluation_def_get: str = \"\",\n        url_evaluation_post: str = \"\",\n        **args,\n    ):\n        \"\"\"\n        Initializes a new instance of TrackingResponseModel.\n\n        Args:\n            successfull (bool, optional): Indicates if the tracking was successful.\n            enola_id (str, optional): Enola ID of the execution.\n            agent_deploy_id (str, optional): Agent deployment ID.\n            message (str, optional): Response message.\n            url_evaluation_def_get (str, optional): URL to get evaluation definitions.\n            url_evaluation_post (str, optional): URL to post evaluations.\n            **args: Additional keyword arguments.\n        \"\"\"\n        self.enola_id = enola_id or args.get(\"agentExecuteId\", \"\")\n        self.agent_deploy_id = agent_deploy_id or args.get(\"agentDeployId\", \"\")\n        self.url_evaluation_def_get = url_evaluation_def_get or args.get(\"urlEvaluationDefGet\", \"\")\n        self.url_evaluation_post = url_evaluation_post or args.get(\"urlEvaluationPost\", \"\")\n        self.successfull = successfull if successfull is not None else args.get(\"isSuccessful\", False)\n        self.message = message or args.get(\"message\", \"\")\n        self.args = args\n\n    def to_json(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Converts the TrackingResponseModel instance to a JSON-serializable dictionary.\n\n        Returns:\n            Dict[str, Any]: A dictionary representation of the TrackingResponseModel.\n        \"\"\"\n        return {\n            \"enolaId\": self.enola_id,\n            \"agentDeployId\": self.agent_deploy_id,\n            \"successfull\": self.successfull,\n            \"message\": self.message,\n            \"args\": self.args,\n        }\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingResponseModel.__init__","title":"<code>__init__(successfull=None, enola_id='', agent_deploy_id='', message='', url_evaluation_def_get='', url_evaluation_post='', **args)</code>","text":"<p>Initializes a new instance of TrackingResponseModel.</p> <p>Parameters:</p> Name Type Description Default <code>successfull</code> <code>bool</code> <p>Indicates if the tracking was successful.</p> <code>None</code> <code>enola_id</code> <code>str</code> <p>Enola ID of the execution.</p> <code>''</code> <code>agent_deploy_id</code> <code>str</code> <p>Agent deployment ID.</p> <code>''</code> <code>message</code> <code>str</code> <p>Response message.</p> <code>''</code> <code>url_evaluation_def_get</code> <code>str</code> <p>URL to get evaluation definitions.</p> <code>''</code> <code>url_evaluation_post</code> <code>str</code> <p>URL to post evaluations.</p> <code>''</code> <code>**args</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def __init__(\n    self,\n    successfull: Optional[bool] = None,\n    enola_id: str = \"\",\n    agent_deploy_id: str = \"\",\n    message: str = \"\",\n    url_evaluation_def_get: str = \"\",\n    url_evaluation_post: str = \"\",\n    **args,\n):\n    \"\"\"\n    Initializes a new instance of TrackingResponseModel.\n\n    Args:\n        successfull (bool, optional): Indicates if the tracking was successful.\n        enola_id (str, optional): Enola ID of the execution.\n        agent_deploy_id (str, optional): Agent deployment ID.\n        message (str, optional): Response message.\n        url_evaluation_def_get (str, optional): URL to get evaluation definitions.\n        url_evaluation_post (str, optional): URL to post evaluations.\n        **args: Additional keyword arguments.\n    \"\"\"\n    self.enola_id = enola_id or args.get(\"agentExecuteId\", \"\")\n    self.agent_deploy_id = agent_deploy_id or args.get(\"agentDeployId\", \"\")\n    self.url_evaluation_def_get = url_evaluation_def_get or args.get(\"urlEvaluationDefGet\", \"\")\n    self.url_evaluation_post = url_evaluation_post or args.get(\"urlEvaluationPost\", \"\")\n    self.successfull = successfull if successfull is not None else args.get(\"isSuccessful\", False)\n    self.message = message or args.get(\"message\", \"\")\n    self.args = args\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingResponseModel.to_json","title":"<code>to_json()</code>","text":"<p>Converts the TrackingResponseModel instance to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A dictionary representation of the TrackingResponseModel.</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Converts the TrackingResponseModel instance to a JSON-serializable dictionary.\n\n    Returns:\n        Dict[str, Any]: A dictionary representation of the TrackingResponseModel.\n    \"\"\"\n    return {\n        \"enolaId\": self.enola_id,\n        \"agentDeployId\": self.agent_deploy_id,\n        \"successfull\": self.successfull,\n        \"message\": self.message,\n        \"args\": self.args,\n    }\n</code></pre>"},{"location":"reference/evaluation/","title":"Evaluation","text":""},{"location":"reference/evaluation/#enola.evaluation.Evaluation","title":"<code>Evaluation</code>","text":"<p>The <code>Evaluation</code> class provides methods to evaluate executions in the Enola system.</p> <p>This class allows you to:</p> <ul> <li>Initialize an evaluation session.</li> <li>Add evaluations by value or level.</li> <li>Execute the evaluations and send the data to the Enola server.</li> </ul> Source code in <code>src\\enola\\evaluation.py</code> <pre><code>class Evaluation:\n    \"\"\"\n    The `Evaluation` class provides methods to evaluate executions in the Enola system.\n\n    This class allows you to:\n\n    - Initialize an evaluation session.\n    - Add evaluations by value or level.\n    - Execute the evaluations and send the data to the Enola server.\n    \"\"\"\n\n    def __init__(\n        self,\n        token: str,\n        eval_type: EvalType = EvalType.AUTO,\n        result_score: Optional[ResultScore] = None,\n        result_llm: Optional[ResultLLM] = None,\n        app_id: Optional[str] = None,\n        user_id: Optional[str] = None,\n        session_id: Optional[str] = None,\n        channel_id: Optional[str] = None,\n        ip: Optional[str] = None,\n        app_name: str = \"\",\n        user_name: str = \"\",\n        session_name: str = \"\",\n        channel_name: str = \"\",\n    ):\n        \"\"\"\n        Initializes a new `Evaluation` instance.\n\n        Args:\n            token (str): JWT token, used to identify the agent.\n            eval_type (EvalType, optional): Type of evaluation (AUTO, USER, INTERNAL).\n            result_score (ResultScore, optional): Actual results of score.\n            result_llm (ResultLLM, optional): Actual results of LLM.\n            app_id (str, optional): ID of the app calling the evaluation.\n            user_id (str, optional): External user ID.\n            session_id (str, optional): Session ID of the user or application.\n            channel_id (str, optional): Communication channel ID.\n            ip (str, optional): IP address of the user or application.\n            app_name (str, optional): Name of the app.\n            user_name (str, optional): Name of the user.\n            session_name (str, optional): Name of the session.\n            channel_name (str, optional): Name of the channel.\n        \"\"\"\n        self.hf = HuemulFunctions()\n        self.eval_type = eval_type\n        self.result_score = result_score\n        self.result_llm = result_llm\n\n        # Decode JWT token\n        self.token_info = TokenInfo(token=token)\n\n        if not self.token_info.is_service_account:\n            raise Exception(\n                \"This token is not a service account. Only service accounts can execute evaluations.\"\n            )\n\n        if (\n            self.token_info.is_service_account\n            and not self.token_info.service_account_can_evaluate\n        ):\n            raise Exception(\"Service Account can't evaluate\")\n\n        self.connection = Connect(\n            AuthModel(\n                jwt_token=token,\n                url_service=self.token_info.service_account_url,\n                org_id=self.token_info.org_id,\n            )\n        )\n\n        # User information\n        self.enola_sender = EnolaSenderModel(\n            app_id=app_id,\n            app_name=app_name,\n            user_id=user_id,\n            user_name=user_name,\n            session_id=session_id,\n            session_name=session_name,\n            channel_id=channel_id,\n            channel_name=channel_name,\n            batch_id=\"\",\n            client_id=\"\",\n            external_id=\"\",\n            product_id=\"\",\n            ip=ip,\n        )\n\n        # Current date\n        self.date_start = self.hf.get_date_for_api()\n        self.executions: List[EvaluationModel] = []\n\n    ########################################################################################\n    ###############    E V A L U A T I O N     M E T H O D S     ###########################\n    ########################################################################################\n\n    def execution_exists(self, enola_id: str) -&gt; Optional[EvaluationModel]:\n        \"\"\"\n        Checks if an execution exists.\n\n        Args:\n            enola_id (str): ID of Enola execution.\n\n        Returns:\n            Optional[EvaluationModel]: The evaluation model if it exists, None otherwise.\n        \"\"\"\n        for item in self.executions:\n            if item.enola_id == enola_id:\n                return item\n        return None\n\n    def add_evaluation(\n        self, enola_id: str, eval_id: str, value: float, comment: str\n    ) -&gt; None:\n        \"\"\"\n        Adds an evaluation by value.\n\n        Args:\n            enola_id (str): ID of Enola execution.\n            eval_id (str): ID of evaluation.\n            value (float): Value of evaluation.\n            comment (str): Comment of evaluation.\n        \"\"\"\n        eval_detail = EvaluationDetailModel(\n            eval_id=eval_id, value=value, comment=comment\n        )\n        execution = self.execution_exists(enola_id)\n\n        if execution is None:\n            execution = EvaluationModel(\n                enola_id,\n                eval_type=self.eval_type,\n                enola_sender=self.enola_sender,\n                result_score=self.result_score,\n                result_llm=self.result_llm,\n            )\n            self.executions.append(execution)\n\n        execution.add_eval(eval_detail)\n\n    def add_evaluation_by_level(\n        self, enola_id: str, eval_id: str, level: int, comment: str\n    ) -&gt; None:\n        \"\"\"\n        Adds an evaluation by level.\n\n        Args:\n            enola_id (str): ID of Enola execution.\n            eval_id (str): ID of evaluation.\n            level (int): Level from 1 to 5.\n            comment (str): Comment of evaluation.\n        \"\"\"\n        eval_detail = EvaluationDetailModel(\n            eval_id=eval_id, level=level, comment=comment\n        )\n        execution = self.execution_exists(enola_id)\n\n        if execution is None:\n            execution = EvaluationModel(\n                enola_id,\n                eval_type=self.eval_type,\n                enola_sender=self.enola_sender,\n            )\n            self.executions.append(execution)\n\n        execution.add_eval(eval_detail)\n\n    def execute(self) -&gt; EvaluationResultModel:\n        \"\"\"\n        Executes the evaluations.\n\n        Returns:\n            EvaluationResultModel: The result of the evaluations.\n        \"\"\"\n        final_result = EvaluationResultModel(\n            total_evals=len(self.executions),\n            total_errors=0,\n            total_success=0,\n            errors=[],\n        )\n\n        for item in self.executions:\n            result = create_evaluation(\n                evaluation_model=item, connection=self.connection\n            )\n            if not result.successfull:\n                print(result.errors)\n                print(result.message)\n                final_result.errors.append(result.message)\n\n        return final_result\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/evaluation/#enola.evaluation.Evaluation.__init__","title":"<code>__init__(token, eval_type=EvalType.AUTO, result_score=None, result_llm=None, app_id=None, user_id=None, session_id=None, channel_id=None, ip=None, app_name='', user_name='', session_name='', channel_name='')</code>","text":"<p>Initializes a new <code>Evaluation</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>JWT token, used to identify the agent.</p> required <code>eval_type</code> <code>EvalType</code> <p>Type of evaluation (AUTO, USER, INTERNAL).</p> <code>AUTO</code> <code>result_score</code> <code>ResultScore</code> <p>Actual results of score.</p> <code>None</code> <code>result_llm</code> <code>ResultLLM</code> <p>Actual results of LLM.</p> <code>None</code> <code>app_id</code> <code>str</code> <p>ID of the app calling the evaluation.</p> <code>None</code> <code>user_id</code> <code>str</code> <p>External user ID.</p> <code>None</code> <code>session_id</code> <code>str</code> <p>Session ID of the user or application.</p> <code>None</code> <code>channel_id</code> <code>str</code> <p>Communication channel ID.</p> <code>None</code> <code>ip</code> <code>str</code> <p>IP address of the user or application.</p> <code>None</code> <code>app_name</code> <code>str</code> <p>Name of the app.</p> <code>''</code> <code>user_name</code> <code>str</code> <p>Name of the user.</p> <code>''</code> <code>session_name</code> <code>str</code> <p>Name of the session.</p> <code>''</code> <code>channel_name</code> <code>str</code> <p>Name of the channel.</p> <code>''</code> Source code in <code>src\\enola\\evaluation.py</code> <pre><code>def __init__(\n    self,\n    token: str,\n    eval_type: EvalType = EvalType.AUTO,\n    result_score: Optional[ResultScore] = None,\n    result_llm: Optional[ResultLLM] = None,\n    app_id: Optional[str] = None,\n    user_id: Optional[str] = None,\n    session_id: Optional[str] = None,\n    channel_id: Optional[str] = None,\n    ip: Optional[str] = None,\n    app_name: str = \"\",\n    user_name: str = \"\",\n    session_name: str = \"\",\n    channel_name: str = \"\",\n):\n    \"\"\"\n    Initializes a new `Evaluation` instance.\n\n    Args:\n        token (str): JWT token, used to identify the agent.\n        eval_type (EvalType, optional): Type of evaluation (AUTO, USER, INTERNAL).\n        result_score (ResultScore, optional): Actual results of score.\n        result_llm (ResultLLM, optional): Actual results of LLM.\n        app_id (str, optional): ID of the app calling the evaluation.\n        user_id (str, optional): External user ID.\n        session_id (str, optional): Session ID of the user or application.\n        channel_id (str, optional): Communication channel ID.\n        ip (str, optional): IP address of the user or application.\n        app_name (str, optional): Name of the app.\n        user_name (str, optional): Name of the user.\n        session_name (str, optional): Name of the session.\n        channel_name (str, optional): Name of the channel.\n    \"\"\"\n    self.hf = HuemulFunctions()\n    self.eval_type = eval_type\n    self.result_score = result_score\n    self.result_llm = result_llm\n\n    # Decode JWT token\n    self.token_info = TokenInfo(token=token)\n\n    if not self.token_info.is_service_account:\n        raise Exception(\n            \"This token is not a service account. Only service accounts can execute evaluations.\"\n        )\n\n    if (\n        self.token_info.is_service_account\n        and not self.token_info.service_account_can_evaluate\n    ):\n        raise Exception(\"Service Account can't evaluate\")\n\n    self.connection = Connect(\n        AuthModel(\n            jwt_token=token,\n            url_service=self.token_info.service_account_url,\n            org_id=self.token_info.org_id,\n        )\n    )\n\n    # User information\n    self.enola_sender = EnolaSenderModel(\n        app_id=app_id,\n        app_name=app_name,\n        user_id=user_id,\n        user_name=user_name,\n        session_id=session_id,\n        session_name=session_name,\n        channel_id=channel_id,\n        channel_name=channel_name,\n        batch_id=\"\",\n        client_id=\"\",\n        external_id=\"\",\n        product_id=\"\",\n        ip=ip,\n    )\n\n    # Current date\n    self.date_start = self.hf.get_date_for_api()\n    self.executions: List[EvaluationModel] = []\n</code></pre>"},{"location":"reference/evaluation/#enola.evaluation.Evaluation.add_evaluation","title":"<code>add_evaluation(enola_id, eval_id, value, comment)</code>","text":"<p>Adds an evaluation by value.</p> <p>Parameters:</p> Name Type Description Default <code>enola_id</code> <code>str</code> <p>ID of Enola execution.</p> required <code>eval_id</code> <code>str</code> <p>ID of evaluation.</p> required <code>value</code> <code>float</code> <p>Value of evaluation.</p> required <code>comment</code> <code>str</code> <p>Comment of evaluation.</p> required Source code in <code>src\\enola\\evaluation.py</code> <pre><code>def add_evaluation(\n    self, enola_id: str, eval_id: str, value: float, comment: str\n) -&gt; None:\n    \"\"\"\n    Adds an evaluation by value.\n\n    Args:\n        enola_id (str): ID of Enola execution.\n        eval_id (str): ID of evaluation.\n        value (float): Value of evaluation.\n        comment (str): Comment of evaluation.\n    \"\"\"\n    eval_detail = EvaluationDetailModel(\n        eval_id=eval_id, value=value, comment=comment\n    )\n    execution = self.execution_exists(enola_id)\n\n    if execution is None:\n        execution = EvaluationModel(\n            enola_id,\n            eval_type=self.eval_type,\n            enola_sender=self.enola_sender,\n            result_score=self.result_score,\n            result_llm=self.result_llm,\n        )\n        self.executions.append(execution)\n\n    execution.add_eval(eval_detail)\n</code></pre>"},{"location":"reference/evaluation/#enola.evaluation.Evaluation.add_evaluation_by_level","title":"<code>add_evaluation_by_level(enola_id, eval_id, level, comment)</code>","text":"<p>Adds an evaluation by level.</p> <p>Parameters:</p> Name Type Description Default <code>enola_id</code> <code>str</code> <p>ID of Enola execution.</p> required <code>eval_id</code> <code>str</code> <p>ID of evaluation.</p> required <code>level</code> <code>int</code> <p>Level from 1 to 5.</p> required <code>comment</code> <code>str</code> <p>Comment of evaluation.</p> required Source code in <code>src\\enola\\evaluation.py</code> <pre><code>def add_evaluation_by_level(\n    self, enola_id: str, eval_id: str, level: int, comment: str\n) -&gt; None:\n    \"\"\"\n    Adds an evaluation by level.\n\n    Args:\n        enola_id (str): ID of Enola execution.\n        eval_id (str): ID of evaluation.\n        level (int): Level from 1 to 5.\n        comment (str): Comment of evaluation.\n    \"\"\"\n    eval_detail = EvaluationDetailModel(\n        eval_id=eval_id, level=level, comment=comment\n    )\n    execution = self.execution_exists(enola_id)\n\n    if execution is None:\n        execution = EvaluationModel(\n            enola_id,\n            eval_type=self.eval_type,\n            enola_sender=self.enola_sender,\n        )\n        self.executions.append(execution)\n\n    execution.add_eval(eval_detail)\n</code></pre>"},{"location":"reference/evaluation/#enola.evaluation.Evaluation.execute","title":"<code>execute()</code>","text":"<p>Executes the evaluations.</p> <p>Returns:</p> Name Type Description <code>EvaluationResultModel</code> <code>EvaluationResultModel</code> <p>The result of the evaluations.</p> Source code in <code>src\\enola\\evaluation.py</code> <pre><code>def execute(self) -&gt; EvaluationResultModel:\n    \"\"\"\n    Executes the evaluations.\n\n    Returns:\n        EvaluationResultModel: The result of the evaluations.\n    \"\"\"\n    final_result = EvaluationResultModel(\n        total_evals=len(self.executions),\n        total_errors=0,\n        total_success=0,\n        errors=[],\n    )\n\n    for item in self.executions:\n        result = create_evaluation(\n            evaluation_model=item, connection=self.connection\n        )\n        if not result.successfull:\n            print(result.errors)\n            print(result.message)\n            final_result.errors.append(result.message)\n\n    return final_result\n</code></pre>"},{"location":"reference/evaluation/#enola.evaluation.Evaluation.execution_exists","title":"<code>execution_exists(enola_id)</code>","text":"<p>Checks if an execution exists.</p> <p>Parameters:</p> Name Type Description Default <code>enola_id</code> <code>str</code> <p>ID of Enola execution.</p> required <p>Returns:</p> Type Description <code>Optional[EvaluationModel]</code> <p>Optional[EvaluationModel]: The evaluation model if it exists, None otherwise.</p> Source code in <code>src\\enola\\evaluation.py</code> <pre><code>def execution_exists(self, enola_id: str) -&gt; Optional[EvaluationModel]:\n    \"\"\"\n    Checks if an execution exists.\n\n    Args:\n        enola_id (str): ID of Enola execution.\n\n    Returns:\n        Optional[EvaluationModel]: The evaluation model if it exists, None otherwise.\n    \"\"\"\n    for item in self.executions:\n        if item.enola_id == enola_id:\n            return item\n    return None\n</code></pre>"},{"location":"reference/get_executions/","title":"Get Executions","text":""},{"location":"reference/get_executions/#enola.get_executions.GetExecutions","title":"<code>GetExecutions</code>","text":"<p>The <code>GetExecutions</code> class provides methods to retrieve executions from the Enola system.</p> <p>This class allows you to:</p> <ul> <li>Initialize a retrieval session.</li> <li>Query executions based on various filters.</li> <li>Fetch subsequent pages of results.</li> </ul> Source code in <code>src\\enola\\get_executions.py</code> <pre><code>class GetExecutions:\n    \"\"\"\n    The `GetExecutions` class provides methods to retrieve executions from the Enola system.\n\n    This class allows you to:\n\n    - Initialize a retrieval session.\n    - Query executions based on various filters.\n    - Fetch subsequent pages of results.\n    \"\"\"\n\n    def __init__(self, token: str, raise_error_if_fail: bool = True):\n        \"\"\"\n        Initializes a new `GetExecutions` instance.\n\n        Args:\n            token (str): JWT token used to identify the agent.\n            raise_error_if_fail (bool, optional): Whether to raise an error if the retrieval fails.\n        \"\"\"\n        self.raise_error_if_fail = raise_error_if_fail\n        self.num_rows_acum = 0\n        self.num_rows = 0\n        self.continue_execution = False\n        self.hf = HuemulFunctions()\n        # Connection data\n\n        # Get token info\n        self.token_info = TokenInfo(token=token)\n\n        if (\n            self.token_info.is_service_account\n            and not self.token_info.service_account_can_get_executions\n        ):\n            raise Exception(\"Service Account Token is not allowed to get executions\")\n\n        self.connection = Connect(\n            AuthModel(\n                jwt_token=token,\n                url_service=self.token_info.service_account_url_backend,\n                org_id=self.token_info.org_id,\n            )\n        )\n\n    def get_next_page(self) -&gt; ExecutionModel:\n        \"\"\"\n        Retrieves the next page of results.\n\n        Returns:\n            ExecutionModel: The execution model containing the results.\n        \"\"\"\n        if not self.continue_execution:\n            raise Exception(\"No more data to show.\")\n\n        self.execution_query_model.page_number += 1\n        enola_result = self.__run_query()\n\n        # Show results\n        return enola_result\n\n    def get_page_number(self) -&gt; int:\n        \"\"\"\n        Gets the current page number.\n\n        Returns:\n            int: The current page number.\n        \"\"\"\n        return self.execution_query_model.page_number\n\n    def query(\n        self,\n        date_from: str,\n        date_to: str,\n        chamber_id_list: Optional[List[str]] = None,\n        agent_id_list: Optional[List[str]] = None,\n        agent_deploy_id_list: Optional[List[str]] = None,\n        user_id_list: Optional[List[str]] = None,\n        session_id_list: Optional[List[str]] = None,\n        channel_id_list: Optional[List[str]] = None,\n        data_filter_list: Optional[List[Any]] = None,\n        eval_id_user: Optional[ExecutionEvalFilter] = None,\n        eval_id_internal: Optional[ExecutionEvalFilter] = None,\n        eval_id_auto: Optional[ExecutionEvalFilter] = None,\n        environment_id: Optional[Environtment] = None,\n        is_test_plan: Optional[bool] = None,\n        finished: Optional[bool] = None,\n        limit: int = 100,\n        include_tags: bool = False,\n        include_data: bool = False,\n        include_errors: bool = False,\n        include_evals: bool = False,\n    ) -&gt; ExecutionModel:\n        \"\"\"\n        Queries executions based on various filters.\n\n        Args:\n            date_from (str): Start date.\n            date_to (str): End date.\n            chamber_id_list (List[str], optional): List of chamber IDs.\n            agent_id_list (List[str], optional): List of agent IDs.\n            agent_deploy_id_list (List[str], optional): List of agent deploy IDs.\n            user_id_list (List[str], optional): List of user IDs.\n            session_id_list (List[str], optional): List of session IDs.\n            channel_id_list (List[str], optional): List of channel IDs.\n            data_filter_list (List[Any], optional): List of data filters.\n            eval_id_user (ExecutionEvalFilter, optional): User evaluation filter.\n            eval_id_internal (ExecutionEvalFilter, optional): Internal evaluation filter.\n            eval_id_auto (ExecutionEvalFilter, optional): Auto evaluation filter.\n            environment_id (Environtment, optional): Environment ID.\n            is_test_plan (bool, optional): Whether it's a test plan.\n            finished (bool, optional): Whether execution is finished.\n            limit (int, optional): Limit of results per page.\n            include_tags (bool, optional): Whether to include tags.\n            include_data (bool, optional): Whether to include data.\n            include_errors (bool, optional): Whether to include errors.\n            include_evals (bool, optional): Whether to include evaluations.\n\n        Returns:\n            ExecutionModel: The execution model containing the results.\n        \"\"\"\n        chamber_id_list = chamber_id_list or []\n        agent_id_list = agent_id_list or []\n        agent_deploy_id_list = agent_deploy_id_list or []\n\n        if (\n            self.token_info.agent_deploy_id\n            and self.token_info.agent_deploy_id != \"0\"\n        ):\n            if len(agent_deploy_id_list) &gt; 1:\n                raise Exception(\n                    \"Service Account Token is not allowed to access more than one agent_deploy_id\",\n                    self.token_info.agent_deploy_id,\n                )\n            if len(agent_deploy_id_list) == 1:\n                if self.token_info.agent_deploy_id != agent_deploy_id_list[0]:\n                    raise Exception(\n                        \"Service Account Token is not allowed to access this agent_deploy_id\",\n                        self.token_info.agent_deploy_id,\n                    )\n            else:\n                agent_deploy_id_list = [self.token_info.agent_deploy_id]\n\n        if not chamber_id_list and not agent_id_list and not agent_deploy_id_list:\n            raise Exception(\n                \"chamber_id or agent_id or agent_deploy_id must be filled.\"\n            )\n\n        self.num_rows_acum = 0\n        self.num_rows = 0\n        self.continue_execution = True\n\n        self.execution_query_model = ExecutionQueryModel(\n            date_from=date_from,\n            date_to=date_to,\n            chamber_id_list=chamber_id_list,\n            agent_id_list=agent_id_list,\n            agent_deploy_id_list=agent_deploy_id_list,\n            user_id_list=user_id_list,\n            session_id_list=session_id_list,\n            channel_id_list=channel_id_list,\n            data_filter_list=data_filter_list,\n            eval_id_user=eval_id_user,\n            eval_id_internal=eval_id_internal,\n            eval_id_auto=eval_id_auto,\n            environment_id=environment_id,\n            is_test_plan=is_test_plan,\n            finished=finished,\n            limit=limit,\n            page_number=0,\n            include_tags=include_tags,\n            include_data=include_data,\n            include_errors=include_errors,\n            include_evals=include_evals,\n        )\n\n    def __run_query(self) -&gt; ExecutionModel:\n        \"\"\"\n        Runs the query using the current execution query model.\n\n        Returns:\n            ExecutionModel: The execution model containing the results.\n        \"\"\"\n        enola_result = get_execution(\n            execution_query_model=self.execution_query_model,\n            connection=self.connection,\n            raise_error_if_fail=self.raise_error_if_fail,\n        )\n\n        self.num_rows = len(enola_result.data)\n\n        self.continue_execution = False\n        if (\n            self.num_rows == self.execution_query_model.limit\n            and self.num_rows != 0\n        ):\n            self.continue_execution = True\n\n        self.num_rows_acum += self.num_rows\n\n        return enola_result\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/get_executions/#enola.get_executions.GetExecutions.__init__","title":"<code>__init__(token, raise_error_if_fail=True)</code>","text":"<p>Initializes a new <code>GetExecutions</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>JWT token used to identify the agent.</p> required <code>raise_error_if_fail</code> <code>bool</code> <p>Whether to raise an error if the retrieval fails.</p> <code>True</code> Source code in <code>src\\enola\\get_executions.py</code> <pre><code>def __init__(self, token: str, raise_error_if_fail: bool = True):\n    \"\"\"\n    Initializes a new `GetExecutions` instance.\n\n    Args:\n        token (str): JWT token used to identify the agent.\n        raise_error_if_fail (bool, optional): Whether to raise an error if the retrieval fails.\n    \"\"\"\n    self.raise_error_if_fail = raise_error_if_fail\n    self.num_rows_acum = 0\n    self.num_rows = 0\n    self.continue_execution = False\n    self.hf = HuemulFunctions()\n    # Connection data\n\n    # Get token info\n    self.token_info = TokenInfo(token=token)\n\n    if (\n        self.token_info.is_service_account\n        and not self.token_info.service_account_can_get_executions\n    ):\n        raise Exception(\"Service Account Token is not allowed to get executions\")\n\n    self.connection = Connect(\n        AuthModel(\n            jwt_token=token,\n            url_service=self.token_info.service_account_url_backend,\n            org_id=self.token_info.org_id,\n        )\n    )\n</code></pre>"},{"location":"reference/get_executions/#enola.get_executions.GetExecutions.__run_query","title":"<code>__run_query()</code>","text":"<p>Runs the query using the current execution query model.</p> <p>Returns:</p> Name Type Description <code>ExecutionModel</code> <code>ExecutionModel</code> <p>The execution model containing the results.</p> Source code in <code>src\\enola\\get_executions.py</code> <pre><code>def __run_query(self) -&gt; ExecutionModel:\n    \"\"\"\n    Runs the query using the current execution query model.\n\n    Returns:\n        ExecutionModel: The execution model containing the results.\n    \"\"\"\n    enola_result = get_execution(\n        execution_query_model=self.execution_query_model,\n        connection=self.connection,\n        raise_error_if_fail=self.raise_error_if_fail,\n    )\n\n    self.num_rows = len(enola_result.data)\n\n    self.continue_execution = False\n    if (\n        self.num_rows == self.execution_query_model.limit\n        and self.num_rows != 0\n    ):\n        self.continue_execution = True\n\n    self.num_rows_acum += self.num_rows\n\n    return enola_result\n</code></pre>"},{"location":"reference/get_executions/#enola.get_executions.GetExecutions.get_next_page","title":"<code>get_next_page()</code>","text":"<p>Retrieves the next page of results.</p> <p>Returns:</p> Name Type Description <code>ExecutionModel</code> <code>ExecutionModel</code> <p>The execution model containing the results.</p> Source code in <code>src\\enola\\get_executions.py</code> <pre><code>def get_next_page(self) -&gt; ExecutionModel:\n    \"\"\"\n    Retrieves the next page of results.\n\n    Returns:\n        ExecutionModel: The execution model containing the results.\n    \"\"\"\n    if not self.continue_execution:\n        raise Exception(\"No more data to show.\")\n\n    self.execution_query_model.page_number += 1\n    enola_result = self.__run_query()\n\n    # Show results\n    return enola_result\n</code></pre>"},{"location":"reference/get_executions/#enola.get_executions.GetExecutions.get_page_number","title":"<code>get_page_number()</code>","text":"<p>Gets the current page number.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current page number.</p> Source code in <code>src\\enola\\get_executions.py</code> <pre><code>def get_page_number(self) -&gt; int:\n    \"\"\"\n    Gets the current page number.\n\n    Returns:\n        int: The current page number.\n    \"\"\"\n    return self.execution_query_model.page_number\n</code></pre>"},{"location":"reference/get_executions/#enola.get_executions.GetExecutions.query","title":"<code>query(date_from, date_to, chamber_id_list=None, agent_id_list=None, agent_deploy_id_list=None, user_id_list=None, session_id_list=None, channel_id_list=None, data_filter_list=None, eval_id_user=None, eval_id_internal=None, eval_id_auto=None, environment_id=None, is_test_plan=None, finished=None, limit=100, include_tags=False, include_data=False, include_errors=False, include_evals=False)</code>","text":"<p>Queries executions based on various filters.</p> <p>Parameters:</p> Name Type Description Default <code>date_from</code> <code>str</code> <p>Start date.</p> required <code>date_to</code> <code>str</code> <p>End date.</p> required <code>chamber_id_list</code> <code>List[str]</code> <p>List of chamber IDs.</p> <code>None</code> <code>agent_id_list</code> <code>List[str]</code> <p>List of agent IDs.</p> <code>None</code> <code>agent_deploy_id_list</code> <code>List[str]</code> <p>List of agent deploy IDs.</p> <code>None</code> <code>user_id_list</code> <code>List[str]</code> <p>List of user IDs.</p> <code>None</code> <code>session_id_list</code> <code>List[str]</code> <p>List of session IDs.</p> <code>None</code> <code>channel_id_list</code> <code>List[str]</code> <p>List of channel IDs.</p> <code>None</code> <code>data_filter_list</code> <code>List[Any]</code> <p>List of data filters.</p> <code>None</code> <code>eval_id_user</code> <code>ExecutionEvalFilter</code> <p>User evaluation filter.</p> <code>None</code> <code>eval_id_internal</code> <code>ExecutionEvalFilter</code> <p>Internal evaluation filter.</p> <code>None</code> <code>eval_id_auto</code> <code>ExecutionEvalFilter</code> <p>Auto evaluation filter.</p> <code>None</code> <code>environment_id</code> <code>Environtment</code> <p>Environment ID.</p> <code>None</code> <code>is_test_plan</code> <code>bool</code> <p>Whether it's a test plan.</p> <code>None</code> <code>finished</code> <code>bool</code> <p>Whether execution is finished.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Limit of results per page.</p> <code>100</code> <code>include_tags</code> <code>bool</code> <p>Whether to include tags.</p> <code>False</code> <code>include_data</code> <code>bool</code> <p>Whether to include data.</p> <code>False</code> <code>include_errors</code> <code>bool</code> <p>Whether to include errors.</p> <code>False</code> <code>include_evals</code> <code>bool</code> <p>Whether to include evaluations.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>ExecutionModel</code> <code>ExecutionModel</code> <p>The execution model containing the results.</p> Source code in <code>src\\enola\\get_executions.py</code> <pre><code>def query(\n    self,\n    date_from: str,\n    date_to: str,\n    chamber_id_list: Optional[List[str]] = None,\n    agent_id_list: Optional[List[str]] = None,\n    agent_deploy_id_list: Optional[List[str]] = None,\n    user_id_list: Optional[List[str]] = None,\n    session_id_list: Optional[List[str]] = None,\n    channel_id_list: Optional[List[str]] = None,\n    data_filter_list: Optional[List[Any]] = None,\n    eval_id_user: Optional[ExecutionEvalFilter] = None,\n    eval_id_internal: Optional[ExecutionEvalFilter] = None,\n    eval_id_auto: Optional[ExecutionEvalFilter] = None,\n    environment_id: Optional[Environtment] = None,\n    is_test_plan: Optional[bool] = None,\n    finished: Optional[bool] = None,\n    limit: int = 100,\n    include_tags: bool = False,\n    include_data: bool = False,\n    include_errors: bool = False,\n    include_evals: bool = False,\n) -&gt; ExecutionModel:\n    \"\"\"\n    Queries executions based on various filters.\n\n    Args:\n        date_from (str): Start date.\n        date_to (str): End date.\n        chamber_id_list (List[str], optional): List of chamber IDs.\n        agent_id_list (List[str], optional): List of agent IDs.\n        agent_deploy_id_list (List[str], optional): List of agent deploy IDs.\n        user_id_list (List[str], optional): List of user IDs.\n        session_id_list (List[str], optional): List of session IDs.\n        channel_id_list (List[str], optional): List of channel IDs.\n        data_filter_list (List[Any], optional): List of data filters.\n        eval_id_user (ExecutionEvalFilter, optional): User evaluation filter.\n        eval_id_internal (ExecutionEvalFilter, optional): Internal evaluation filter.\n        eval_id_auto (ExecutionEvalFilter, optional): Auto evaluation filter.\n        environment_id (Environtment, optional): Environment ID.\n        is_test_plan (bool, optional): Whether it's a test plan.\n        finished (bool, optional): Whether execution is finished.\n        limit (int, optional): Limit of results per page.\n        include_tags (bool, optional): Whether to include tags.\n        include_data (bool, optional): Whether to include data.\n        include_errors (bool, optional): Whether to include errors.\n        include_evals (bool, optional): Whether to include evaluations.\n\n    Returns:\n        ExecutionModel: The execution model containing the results.\n    \"\"\"\n    chamber_id_list = chamber_id_list or []\n    agent_id_list = agent_id_list or []\n    agent_deploy_id_list = agent_deploy_id_list or []\n\n    if (\n        self.token_info.agent_deploy_id\n        and self.token_info.agent_deploy_id != \"0\"\n    ):\n        if len(agent_deploy_id_list) &gt; 1:\n            raise Exception(\n                \"Service Account Token is not allowed to access more than one agent_deploy_id\",\n                self.token_info.agent_deploy_id,\n            )\n        if len(agent_deploy_id_list) == 1:\n            if self.token_info.agent_deploy_id != agent_deploy_id_list[0]:\n                raise Exception(\n                    \"Service Account Token is not allowed to access this agent_deploy_id\",\n                    self.token_info.agent_deploy_id,\n                )\n        else:\n            agent_deploy_id_list = [self.token_info.agent_deploy_id]\n\n    if not chamber_id_list and not agent_id_list and not agent_deploy_id_list:\n        raise Exception(\n            \"chamber_id or agent_id or agent_deploy_id must be filled.\"\n        )\n\n    self.num_rows_acum = 0\n    self.num_rows = 0\n    self.continue_execution = True\n\n    self.execution_query_model = ExecutionQueryModel(\n        date_from=date_from,\n        date_to=date_to,\n        chamber_id_list=chamber_id_list,\n        agent_id_list=agent_id_list,\n        agent_deploy_id_list=agent_deploy_id_list,\n        user_id_list=user_id_list,\n        session_id_list=session_id_list,\n        channel_id_list=channel_id_list,\n        data_filter_list=data_filter_list,\n        eval_id_user=eval_id_user,\n        eval_id_internal=eval_id_internal,\n        eval_id_auto=eval_id_auto,\n        environment_id=environment_id,\n        is_test_plan=is_test_plan,\n        finished=finished,\n        limit=limit,\n        page_number=0,\n        include_tags=include_tags,\n        include_data=include_data,\n        include_errors=include_errors,\n        include_evals=include_evals,\n    )\n</code></pre>"},{"location":"reference/tracking/","title":"Tracking","text":""},{"location":"reference/tracking/#enola.tracking.Tracking","title":"<code>Tracking</code>","text":"<p>The <code>Tracking</code> class provides methods to start and manage execution tracking in the Enola system.</p> <p>This class allows you to:</p> <ul> <li>Initialize a tracking session.</li> <li>Add data received from or sent to the user.</li> <li>Register custom information, errors, warnings, and steps.</li> <li>Execute the tracking and send the data to the Enola server.</li> </ul> <p>Example usage:</p> <pre><code>tracking = Tracking(\n    token='your_jwt_token',\n    name='ExecutionName',\n    message_input='User input message',\n    app_id='App123',\n    user_id='User456',\n    is_test=False\n)\n</code></pre> Source code in <code>src\\enola\\tracking.py</code> <pre><code>class Tracking:\n    \"\"\"\n    The `Tracking` class provides methods to start and manage execution tracking in the Enola system.\n\n    This class allows you to:\n\n    - Initialize a tracking session.\n    - Add data received from or sent to the user.\n    - Register custom information, errors, warnings, and steps.\n    - Execute the tracking and send the data to the Enola server.\n\n    **Example usage:**\n\n    ```python\n    tracking = Tracking(\n        token='your_jwt_token',\n        name='ExecutionName',\n        message_input='User input message',\n        app_id='App123',\n        user_id='User456',\n        is_test=False\n    )\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        token: str,\n        name: str,\n        app_id: Optional[str] = None,\n        user_id: Optional[str] = None,\n        session_id: Optional[str] = None,\n        channel_id: Optional[str] = None,\n        ip: Optional[str] = None,\n        external_id: Optional[str] = None,\n        is_test: bool = False,\n        message_input: str = \"\",\n        enola_id_prev: str = \"\",\n        app_name: str = \"\",\n        user_name: str = \"\",\n        session_name: str = \"\",\n        channel_name: str = \"\",\n        client_id: str = \"\",\n        product_id: str = \"\",\n    ):\n        \"\"\"\n        Initializes a new `Tracking` instance to start tracking an execution.\n\n        Args:\n            token (str): JWT token used to identify the agent (request from Admin App).\n            name (str): Name of this execution.\n            app_id (str, optional): ID of the app that is calling.\n            user_id (str, optional): External user ID.\n            session_id (str, optional): ID of the user or application's session.\n            channel_id (str, optional): Communication channel (e.g., 'web', 'chat', 'whatsapp').\n            ip (str, optional): IP address of the user or application.\n            external_id (str, optional): External unique record identifier.\n            is_test (bool, optional): True if this call is for testing purposes.\n            message_input (str, optional): Message received from the user or to explain the execution.\n            enola_id_prev (str, optional): ID of the previous call to link agent sequences.\n            app_name (str, optional): Name of the app.\n            user_name (str, optional): Name of the user.\n            session_name (str, optional): Name of the session.\n            channel_name (str, optional): Name of the channel.\n            client_id (str, optional): Client ID.\n            product_id (str, optional): Product ID.\n        \"\"\"\n        self.name = name\n        self.enola_id_prev = enola_id_prev\n        self.enola_id = \"\"  # Obtained after execution\n        self.agent_deploy_id = \"\"\n        self.message_input = message_input\n        self.message_output = \"\"\n        self.num_iteratons = 0\n        self.hf = HuemulFunctions()\n        self.url_evaluation_post = None\n        self.url_evaluation_def_get = None\n\n        # This execution information\n        self.tracking_status = \"\"\n        # Connection data\n\n        # Decode JWT token\n        self.token_info = TokenInfo(token=token)\n\n        if not self.token_info.is_service_account:\n            raise Exception(\n                \"This token is not a service account. Only service accounts can execute tracking\"\n            )\n\n        if not self.token_info.agent_deploy_id:\n            raise Exception(\"agentDeployId is empty.\")\n\n        if not self.token_info.service_account_can_tracking:\n            raise Exception(\"This service account can't execute tracking\")\n\n        self.agent_deploy_id = self.token_info.agent_deploy_id\n        self.connection = Connect(\n            AuthModel(\n                jwt_token=token,\n                url_service=self.token_info.service_account_url,\n                org_id=self.token_info.org_id,\n            )\n        )\n\n        # User information\n        self.enola_sender = EnolaSenderModel(\n            app_id=app_id,\n            batch_id=None,\n            app_name=app_name,\n            user_id=user_id,\n            user_name=user_name,\n            session_id=session_id,\n            session_name=session_name,\n            channel_id=channel_id,\n            channel_name=channel_name,\n            ip=ip,\n            external_id=external_id,\n            client_id=client_id,\n            product_id=product_id,\n        )\n\n        # If is empty or not exist assign false\n        self.is_test = is_test\n\n        # Save steps and information\n        self.step_list: List[Step] = []\n        self.steps = 0\n        self.first_step = self.new_step(self.name, message_input=self.message_input)\n\n    ########################################################################################\n    ###############    A G E N T   M E T H O D S     #######################################\n    ########################################################################################\n\n    def add_data_received(self, name: str, data: Any, type: DataType) -&gt; None:\n        \"\"\"\n        Adds data received from the user.\n\n        Args:\n            name (str): The name of the data.\n            data (Any): The data content.\n            type (DataType): The type of data received.\n        \"\"\"\n        self.first_step.agent_data_list.append(\n            DataListModel(\n                value=data, name=name, data_type=type, kind=KindType.RECEIVER\n            )\n        )\n\n    def add_data_send(self, name: str, data: Any, type: DataType) -&gt; None:\n        \"\"\"\n        Adds data to send to the user.\n\n        Args:\n            name (str): The name of the data.\n            data (Any): The data content.\n            type (DataType): The type of data being sent.\n        \"\"\"\n        self.first_step.agent_data_list.append(\n            DataListModel(value=data, name=name, data_type=type, kind=KindType.SENDER)\n        )\n\n    def add_custom_info(self, key: str, value: Any) -&gt; None:\n        \"\"\"\n        Adds custom information to tracking.\n\n        Args:\n            key (str): The key for the custom information.\n            value (Any): The value associated with the key.\n        \"\"\"\n        self.first_step.info_list.append(Info(key, value))\n\n    def add_file_link(\n        self, name: str, url: str, type: str, size_kb: int\n    ) -&gt; None:\n        \"\"\"\n        Adds a file link to tracking.\n\n        Args:\n            name (str): The name of the file.\n            url (str): The URL of the file.\n            type (str): The type of the file.\n            size_kb (int): The size of the file in kilobytes.\n        \"\"\"\n        self.first_step.add_file_link(\n            name=name, url=url, type=type, size_kb=size_kb\n        )\n\n    def add_tag(self, key: str, value: Any) -&gt; None:\n        \"\"\"\n        Adds a tag to tracking, this tag is used to search in Enola App.\n\n        Args:\n            key (str): The tag key.\n            value (Any): The tag value.\n        \"\"\"\n        self.first_step.add_tag(key=key, value=value)\n\n    def add_extra_info(self, key: str, value: Any) -&gt; None:\n        \"\"\"\n        Adds extra information to tracking, this can be used to test or debug.\n\n        Args:\n            key (str): The key for the extra information.\n            value (Any): The value associated with the key.\n        \"\"\"\n        self.first_step.add_extra_info(key=key, value=value)\n\n    def add_error(self, id: str, message: str, kind: ErrOrWarnKind) -&gt; None:\n        \"\"\"\n        Registers an error to tracking.\n\n        Args:\n            id (str): The error identifier.\n            message (str): The error message.\n            kind (ErrOrWarnKind): The kind of error.\n        \"\"\"\n        self.first_step.add_error(id=id, message=message, kind=kind)\n\n    def add_warning(self, id: str, message: str, kind: ErrOrWarnKind) -&gt; None:\n        \"\"\"\n        Registers a warning to tracking.\n\n        Args:\n            id (str): The warning identifier.\n            message (str): The warning message.\n            kind (ErrOrWarnKind): The kind of warning.\n        \"\"\"\n        self.first_step.add_warning(id=id, message=message, kind=kind)\n\n    def execute(\n        self,\n        successfull: bool,\n        message_output: str = \"\",\n        num_iteratons: int = 0,\n        score_value: float = 0,\n        score_group: str = \"\",\n        score_cluster: str = \"\",\n        score_date: str = \"\",\n        external_id: str = \"\",\n    ) -&gt; bool:\n        \"\"\"\n        Registers tracking in the Enola server.\n\n        Args:\n            successfull (bool): True for your Agent execution OK, false for error in your Agent execution.\n            message_output (str, optional): Message to user or to explain the execution results.\n            num_iteratons (int, optional): Number of iterations.\n            score_value (float, optional): Score value.\n            score_group (str, optional): Score group.\n            score_cluster (str, optional): Score cluster.\n            score_date (str, optional): Date of score in ISO &amp; UTC format (e.g., 'yyyy-MM-ddTHH:mm:ss:SSSz'). Empty for current date.\n            external_id (str, optional): External unique identifier.\n\n        Returns:\n            bool: True if execution was successful, False otherwise.\n        \"\"\"\n        self.first_step.num_iterations = num_iteratons\n        if external_id != \"\":\n            self.enola_sender.external_id = external_id\n\n        self.close_step_others(\n            step=self.first_step,\n            successfull=successfull,\n            others_cost=0,\n            step_id=\"AGENT\",\n            message_output=message_output,\n        )\n        self.first_step.set_score(\n            value=score_value, group=score_group, cluster=score_cluster, date=score_date\n        )\n\n        # Register in server\n        print(f\"{self.name}: sending to server... \")\n        tracking_model = TrackingModel(\n            enola_id_prev=self.enola_id_prev,\n            enola_sender=self.enola_sender,\n            isTest=self.is_test,\n            step_list=self.step_list,\n            steps=self.steps,\n        )\n\n        enola_result = create_tracking(\n            tracking_model=tracking_model,\n            connection=self.connection,\n            raise_error_if_fail=True,\n        )\n        # Show results\n        if enola_result.successfull:\n            # Obtain Enola ID and evaluation URLs\n            self.enola_id = enola_result.enola_id\n            self.agent_deploy_id = enola_result.agent_deploy_id\n            self.url_evaluation_post = enola_result.url_evaluation_post\n            self.url_evaluation_def_get = enola_result.url_evaluation_def_get\n\n            print(f\"{self.name}: finish OK! \")\n\n            return True\n        else:\n            print(f\"{self.name}: finish with error: {enola_result.message}\")\n            self.tracking_status = enola_result.message\n\n            return False\n\n    ########################################################################################\n    ###############    S T E P   I N F O     ###############################################\n    ########################################################################################\n\n    def new_step(self, name: str, message_input: str = \"\") -&gt; Step:\n        \"\"\"\n        Starts a new step.\n\n        Args:\n            name (str): Name of this step.\n            message_input (str, optional): Message received from user or to explain the execution.\n\n        Returns:\n            Step: The newly created step object.\n        \"\"\"\n        self.steps += 1\n        return Step(name=name, message_input=message_input)\n\n    def close_step_token(\n        self,\n        step: Step,\n        successfull: bool,\n        message_output: str = \"\",\n        token_input_num: int = 0,\n        token_output_num: int = 0,\n        token_total_num: int = 0,\n        token_input_cost: float = 0,\n        token_output_cost: float = 0,\n        token_total_cost: float = 0,\n        enola_id: str = \"\",\n        agent_deploy_id: str = \"\",\n        step_id: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Closes a step with token information.\n\n        Args:\n            step (Step): The step to close.\n            successfull (bool): True if the step was successful, False otherwise.\n            message_output (str, optional): Message to user or to explain the execution results.\n            token_input_num (int, optional): Number of input tokens.\n            token_output_num (int, optional): Number of output tokens.\n            token_total_num (int, optional): Total number of tokens.\n            token_input_cost (float, optional): Cost of input tokens.\n            token_output_cost (float, optional): Cost of output tokens.\n            token_total_cost (float, optional): Total cost of tokens.\n            enola_id (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n            agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n            step_id (str, optional): ID of this step, you can use it to link with external calls.\n        \"\"\"\n        step.enola_id = enola_id\n        step.agent_deploy_id = agent_deploy_id\n        step.step_id = step_id\n        step.message_output = message_output\n        step.step_type = StepType.TOKEN\n        step.token.token_input = token_input_num\n        step.token.token_output = token_output_num\n        step.token.token_total = token_total_num\n        step.cost.token_input = token_input_cost\n        step.cost.token_output = token_output_cost\n        step.cost.token_total = token_total_cost\n\n        step.date_end = self.hf.get_date_for_api()\n        step.duration_in_ms = self.hf.get_dif_ms(\n            step.date_start, step.date_end\n        )\n        step.successfull = successfull\n\n        self.step_list.append(step)\n\n    def close_step_video(\n        self,\n        step: Step,\n        successfull: bool,\n        message_output: str = \"\",\n        video_num: int = 0,\n        video_sec: int = 0,\n        video_size: int = 0,\n        video_cost: float = 0,\n        enola_id_prev: str = \"\",\n        agent_deploy_id: str = \"\",\n        step_id: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Closes a step with video information.\n\n        Args:\n            step (Step): The step to close.\n            successfull (bool): True if the step was successful, False otherwise.\n            message_output (str, optional): Message to user or to explain the execution results.\n            video_num (int, optional): Number of videos.\n            video_sec (int, optional): Number of video seconds.\n            video_size (int, optional): Video size.\n            video_cost (float, optional): Video cost.\n            enola_id_prev (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n            agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n            step_id (str, optional): ID of this step, you can use it to link with external calls.\n        \"\"\"\n        step.enola_id_prev = enola_id_prev\n        step.agent_deploy_id = agent_deploy_id\n        step.step_id = step_id\n        step.message_output = message_output\n        step.step_type = StepType.VIDEO\n        step.video.num_videos = video_num\n        step.video.sec_videos = video_sec\n        step.video.size_videos = video_size\n        step.cost.videos = video_cost\n        step.date_end = self.hf.get_date_for_api()\n        step.duration_in_ms = self.hf.get_dif_ms(step.date_start, step.date_end)\n        step.successfull = successfull\n\n        self.step_list.append(step)\n\n    def close_step_audio(\n        self,\n        step: Step,\n        successfull: bool,\n        message_output: str = \"\",\n        audio_num: int = 0,\n        audio_sec: int = 0,\n        audio_size: int = 0,\n        audio_cost: float = 0,\n        enola_id_prev: str = \"\",\n        agent_deploy_id: str = \"\",\n        step_id: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Closes a step with audio information.\n\n        Args:\n            step (Step): The step to close.\n            successfull (bool): True if the step was successful, False otherwise.\n            message_output (str, optional): Message to user or to explain the execution results.\n            audio_num (int, optional): Number of audio clips.\n            audio_sec (int, optional): Number of audio seconds.\n            audio_size (int, optional): Audio size.\n            audio_cost (float, optional): Audio cost.\n            enola_id_prev (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n            agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n            step_id (str, optional): ID of this step, you can use it to link with external calls.\n        \"\"\"\n        step.enola_id_prev = enola_id_prev\n        step.agent_deploy_id = agent_deploy_id\n        step.step_id = step_id\n        step.message_output = message_output\n        step.step_type = StepType.AUDIO\n        step.audio.num_audio = audio_num\n        step.audio.sec_audio = audio_sec\n        step.audio.size_audio = audio_size\n        step.cost.audio = audio_cost\n        step.date_end = self.hf.get_date_for_api()\n        step.duration_in_ms = self.hf.get_dif_ms(step.date_start, step.date_end)\n        step.successfull = successfull\n\n        self.step_list.append(step)\n\n    def close_step_image(\n        self,\n        step: Step,\n        successfull: bool,\n        message_output: str = \"\",\n        image_num: int = 0,\n        image_size: int = 0,\n        image_cost: float = 0,\n        enola_id_prev: str = \"\",\n        agent_deploy_id: str = \"\",\n        step_id: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Closes a step with image information.\n\n        Args:\n            step (Step): The step to close.\n            successfull (bool): True if the step was successful, False otherwise.\n            message_output (str, optional): Message to user or to explain the execution results.\n            image_num (int, optional): Number of images.\n            image_size (int, optional): Image size.\n            image_cost (float, optional): Image cost.\n            enola_id_prev (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n            agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n            step_id (str, optional): ID of this step, you can use it to link with external calls.\n        \"\"\"\n        step.enola_id_prev = enola_id_prev\n        step.agent_deploy_id = agent_deploy_id\n        step.step_id = step_id\n        step.message_output = message_output\n        step.step_type = StepType.IMAGE\n        step.image.num_images = image_num\n        step.image.size_images = image_size\n        step.cost.images = image_cost\n        step.date_end = self.hf.get_date_for_api()\n        step.duration_in_ms = self.hf.get_dif_ms(step.date_start, step.date_end)\n        step.successfull = successfull\n\n        self.step_list.append(step)\n\n    def close_step_doc(\n        self,\n        step: Step,\n        successfull: bool,\n        message_output: str = \"\",\n        doc_num: int = 0,\n        doc_pages: int = 0,\n        doc_size: int = 0,\n        doc_char: int = 0,\n        doc_cost: float = 0,\n        enola_id_prev: str = \"\",\n        agent_deploy_id: str = \"\",\n        step_id: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Closes a step with document information.\n\n        Args:\n            step (Step): The step to close.\n            successfull (bool): True if the step was successful, False otherwise.\n            message_output (str, optional): Message to user or to explain the execution results.\n            doc_num (int, optional): Number of documents.\n            doc_pages (int, optional): Number of pages in the document.\n            doc_size (int, optional): Document size.\n            doc_char (int, optional): Number of characters in the document.\n            doc_cost (float, optional): Document cost.\n            enola_id_prev (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n            agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n            step_id (str, optional): ID of this step, you can use it to link with external calls.\n        \"\"\"\n        step.enola_id_prev = enola_id_prev\n        step.agent_deploy_id = agent_deploy_id\n        step.step_id = step_id\n        step.message_output = message_output\n        step.step_type = StepType.DOCUMENT\n        step.doc.num_docs = doc_num\n        step.doc.num_pages = doc_pages\n        step.doc.size_docs = doc_size\n        step.doc.num_char = doc_char\n        step.cost.docs = doc_cost\n        step.date_end = self.hf.get_date_for_api()\n        step.duration_in_ms = self.hf.get_dif_ms(step.date_start, step.date_end)\n        step.successfull = successfull\n\n        self.step_list.append(step)\n\n    def close_step_others(\n        self,\n        step: Step,\n        successfull: bool,\n        message_output: str = \"\",\n        others_cost: float = 0,\n        enola_id_prev: str = \"\",\n        agent_deploy_id: str = \"\",\n        step_id: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Closes a step with other types of information.\n\n        Args:\n            step (Step): The step to close.\n            successfull (bool): True if the step was successful, False otherwise.\n            message_output (str, optional): Message to user or to explain the execution results.\n            others_cost (float, optional): Cost of other types.\n            enola_id_prev (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n            agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n            step_id (str, optional): ID of this step, you can use it to link with external calls.\n        \"\"\"\n        step.enola_id_prev = enola_id_prev\n        step.agent_deploy_id = agent_deploy_id\n        step.step_id = step_id\n        step.message_output = message_output\n        step.step_type = StepType.OTHER\n        step.cost.others = others_cost\n        step.date_end = self.hf.get_date_for_api()\n        step.duration_in_ms = self.hf.get_dif_ms(step.date_start, step.date_end)\n        step.successfull = successfull\n\n        self.step_list.append(step)\n\n    def close_step_score(\n        self,\n        step: Step,\n        successfull: bool,\n        message_output: str = \"\",\n        others_cost: float = 0,\n        enola_id_prev: str = \"\",\n        agent_deploy_id: str = \"\",\n        step_id: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Closes a step for score information.\n\n        Args:\n            step (Step): The step to close.\n            successfull (bool): True if the step was successful, False otherwise.\n            message_output (str, optional): Message to user or to explain the execution results.\n            others_cost (float, optional): Cost of other types.\n            enola_id_prev (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n            agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n            step_id (str, optional): ID of this step, you can use it to link with external calls.\n        \"\"\"\n        step.enola_id_prev = enola_id_prev\n        step.agent_deploy_id = agent_deploy_id\n        step.step_id = step_id\n        step.message_output = message_output\n        step.step_type = StepType.SCORE\n        step.cost.others = others_cost\n        step.successfull = successfull\n\n        self.step_list.append(step)\n\n    def __str__(self) -&gt; str:\n        return f\"Agent/Model: {self.name}, Steps: {self.steps}\"\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.__init__","title":"<code>__init__(token, name, app_id=None, user_id=None, session_id=None, channel_id=None, ip=None, external_id=None, is_test=False, message_input='', enola_id_prev='', app_name='', user_name='', session_name='', channel_name='', client_id='', product_id='')</code>","text":"<p>Initializes a new <code>Tracking</code> instance to start tracking an execution.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>JWT token used to identify the agent (request from Admin App).</p> required <code>name</code> <code>str</code> <p>Name of this execution.</p> required <code>app_id</code> <code>str</code> <p>ID of the app that is calling.</p> <code>None</code> <code>user_id</code> <code>str</code> <p>External user ID.</p> <code>None</code> <code>session_id</code> <code>str</code> <p>ID of the user or application's session.</p> <code>None</code> <code>channel_id</code> <code>str</code> <p>Communication channel (e.g., 'web', 'chat', 'whatsapp').</p> <code>None</code> <code>ip</code> <code>str</code> <p>IP address of the user or application.</p> <code>None</code> <code>external_id</code> <code>str</code> <p>External unique record identifier.</p> <code>None</code> <code>is_test</code> <code>bool</code> <p>True if this call is for testing purposes.</p> <code>False</code> <code>message_input</code> <code>str</code> <p>Message received from the user or to explain the execution.</p> <code>''</code> <code>enola_id_prev</code> <code>str</code> <p>ID of the previous call to link agent sequences.</p> <code>''</code> <code>app_name</code> <code>str</code> <p>Name of the app.</p> <code>''</code> <code>user_name</code> <code>str</code> <p>Name of the user.</p> <code>''</code> <code>session_name</code> <code>str</code> <p>Name of the session.</p> <code>''</code> <code>channel_name</code> <code>str</code> <p>Name of the channel.</p> <code>''</code> <code>client_id</code> <code>str</code> <p>Client ID.</p> <code>''</code> <code>product_id</code> <code>str</code> <p>Product ID.</p> <code>''</code> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def __init__(\n    self,\n    token: str,\n    name: str,\n    app_id: Optional[str] = None,\n    user_id: Optional[str] = None,\n    session_id: Optional[str] = None,\n    channel_id: Optional[str] = None,\n    ip: Optional[str] = None,\n    external_id: Optional[str] = None,\n    is_test: bool = False,\n    message_input: str = \"\",\n    enola_id_prev: str = \"\",\n    app_name: str = \"\",\n    user_name: str = \"\",\n    session_name: str = \"\",\n    channel_name: str = \"\",\n    client_id: str = \"\",\n    product_id: str = \"\",\n):\n    \"\"\"\n    Initializes a new `Tracking` instance to start tracking an execution.\n\n    Args:\n        token (str): JWT token used to identify the agent (request from Admin App).\n        name (str): Name of this execution.\n        app_id (str, optional): ID of the app that is calling.\n        user_id (str, optional): External user ID.\n        session_id (str, optional): ID of the user or application's session.\n        channel_id (str, optional): Communication channel (e.g., 'web', 'chat', 'whatsapp').\n        ip (str, optional): IP address of the user or application.\n        external_id (str, optional): External unique record identifier.\n        is_test (bool, optional): True if this call is for testing purposes.\n        message_input (str, optional): Message received from the user or to explain the execution.\n        enola_id_prev (str, optional): ID of the previous call to link agent sequences.\n        app_name (str, optional): Name of the app.\n        user_name (str, optional): Name of the user.\n        session_name (str, optional): Name of the session.\n        channel_name (str, optional): Name of the channel.\n        client_id (str, optional): Client ID.\n        product_id (str, optional): Product ID.\n    \"\"\"\n    self.name = name\n    self.enola_id_prev = enola_id_prev\n    self.enola_id = \"\"  # Obtained after execution\n    self.agent_deploy_id = \"\"\n    self.message_input = message_input\n    self.message_output = \"\"\n    self.num_iteratons = 0\n    self.hf = HuemulFunctions()\n    self.url_evaluation_post = None\n    self.url_evaluation_def_get = None\n\n    # This execution information\n    self.tracking_status = \"\"\n    # Connection data\n\n    # Decode JWT token\n    self.token_info = TokenInfo(token=token)\n\n    if not self.token_info.is_service_account:\n        raise Exception(\n            \"This token is not a service account. Only service accounts can execute tracking\"\n        )\n\n    if not self.token_info.agent_deploy_id:\n        raise Exception(\"agentDeployId is empty.\")\n\n    if not self.token_info.service_account_can_tracking:\n        raise Exception(\"This service account can't execute tracking\")\n\n    self.agent_deploy_id = self.token_info.agent_deploy_id\n    self.connection = Connect(\n        AuthModel(\n            jwt_token=token,\n            url_service=self.token_info.service_account_url,\n            org_id=self.token_info.org_id,\n        )\n    )\n\n    # User information\n    self.enola_sender = EnolaSenderModel(\n        app_id=app_id,\n        batch_id=None,\n        app_name=app_name,\n        user_id=user_id,\n        user_name=user_name,\n        session_id=session_id,\n        session_name=session_name,\n        channel_id=channel_id,\n        channel_name=channel_name,\n        ip=ip,\n        external_id=external_id,\n        client_id=client_id,\n        product_id=product_id,\n    )\n\n    # If is empty or not exist assign false\n    self.is_test = is_test\n\n    # Save steps and information\n    self.step_list: List[Step] = []\n    self.steps = 0\n    self.first_step = self.new_step(self.name, message_input=self.message_input)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_custom_info","title":"<code>add_custom_info(key, value)</code>","text":"<p>Adds custom information to tracking.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the custom information.</p> required <code>value</code> <code>Any</code> <p>The value associated with the key.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_custom_info(self, key: str, value: Any) -&gt; None:\n    \"\"\"\n    Adds custom information to tracking.\n\n    Args:\n        key (str): The key for the custom information.\n        value (Any): The value associated with the key.\n    \"\"\"\n    self.first_step.info_list.append(Info(key, value))\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_data_received","title":"<code>add_data_received(name, data, type)</code>","text":"<p>Adds data received from the user.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data.</p> required <code>data</code> <code>Any</code> <p>The data content.</p> required <code>type</code> <code>DataType</code> <p>The type of data received.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_data_received(self, name: str, data: Any, type: DataType) -&gt; None:\n    \"\"\"\n    Adds data received from the user.\n\n    Args:\n        name (str): The name of the data.\n        data (Any): The data content.\n        type (DataType): The type of data received.\n    \"\"\"\n    self.first_step.agent_data_list.append(\n        DataListModel(\n            value=data, name=name, data_type=type, kind=KindType.RECEIVER\n        )\n    )\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_data_send","title":"<code>add_data_send(name, data, type)</code>","text":"<p>Adds data to send to the user.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data.</p> required <code>data</code> <code>Any</code> <p>The data content.</p> required <code>type</code> <code>DataType</code> <p>The type of data being sent.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_data_send(self, name: str, data: Any, type: DataType) -&gt; None:\n    \"\"\"\n    Adds data to send to the user.\n\n    Args:\n        name (str): The name of the data.\n        data (Any): The data content.\n        type (DataType): The type of data being sent.\n    \"\"\"\n    self.first_step.agent_data_list.append(\n        DataListModel(value=data, name=name, data_type=type, kind=KindType.SENDER)\n    )\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_error","title":"<code>add_error(id, message, kind)</code>","text":"<p>Registers an error to tracking.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The error identifier.</p> required <code>message</code> <code>str</code> <p>The error message.</p> required <code>kind</code> <code>ErrOrWarnKind</code> <p>The kind of error.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_error(self, id: str, message: str, kind: ErrOrWarnKind) -&gt; None:\n    \"\"\"\n    Registers an error to tracking.\n\n    Args:\n        id (str): The error identifier.\n        message (str): The error message.\n        kind (ErrOrWarnKind): The kind of error.\n    \"\"\"\n    self.first_step.add_error(id=id, message=message, kind=kind)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_extra_info","title":"<code>add_extra_info(key, value)</code>","text":"<p>Adds extra information to tracking, this can be used to test or debug.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the extra information.</p> required <code>value</code> <code>Any</code> <p>The value associated with the key.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_extra_info(self, key: str, value: Any) -&gt; None:\n    \"\"\"\n    Adds extra information to tracking, this can be used to test or debug.\n\n    Args:\n        key (str): The key for the extra information.\n        value (Any): The value associated with the key.\n    \"\"\"\n    self.first_step.add_extra_info(key=key, value=value)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_file_link","title":"<code>add_file_link(name, url, type, size_kb)</code>","text":"<p>Adds a file link to tracking.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the file.</p> required <code>url</code> <code>str</code> <p>The URL of the file.</p> required <code>type</code> <code>str</code> <p>The type of the file.</p> required <code>size_kb</code> <code>int</code> <p>The size of the file in kilobytes.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_file_link(\n    self, name: str, url: str, type: str, size_kb: int\n) -&gt; None:\n    \"\"\"\n    Adds a file link to tracking.\n\n    Args:\n        name (str): The name of the file.\n        url (str): The URL of the file.\n        type (str): The type of the file.\n        size_kb (int): The size of the file in kilobytes.\n    \"\"\"\n    self.first_step.add_file_link(\n        name=name, url=url, type=type, size_kb=size_kb\n    )\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_tag","title":"<code>add_tag(key, value)</code>","text":"<p>Adds a tag to tracking, this tag is used to search in Enola App.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The tag key.</p> required <code>value</code> <code>Any</code> <p>The tag value.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_tag(self, key: str, value: Any) -&gt; None:\n    \"\"\"\n    Adds a tag to tracking, this tag is used to search in Enola App.\n\n    Args:\n        key (str): The tag key.\n        value (Any): The tag value.\n    \"\"\"\n    self.first_step.add_tag(key=key, value=value)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_warning","title":"<code>add_warning(id, message, kind)</code>","text":"<p>Registers a warning to tracking.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The warning identifier.</p> required <code>message</code> <code>str</code> <p>The warning message.</p> required <code>kind</code> <code>ErrOrWarnKind</code> <p>The kind of warning.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_warning(self, id: str, message: str, kind: ErrOrWarnKind) -&gt; None:\n    \"\"\"\n    Registers a warning to tracking.\n\n    Args:\n        id (str): The warning identifier.\n        message (str): The warning message.\n        kind (ErrOrWarnKind): The kind of warning.\n    \"\"\"\n    self.first_step.add_warning(id=id, message=message, kind=kind)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.close_step_audio","title":"<code>close_step_audio(step, successfull, message_output='', audio_num=0, audio_sec=0, audio_size=0, audio_cost=0, enola_id_prev='', agent_deploy_id='', step_id='')</code>","text":"<p>Closes a step with audio information.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Step</code> <p>The step to close.</p> required <code>successfull</code> <code>bool</code> <p>True if the step was successful, False otherwise.</p> required <code>message_output</code> <code>str</code> <p>Message to user or to explain the execution results.</p> <code>''</code> <code>audio_num</code> <code>int</code> <p>Number of audio clips.</p> <code>0</code> <code>audio_sec</code> <code>int</code> <p>Number of audio seconds.</p> <code>0</code> <code>audio_size</code> <code>int</code> <p>Audio size.</p> <code>0</code> <code>audio_cost</code> <code>float</code> <p>Audio cost.</p> <code>0</code> <code>enola_id_prev</code> <code>str</code> <p>If this step was a call to another Enola agent, this is the ID of that agent.</p> <code>''</code> <code>agent_deploy_id</code> <code>str</code> <p>Include this if you want to link this step to another agent of another company.</p> <code>''</code> <code>step_id</code> <code>str</code> <p>ID of this step, you can use it to link with external calls.</p> <code>''</code> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def close_step_audio(\n    self,\n    step: Step,\n    successfull: bool,\n    message_output: str = \"\",\n    audio_num: int = 0,\n    audio_sec: int = 0,\n    audio_size: int = 0,\n    audio_cost: float = 0,\n    enola_id_prev: str = \"\",\n    agent_deploy_id: str = \"\",\n    step_id: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Closes a step with audio information.\n\n    Args:\n        step (Step): The step to close.\n        successfull (bool): True if the step was successful, False otherwise.\n        message_output (str, optional): Message to user or to explain the execution results.\n        audio_num (int, optional): Number of audio clips.\n        audio_sec (int, optional): Number of audio seconds.\n        audio_size (int, optional): Audio size.\n        audio_cost (float, optional): Audio cost.\n        enola_id_prev (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n        agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n        step_id (str, optional): ID of this step, you can use it to link with external calls.\n    \"\"\"\n    step.enola_id_prev = enola_id_prev\n    step.agent_deploy_id = agent_deploy_id\n    step.step_id = step_id\n    step.message_output = message_output\n    step.step_type = StepType.AUDIO\n    step.audio.num_audio = audio_num\n    step.audio.sec_audio = audio_sec\n    step.audio.size_audio = audio_size\n    step.cost.audio = audio_cost\n    step.date_end = self.hf.get_date_for_api()\n    step.duration_in_ms = self.hf.get_dif_ms(step.date_start, step.date_end)\n    step.successfull = successfull\n\n    self.step_list.append(step)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.close_step_doc","title":"<code>close_step_doc(step, successfull, message_output='', doc_num=0, doc_pages=0, doc_size=0, doc_char=0, doc_cost=0, enola_id_prev='', agent_deploy_id='', step_id='')</code>","text":"<p>Closes a step with document information.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Step</code> <p>The step to close.</p> required <code>successfull</code> <code>bool</code> <p>True if the step was successful, False otherwise.</p> required <code>message_output</code> <code>str</code> <p>Message to user or to explain the execution results.</p> <code>''</code> <code>doc_num</code> <code>int</code> <p>Number of documents.</p> <code>0</code> <code>doc_pages</code> <code>int</code> <p>Number of pages in the document.</p> <code>0</code> <code>doc_size</code> <code>int</code> <p>Document size.</p> <code>0</code> <code>doc_char</code> <code>int</code> <p>Number of characters in the document.</p> <code>0</code> <code>doc_cost</code> <code>float</code> <p>Document cost.</p> <code>0</code> <code>enola_id_prev</code> <code>str</code> <p>If this step was a call to another Enola agent, this is the ID of that agent.</p> <code>''</code> <code>agent_deploy_id</code> <code>str</code> <p>Include this if you want to link this step to another agent of another company.</p> <code>''</code> <code>step_id</code> <code>str</code> <p>ID of this step, you can use it to link with external calls.</p> <code>''</code> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def close_step_doc(\n    self,\n    step: Step,\n    successfull: bool,\n    message_output: str = \"\",\n    doc_num: int = 0,\n    doc_pages: int = 0,\n    doc_size: int = 0,\n    doc_char: int = 0,\n    doc_cost: float = 0,\n    enola_id_prev: str = \"\",\n    agent_deploy_id: str = \"\",\n    step_id: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Closes a step with document information.\n\n    Args:\n        step (Step): The step to close.\n        successfull (bool): True if the step was successful, False otherwise.\n        message_output (str, optional): Message to user or to explain the execution results.\n        doc_num (int, optional): Number of documents.\n        doc_pages (int, optional): Number of pages in the document.\n        doc_size (int, optional): Document size.\n        doc_char (int, optional): Number of characters in the document.\n        doc_cost (float, optional): Document cost.\n        enola_id_prev (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n        agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n        step_id (str, optional): ID of this step, you can use it to link with external calls.\n    \"\"\"\n    step.enola_id_prev = enola_id_prev\n    step.agent_deploy_id = agent_deploy_id\n    step.step_id = step_id\n    step.message_output = message_output\n    step.step_type = StepType.DOCUMENT\n    step.doc.num_docs = doc_num\n    step.doc.num_pages = doc_pages\n    step.doc.size_docs = doc_size\n    step.doc.num_char = doc_char\n    step.cost.docs = doc_cost\n    step.date_end = self.hf.get_date_for_api()\n    step.duration_in_ms = self.hf.get_dif_ms(step.date_start, step.date_end)\n    step.successfull = successfull\n\n    self.step_list.append(step)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.close_step_image","title":"<code>close_step_image(step, successfull, message_output='', image_num=0, image_size=0, image_cost=0, enola_id_prev='', agent_deploy_id='', step_id='')</code>","text":"<p>Closes a step with image information.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Step</code> <p>The step to close.</p> required <code>successfull</code> <code>bool</code> <p>True if the step was successful, False otherwise.</p> required <code>message_output</code> <code>str</code> <p>Message to user or to explain the execution results.</p> <code>''</code> <code>image_num</code> <code>int</code> <p>Number of images.</p> <code>0</code> <code>image_size</code> <code>int</code> <p>Image size.</p> <code>0</code> <code>image_cost</code> <code>float</code> <p>Image cost.</p> <code>0</code> <code>enola_id_prev</code> <code>str</code> <p>If this step was a call to another Enola agent, this is the ID of that agent.</p> <code>''</code> <code>agent_deploy_id</code> <code>str</code> <p>Include this if you want to link this step to another agent of another company.</p> <code>''</code> <code>step_id</code> <code>str</code> <p>ID of this step, you can use it to link with external calls.</p> <code>''</code> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def close_step_image(\n    self,\n    step: Step,\n    successfull: bool,\n    message_output: str = \"\",\n    image_num: int = 0,\n    image_size: int = 0,\n    image_cost: float = 0,\n    enola_id_prev: str = \"\",\n    agent_deploy_id: str = \"\",\n    step_id: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Closes a step with image information.\n\n    Args:\n        step (Step): The step to close.\n        successfull (bool): True if the step was successful, False otherwise.\n        message_output (str, optional): Message to user or to explain the execution results.\n        image_num (int, optional): Number of images.\n        image_size (int, optional): Image size.\n        image_cost (float, optional): Image cost.\n        enola_id_prev (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n        agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n        step_id (str, optional): ID of this step, you can use it to link with external calls.\n    \"\"\"\n    step.enola_id_prev = enola_id_prev\n    step.agent_deploy_id = agent_deploy_id\n    step.step_id = step_id\n    step.message_output = message_output\n    step.step_type = StepType.IMAGE\n    step.image.num_images = image_num\n    step.image.size_images = image_size\n    step.cost.images = image_cost\n    step.date_end = self.hf.get_date_for_api()\n    step.duration_in_ms = self.hf.get_dif_ms(step.date_start, step.date_end)\n    step.successfull = successfull\n\n    self.step_list.append(step)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.close_step_others","title":"<code>close_step_others(step, successfull, message_output='', others_cost=0, enola_id_prev='', agent_deploy_id='', step_id='')</code>","text":"<p>Closes a step with other types of information.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Step</code> <p>The step to close.</p> required <code>successfull</code> <code>bool</code> <p>True if the step was successful, False otherwise.</p> required <code>message_output</code> <code>str</code> <p>Message to user or to explain the execution results.</p> <code>''</code> <code>others_cost</code> <code>float</code> <p>Cost of other types.</p> <code>0</code> <code>enola_id_prev</code> <code>str</code> <p>If this step was a call to another Enola agent, this is the ID of that agent.</p> <code>''</code> <code>agent_deploy_id</code> <code>str</code> <p>Include this if you want to link this step to another agent of another company.</p> <code>''</code> <code>step_id</code> <code>str</code> <p>ID of this step, you can use it to link with external calls.</p> <code>''</code> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def close_step_others(\n    self,\n    step: Step,\n    successfull: bool,\n    message_output: str = \"\",\n    others_cost: float = 0,\n    enola_id_prev: str = \"\",\n    agent_deploy_id: str = \"\",\n    step_id: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Closes a step with other types of information.\n\n    Args:\n        step (Step): The step to close.\n        successfull (bool): True if the step was successful, False otherwise.\n        message_output (str, optional): Message to user or to explain the execution results.\n        others_cost (float, optional): Cost of other types.\n        enola_id_prev (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n        agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n        step_id (str, optional): ID of this step, you can use it to link with external calls.\n    \"\"\"\n    step.enola_id_prev = enola_id_prev\n    step.agent_deploy_id = agent_deploy_id\n    step.step_id = step_id\n    step.message_output = message_output\n    step.step_type = StepType.OTHER\n    step.cost.others = others_cost\n    step.date_end = self.hf.get_date_for_api()\n    step.duration_in_ms = self.hf.get_dif_ms(step.date_start, step.date_end)\n    step.successfull = successfull\n\n    self.step_list.append(step)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.close_step_score","title":"<code>close_step_score(step, successfull, message_output='', others_cost=0, enola_id_prev='', agent_deploy_id='', step_id='')</code>","text":"<p>Closes a step for score information.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Step</code> <p>The step to close.</p> required <code>successfull</code> <code>bool</code> <p>True if the step was successful, False otherwise.</p> required <code>message_output</code> <code>str</code> <p>Message to user or to explain the execution results.</p> <code>''</code> <code>others_cost</code> <code>float</code> <p>Cost of other types.</p> <code>0</code> <code>enola_id_prev</code> <code>str</code> <p>If this step was a call to another Enola agent, this is the ID of that agent.</p> <code>''</code> <code>agent_deploy_id</code> <code>str</code> <p>Include this if you want to link this step to another agent of another company.</p> <code>''</code> <code>step_id</code> <code>str</code> <p>ID of this step, you can use it to link with external calls.</p> <code>''</code> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def close_step_score(\n    self,\n    step: Step,\n    successfull: bool,\n    message_output: str = \"\",\n    others_cost: float = 0,\n    enola_id_prev: str = \"\",\n    agent_deploy_id: str = \"\",\n    step_id: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Closes a step for score information.\n\n    Args:\n        step (Step): The step to close.\n        successfull (bool): True if the step was successful, False otherwise.\n        message_output (str, optional): Message to user or to explain the execution results.\n        others_cost (float, optional): Cost of other types.\n        enola_id_prev (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n        agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n        step_id (str, optional): ID of this step, you can use it to link with external calls.\n    \"\"\"\n    step.enola_id_prev = enola_id_prev\n    step.agent_deploy_id = agent_deploy_id\n    step.step_id = step_id\n    step.message_output = message_output\n    step.step_type = StepType.SCORE\n    step.cost.others = others_cost\n    step.successfull = successfull\n\n    self.step_list.append(step)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.close_step_token","title":"<code>close_step_token(step, successfull, message_output='', token_input_num=0, token_output_num=0, token_total_num=0, token_input_cost=0, token_output_cost=0, token_total_cost=0, enola_id='', agent_deploy_id='', step_id='')</code>","text":"<p>Closes a step with token information.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Step</code> <p>The step to close.</p> required <code>successfull</code> <code>bool</code> <p>True if the step was successful, False otherwise.</p> required <code>message_output</code> <code>str</code> <p>Message to user or to explain the execution results.</p> <code>''</code> <code>token_input_num</code> <code>int</code> <p>Number of input tokens.</p> <code>0</code> <code>token_output_num</code> <code>int</code> <p>Number of output tokens.</p> <code>0</code> <code>token_total_num</code> <code>int</code> <p>Total number of tokens.</p> <code>0</code> <code>token_input_cost</code> <code>float</code> <p>Cost of input tokens.</p> <code>0</code> <code>token_output_cost</code> <code>float</code> <p>Cost of output tokens.</p> <code>0</code> <code>token_total_cost</code> <code>float</code> <p>Total cost of tokens.</p> <code>0</code> <code>enola_id</code> <code>str</code> <p>If this step was a call to another Enola agent, this is the ID of that agent.</p> <code>''</code> <code>agent_deploy_id</code> <code>str</code> <p>Include this if you want to link this step to another agent of another company.</p> <code>''</code> <code>step_id</code> <code>str</code> <p>ID of this step, you can use it to link with external calls.</p> <code>''</code> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def close_step_token(\n    self,\n    step: Step,\n    successfull: bool,\n    message_output: str = \"\",\n    token_input_num: int = 0,\n    token_output_num: int = 0,\n    token_total_num: int = 0,\n    token_input_cost: float = 0,\n    token_output_cost: float = 0,\n    token_total_cost: float = 0,\n    enola_id: str = \"\",\n    agent_deploy_id: str = \"\",\n    step_id: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Closes a step with token information.\n\n    Args:\n        step (Step): The step to close.\n        successfull (bool): True if the step was successful, False otherwise.\n        message_output (str, optional): Message to user or to explain the execution results.\n        token_input_num (int, optional): Number of input tokens.\n        token_output_num (int, optional): Number of output tokens.\n        token_total_num (int, optional): Total number of tokens.\n        token_input_cost (float, optional): Cost of input tokens.\n        token_output_cost (float, optional): Cost of output tokens.\n        token_total_cost (float, optional): Total cost of tokens.\n        enola_id (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n        agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n        step_id (str, optional): ID of this step, you can use it to link with external calls.\n    \"\"\"\n    step.enola_id = enola_id\n    step.agent_deploy_id = agent_deploy_id\n    step.step_id = step_id\n    step.message_output = message_output\n    step.step_type = StepType.TOKEN\n    step.token.token_input = token_input_num\n    step.token.token_output = token_output_num\n    step.token.token_total = token_total_num\n    step.cost.token_input = token_input_cost\n    step.cost.token_output = token_output_cost\n    step.cost.token_total = token_total_cost\n\n    step.date_end = self.hf.get_date_for_api()\n    step.duration_in_ms = self.hf.get_dif_ms(\n        step.date_start, step.date_end\n    )\n    step.successfull = successfull\n\n    self.step_list.append(step)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.close_step_video","title":"<code>close_step_video(step, successfull, message_output='', video_num=0, video_sec=0, video_size=0, video_cost=0, enola_id_prev='', agent_deploy_id='', step_id='')</code>","text":"<p>Closes a step with video information.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Step</code> <p>The step to close.</p> required <code>successfull</code> <code>bool</code> <p>True if the step was successful, False otherwise.</p> required <code>message_output</code> <code>str</code> <p>Message to user or to explain the execution results.</p> <code>''</code> <code>video_num</code> <code>int</code> <p>Number of videos.</p> <code>0</code> <code>video_sec</code> <code>int</code> <p>Number of video seconds.</p> <code>0</code> <code>video_size</code> <code>int</code> <p>Video size.</p> <code>0</code> <code>video_cost</code> <code>float</code> <p>Video cost.</p> <code>0</code> <code>enola_id_prev</code> <code>str</code> <p>If this step was a call to another Enola agent, this is the ID of that agent.</p> <code>''</code> <code>agent_deploy_id</code> <code>str</code> <p>Include this if you want to link this step to another agent of another company.</p> <code>''</code> <code>step_id</code> <code>str</code> <p>ID of this step, you can use it to link with external calls.</p> <code>''</code> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def close_step_video(\n    self,\n    step: Step,\n    successfull: bool,\n    message_output: str = \"\",\n    video_num: int = 0,\n    video_sec: int = 0,\n    video_size: int = 0,\n    video_cost: float = 0,\n    enola_id_prev: str = \"\",\n    agent_deploy_id: str = \"\",\n    step_id: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Closes a step with video information.\n\n    Args:\n        step (Step): The step to close.\n        successfull (bool): True if the step was successful, False otherwise.\n        message_output (str, optional): Message to user or to explain the execution results.\n        video_num (int, optional): Number of videos.\n        video_sec (int, optional): Number of video seconds.\n        video_size (int, optional): Video size.\n        video_cost (float, optional): Video cost.\n        enola_id_prev (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n        agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n        step_id (str, optional): ID of this step, you can use it to link with external calls.\n    \"\"\"\n    step.enola_id_prev = enola_id_prev\n    step.agent_deploy_id = agent_deploy_id\n    step.step_id = step_id\n    step.message_output = message_output\n    step.step_type = StepType.VIDEO\n    step.video.num_videos = video_num\n    step.video.sec_videos = video_sec\n    step.video.size_videos = video_size\n    step.cost.videos = video_cost\n    step.date_end = self.hf.get_date_for_api()\n    step.duration_in_ms = self.hf.get_dif_ms(step.date_start, step.date_end)\n    step.successfull = successfull\n\n    self.step_list.append(step)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.execute","title":"<code>execute(successfull, message_output='', num_iteratons=0, score_value=0, score_group='', score_cluster='', score_date='', external_id='')</code>","text":"<p>Registers tracking in the Enola server.</p> <p>Parameters:</p> Name Type Description Default <code>successfull</code> <code>bool</code> <p>True for your Agent execution OK, false for error in your Agent execution.</p> required <code>message_output</code> <code>str</code> <p>Message to user or to explain the execution results.</p> <code>''</code> <code>num_iteratons</code> <code>int</code> <p>Number of iterations.</p> <code>0</code> <code>score_value</code> <code>float</code> <p>Score value.</p> <code>0</code> <code>score_group</code> <code>str</code> <p>Score group.</p> <code>''</code> <code>score_cluster</code> <code>str</code> <p>Score cluster.</p> <code>''</code> <code>score_date</code> <code>str</code> <p>Date of score in ISO &amp; UTC format (e.g., 'yyyy-MM-ddTHH:mm:ss:SSSz'). Empty for current date.</p> <code>''</code> <code>external_id</code> <code>str</code> <p>External unique identifier.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if execution was successful, False otherwise.</p> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def execute(\n    self,\n    successfull: bool,\n    message_output: str = \"\",\n    num_iteratons: int = 0,\n    score_value: float = 0,\n    score_group: str = \"\",\n    score_cluster: str = \"\",\n    score_date: str = \"\",\n    external_id: str = \"\",\n) -&gt; bool:\n    \"\"\"\n    Registers tracking in the Enola server.\n\n    Args:\n        successfull (bool): True for your Agent execution OK, false for error in your Agent execution.\n        message_output (str, optional): Message to user or to explain the execution results.\n        num_iteratons (int, optional): Number of iterations.\n        score_value (float, optional): Score value.\n        score_group (str, optional): Score group.\n        score_cluster (str, optional): Score cluster.\n        score_date (str, optional): Date of score in ISO &amp; UTC format (e.g., 'yyyy-MM-ddTHH:mm:ss:SSSz'). Empty for current date.\n        external_id (str, optional): External unique identifier.\n\n    Returns:\n        bool: True if execution was successful, False otherwise.\n    \"\"\"\n    self.first_step.num_iterations = num_iteratons\n    if external_id != \"\":\n        self.enola_sender.external_id = external_id\n\n    self.close_step_others(\n        step=self.first_step,\n        successfull=successfull,\n        others_cost=0,\n        step_id=\"AGENT\",\n        message_output=message_output,\n    )\n    self.first_step.set_score(\n        value=score_value, group=score_group, cluster=score_cluster, date=score_date\n    )\n\n    # Register in server\n    print(f\"{self.name}: sending to server... \")\n    tracking_model = TrackingModel(\n        enola_id_prev=self.enola_id_prev,\n        enola_sender=self.enola_sender,\n        isTest=self.is_test,\n        step_list=self.step_list,\n        steps=self.steps,\n    )\n\n    enola_result = create_tracking(\n        tracking_model=tracking_model,\n        connection=self.connection,\n        raise_error_if_fail=True,\n    )\n    # Show results\n    if enola_result.successfull:\n        # Obtain Enola ID and evaluation URLs\n        self.enola_id = enola_result.enola_id\n        self.agent_deploy_id = enola_result.agent_deploy_id\n        self.url_evaluation_post = enola_result.url_evaluation_post\n        self.url_evaluation_def_get = enola_result.url_evaluation_def_get\n\n        print(f\"{self.name}: finish OK! \")\n\n        return True\n    else:\n        print(f\"{self.name}: finish with error: {enola_result.message}\")\n        self.tracking_status = enola_result.message\n\n        return False\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.new_step","title":"<code>new_step(name, message_input='')</code>","text":"<p>Starts a new step.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of this step.</p> required <code>message_input</code> <code>str</code> <p>Message received from user or to explain the execution.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>Step</code> <code>Step</code> <p>The newly created step object.</p> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def new_step(self, name: str, message_input: str = \"\") -&gt; Step:\n    \"\"\"\n    Starts a new step.\n\n    Args:\n        name (str): Name of this step.\n        message_input (str, optional): Message received from user or to explain the execution.\n\n    Returns:\n        Step: The newly created step object.\n    \"\"\"\n    self.steps += 1\n    return Step(name=name, message_input=message_input)\n</code></pre>"},{"location":"reference/tracking_batch/","title":"Tracking Batch","text":""},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch","title":"<code>TrackingBatch</code>","text":"<p>The <code>TrackingBatch</code> class is used to perform batch tracking execution in Enola.</p> <p>This class allows you to send batch tracking data to the Enola server, handling large dataframes by sending them in batches. It manages authentication, data preparation, and communication with the Enola API.</p> <p>Example usage:</p> <pre><code>tracking_batch = TrackingBatch(\n    token=\"your_jwt_token\",\n    name=\"BatchExecutionName\",\n    dataframe=df,\n    period=\"2021-01-01T00:00:00Z\",\n    client_id_column_name=\"client_id\",\n    product_id_column_name=\"product_id\",\n    score_value_column_name=\"score_value\",\n    score_group_column_name=\"score_group\",\n    score_cluster_column_name=\"score_cluster\",\n    app_id=\"App123\",\n    user_id=\"User456\",\n    is_test=False\n)\ntracking_batch.execute()\n</code></pre> Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>class TrackingBatch:\n    \"\"\"\n    The `TrackingBatch` class is used to perform batch tracking execution in Enola.\n\n    This class allows you to send batch tracking data to the Enola server, handling large\n    dataframes by sending them in batches. It manages authentication, data preparation,\n    and communication with the Enola API.\n\n    Example usage:\n\n    ```python\n    tracking_batch = TrackingBatch(\n        token=\"your_jwt_token\",\n        name=\"BatchExecutionName\",\n        dataframe=df,\n        period=\"2021-01-01T00:00:00Z\",\n        client_id_column_name=\"client_id\",\n        product_id_column_name=\"product_id\",\n        score_value_column_name=\"score_value\",\n        score_group_column_name=\"score_group\",\n        score_cluster_column_name=\"score_cluster\",\n        app_id=\"App123\",\n        user_id=\"User456\",\n        is_test=False\n    )\n    tracking_batch.execute()\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        token: str,\n        name: str,\n        dataframe,\n        period: str,\n        client_id_column_name: str,\n        product_id_column_name: str,\n        score_value_column_name: Optional[str] = None,\n        score_group_column_name: Optional[str] = None,\n        score_cluster_column_name: Optional[str] = None,\n        channel_id_column_name: Optional[str] = None,\n        channel_name_column_name: Optional[str] = None,\n        session_id_column_name: Optional[str] = None,\n        session_name_column_name: Optional[str] = None,\n        user_id_column_name: Optional[str] = None,\n        user_name_column_name: Optional[str] = None,\n        app_id_column_name: Optional[str] = None,\n        app_name_column_name: Optional[str] = None,\n        ip_column_name: Optional[str] = None,\n        external_id_column_name: Optional[str] = None,\n        app_id: Optional[str] = None,\n        app_name: str = \"\",\n        user_id: Optional[str] = None,\n        user_name: str = \"\",\n        session_id: Optional[str] = None,\n        session_name: str = \"\",\n        channel_id: Optional[str] = None,\n        channel_name: str = \"\",\n        ip: Optional[str] = None,\n        is_test: bool = False,\n    ):\n        \"\"\"\n        Initializes a new instance of the TrackingBatch class.\n\n        Args:\n            token (str): JWT token used to identify the agent. Request this from the Admin App.\n            name (str): Name of this execution.\n            dataframe: Pandas DataFrame containing the data to track.\n            period (str): Period of this execution in ISO format (e.g., '2021-01-01T00:00:00Z').\n            client_id_column_name (str): Name of the column with client ID.\n            product_id_column_name (str): Name of the column with product ID.\n            score_value_column_name (str, optional): Name of the column with score value.\n            score_group_column_name (str, optional): Name of the column with score group.\n            score_cluster_column_name (str, optional): Name of the column with score cluster.\n            channel_id_column_name (str, optional): Name of the column with channel ID.\n            channel_name_column_name (str, optional): Name of the column with channel name.\n            session_id_column_name (str, optional): Name of the column with session ID.\n            session_name_column_name (str, optional): Name of the column with session name.\n            user_id_column_name (str, optional): Name of the column with user ID.\n            user_name_column_name (str, optional): Name of the column with user name.\n            app_id_column_name (str, optional): Name of the column with app ID.\n            app_name_column_name (str, optional): Name of the column with app name.\n            ip_column_name (str, optional): Name of the column with IP address.\n            external_id_column_name (str, optional): Name of the column with external ID.\n            app_id (str, optional): ID of the app making the call.\n            app_name (str, optional): Name of the app making the call.\n            user_id (str, optional): ID of the external user.\n            user_name (str, optional): Name of the external user.\n            session_id (str, optional): ID of the user or application session.\n            session_name (str, optional): Name of the session.\n            channel_id (str, optional): ID of the communication channel (e.g., 'web', 'chat', 'whatsapp').\n            channel_name (str, optional): Name of the communication channel.\n            ip (str, optional): IP address of the user or application.\n            is_test (bool, optional): True if this call is for testing purposes.\n        \"\"\"\n        self.name = name\n        self.hf = HuemulFunctions()\n        self.dataframe = dataframe\n        self.client_id_column_name = client_id_column_name\n        self.product_id_column_name = product_id_column_name\n        self.score_value_column_name = score_value_column_name\n        self.score_group_column_name = score_group_column_name\n        self.score_cluster_column_name = score_cluster_column_name\n        self.channel_id_column_name = channel_id_column_name\n        self.channel_name_column_name = channel_name_column_name\n        self.session_id_column_name = session_id_column_name\n        self.session_name_column_name = session_name_column_name\n        self.user_id_column_name = user_id_column_name\n        self.user_name_column_name = user_name_column_name\n        self.app_id_column_name = app_id_column_name\n        self.app_name_column_name = app_name_column_name\n        self.ip_column_name = ip_column_name\n        self.external_id_column_name = external_id_column_name\n        self.period = period\n\n        if dataframe is None:\n            raise Exception(\"DataFrame is empty\")\n        if len(dataframe) == 0:\n            raise Exception(\"DataFrame is empty (length is 0)\")\n        if score_value_column_name is None and score_group_column_name is None and score_cluster_column_name is None:\n            raise Exception(\n                \"At least one of 'score_value_column_name', 'score_group_column_name', or 'score_cluster_column_name' must be provided\"\n            )\n        if period is None or period == \"\":\n            raise Exception(\"Period is empty\")\n\n        # Decode JWT token\n        self.token_info = TokenInfo(token=token)\n\n        if not self.token_info.is_service_account:\n            raise Exception(\n                \"This token is not a service account. Only service accounts can execute tracking\"\n            )\n\n        if not self.token_info.agent_deploy_id:\n            raise Exception(\"agentDeployId is empty.\")\n\n        if not self.token_info.service_account_can_tracking:\n            raise Exception(\"This service account can't execute tracking\")\n\n        self.agent_deploy_id = self.token_info.agent_deploy_id\n        self.connection = Connect(\n            AuthModel(\n                jwt_token=token,\n                url_service=self.token_info.service_account_url_backend,\n                org_id=self.token_info.org_id,\n            )\n        )\n\n        # User information\n        self.enola_sender = EnolaSenderModel(\n            app_id=app_id,\n            app_name=app_name,\n            user_id=user_id,\n            user_name=user_name,\n            session_id=session_id,\n            session_name=session_name,\n            channel_id=channel_id,\n            channel_name=channel_name,\n            ip=ip,\n            external_id=\"\",\n            batch_id=\"\",\n            client_id=\"\",\n            product_id=\"\",\n        )\n\n        # If is empty or not exist assign false\n        self.is_test = is_test\n\n        # Save steps and information\n        self.batch_id = \"\"\n\n    ########################################################################################\n    ###############    A G E N T   M E T H O D S     #######################################\n    ########################################################################################\n\n    def add_data_received(self, name: str, data, type: DataType) -&gt; None:\n        \"\"\"\n        Adds data received from the user.\n\n        Args:\n            name (str): The name of the data.\n            data: The data content.\n            type (DataType): The type of data received.\n        \"\"\"\n        self.first_step.agent_data_list.append(\n            DataListModel(value=data, name=name, data_type=type, kind=KindType.RECEIVER)\n        )\n\n    def add_data_send(self, name: str, data, type: DataType) -&gt; None:\n        \"\"\"\n        Adds data to send to the user.\n\n        Args:\n            name (str): The name of the data.\n            data: The data content.\n            type (DataType): The type of data being sent.\n        \"\"\"\n        self.first_step.agent_data_list.append(\n            DataListModel(value=data, name=name, data_type=type, kind=KindType.SENDER)\n        )\n\n    def add_custom_info(self, key: str, value) -&gt; None:\n        \"\"\"\n        Adds custom information to tracking.\n\n        Args:\n            key (str): The key for the custom information.\n            value: The value associated with the key.\n        \"\"\"\n        self.first_step.info_list.append(Info(key, value))\n\n    def add_tag(self, key: str, value) -&gt; None:\n        \"\"\"\n        Adds a tag to tracking, this tag is used to search in Enola App.\n\n        Args:\n            key (str): The tag key.\n            value: The tag value.\n        \"\"\"\n        self.first_step.add_tag(key=key, value=value)\n\n    def add_extra_info(self, key: str, value) -&gt; None:\n        \"\"\"\n        Adds extra information to tracking, this can be used to test or debug.\n\n        Args:\n            key (str): The key for the extra information.\n            value: The value associated with the key.\n        \"\"\"\n        self.first_step.add_extra_info(key=key, value=value)\n\n    def add_error(self, id: str, message: str, kind: ErrOrWarnKind) -&gt; None:\n        \"\"\"\n        Registers an error to tracking.\n\n        Args:\n            id (str): The error identifier.\n            message (str): The error message.\n            kind (ErrOrWarnKind): The kind of error.\n        \"\"\"\n        self.first_step.add_error(id=id, message=message, kind=kind)\n\n    def add_warning(self, id: str, message: str, kind: ErrOrWarnKind) -&gt; None:\n        \"\"\"\n        Registers a warning to tracking.\n\n        Args:\n            id (str): The warning identifier.\n            message (str): The warning message.\n            kind (ErrOrWarnKind): The kind of warning.\n        \"\"\"\n        self.first_step.add_warning(id=id, message=message, kind=kind)\n\n    def execute(self, batch_size: int = 200) -&gt; List[TrackingResponseModel]:\n        \"\"\"\n        Registers the tracking batch in the Enola server.\n\n        Args:\n            batch_size (int, optional): Number of records to send per batch. Defaults to 200.\n\n        Returns:\n            List[TrackingResponseModel]: List of tracking response models returned by the server.\n        \"\"\"\n\n        # Create batch\n        if self.batch_id == \"\":\n            print(f\"{self.name}: sending to server, create Batch... \")\n            tracking_batch_model = TrackingBatchHeadModel(\n                enola_sender=self.enola_sender,\n                period=self.period,\n                total_rows=len(self.dataframe),\n                name=self.name,\n                is_test=self.is_test,\n            )\n\n            tracking_batch = create_tracking_batch_head(\n                tracking_batch_model=tracking_batch_model,\n                connection=self.connection,\n                raise_error_if_fail=False,\n            )\n            self.batch_id = tracking_batch.batch_id\n            self.enola_sender.batch_id = self.batch_id\n\n        # Start cycle to send all data\n        print(f\"{self.name}: sending to server, upload... \")\n        # Show results\n        if self.batch_id == \"\":\n            print(f\"{self.name}: finish with error, batch_id is empty\")\n            return []\n\n        totalRows = len(self.dataframe)\n        listToSend: List[TrackingModel] = []\n        resultsList: List[TrackingResponseModel] = []\n        # Iterate over the dataframe\n        count_rows = 0\n        for index, row in self.dataframe.iterrows():\n\n            # Create step\n            step = Step(\n                name=self.name if (self.name != \"\") else \"Prediction\",\n                message_input=\"\",\n            )\n\n            # Add data to step in extra info\n            for column in self.dataframe.columns:\n                step.add_extra_info(column, row[column])\n\n            if (\n                self.score_cluster_column_name\n                and self.score_cluster_column_name in self.dataframe.columns\n            ):\n                step.score_cluster = row[self.score_cluster_column_name]\n                step.date_start = self.period\n                step.date_end = self.period\n            elif self.score_cluster_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column score_cluster_column_name '{self.score_cluster_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column score_cluster_column_name '{self.score_cluster_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.score_group_column_name\n                and self.score_group_column_name in self.dataframe.columns\n            ):\n                step.score_group = row[self.score_group_column_name]\n                step.date_start = self.period\n                step.date_end = self.period\n            elif self.score_group_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column score_group_column_name '{self.score_group_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column score_group_column_name '{self.score_group_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.score_value_column_name\n                and self.score_value_column_name in self.dataframe.columns\n            ):\n                step.score_value = row[self.score_value_column_name]\n                step.date_start = self.period\n                step.date_end = self.period\n            elif self.score_value_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column score_value_column_name '{self.score_value_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column score_value_column_name '{self.score_value_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.client_id_column_name\n                and self.client_id_column_name in self.dataframe.columns\n            ):\n                self.enola_sender.client_id = row[self.client_id_column_name]\n            elif self.client_id_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column client_id_column_name '{self.client_id_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column client_id_column_name '{self.client_id_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.product_id_column_name\n                and self.product_id_column_name in self.dataframe.columns\n            ):\n                step.product_id = row[self.product_id_column_name]\n            elif self.product_id_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column product_id_column_name '{self.product_id_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column product_id_column_name '{self.product_id_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.channel_id_column_name\n                and self.channel_id_column_name in self.dataframe.columns\n            ):\n                self.enola_sender.channel_id = row[self.channel_id_column_name]\n            elif self.channel_id_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column channel_id_column_name '{self.channel_id_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column channel_id_column_name '{self.channel_id_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.channel_name_column_name\n                and self.channel_name_column_name in self.dataframe.columns\n            ):\n                self.enola_sender.channel_name = row[self.channel_name_column_name]\n            elif self.channel_name_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column channel_name_column_name '{self.channel_name_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column channel_name_column_name '{self.channel_name_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.session_id_column_name\n                and self.session_id_column_name in self.dataframe.columns\n            ):\n                self.enola_sender.session_id = row[self.session_id_column_name]\n            elif self.session_id_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column session_id_column_name '{self.session_id_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column session_id_column_name '{self.session_id_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.session_name_column_name\n                and self.session_name_column_name in self.dataframe.columns\n            ):\n                self.enola_sender.session_name = row[self.session_name_column_name]\n            elif self.session_name_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column session_name_column_name '{self.session_name_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column session_name_column_name '{self.session_name_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.user_id_column_name\n                and self.user_id_column_name in self.dataframe.columns\n            ):\n                self.enola_sender.user_id = row[self.user_id_column_name]\n            elif self.user_id_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column user_id_column_name '{self.user_id_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column user_id_column_name '{self.user_id_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.user_name_column_name\n                and self.user_name_column_name in self.dataframe.columns\n            ):\n                self.enola_sender.user_name = row[self.user_name_column_name]\n            elif self.user_name_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column user_name_column_name '{self.user_name_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column user_name_column_name '{self.user_name_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.app_id_column_name\n                and self.app_id_column_name in self.dataframe.columns\n            ):\n                self.enola_sender.app_id = row[self.app_id_column_name]\n            elif self.app_id_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column app_id_column_name '{self.app_id_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column app_id_column_name '{self.app_id_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.app_name_column_name\n                and self.app_name_column_name in self.dataframe.columns\n            ):\n                self.enola_sender.app_name = row[self.app_name_column_name]\n            elif self.app_name_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column app_name_column_name '{self.app_name_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column app_name_column_name '{self.app_name_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.ip_column_name\n                and self.ip_column_name in self.dataframe.columns\n            ):\n                self.enola_sender.ip = row[self.ip_column_name]\n            elif self.ip_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column ip_column_name '{self.ip_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column ip_column_name '{self.ip_column_name}' not found in dataframe\"\n                )\n\n            if (\n                self.external_id_column_name\n                and self.external_id_column_name in self.dataframe.columns\n            ):\n                self.enola_sender.external_id = row[self.external_id_column_name]\n            elif self.external_id_column_name:\n                self.connection.huemul_logging.log_message_error(\n                    message=f\"{self.name}: column external_id_column_name '{self.external_id_column_name}' not found in dataframe\"\n                )\n                raise Exception(\n                    f\"{self.name}: column external_id_column_name '{self.external_id_column_name}' not found in dataframe\"\n                )\n\n            step.step_type = StepType.SCORE\n            step.successfull = True\n            step.set_score(\n                value=step.score_value,\n                group=step.score_group,\n                cluster=step.score_cluster,\n                date=step.date_start,\n            )\n\n            # Create tracking model\n            tracking_model = TrackingModel(\n                isTest=self.is_test,\n                enola_sender=self.enola_sender,\n                enola_id_prev=\"\",\n                steps=1,\n                step_list=[step],\n            )\n\n            # Add to list\n            listToSend.append(tracking_model)\n\n            # Send in batches\n            if len(listToSend) == batch_size or count_rows == totalRows - 1:\n                # Send to Enola\n                tracking_batch = create_tracking(\n                    tracking_list_model=listToSend,\n                    connection=self.connection,\n                    raise_error_if_fail=False,\n                )\n\n                if not tracking_batch.successfull:\n                    print(f\"{self.name}: finish with error, batch_id is empty\")\n                    return []\n\n                resultsList.extend(tracking_batch.tracking_list)\n                self.connection.huemul_logging.log_message_info(\n                    message=f\"{self.name} sent {len(resultsList)} of {totalRows}...\"\n                )\n\n                # Clean and continue\n                listToSend = []\n\n            count_rows += 1\n\n        self.connection.huemul_logging.log_message_info(\n            message=f\"{self.name} finish OK with batch_id: {self.batch_id}\"\n        )\n\n        return resultsList\n\n    def __str__(self) -&gt; str:\n        return f\"Agent/Model: {self.name}\"\n\n    def __getitem__(self, key):\n        return self.__dict__[key]\n\n    def __getattr__(self, key):\n        return self.__dict__[key]\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.__init__","title":"<code>__init__(token, name, dataframe, period, client_id_column_name, product_id_column_name, score_value_column_name=None, score_group_column_name=None, score_cluster_column_name=None, channel_id_column_name=None, channel_name_column_name=None, session_id_column_name=None, session_name_column_name=None, user_id_column_name=None, user_name_column_name=None, app_id_column_name=None, app_name_column_name=None, ip_column_name=None, external_id_column_name=None, app_id=None, app_name='', user_id=None, user_name='', session_id=None, session_name='', channel_id=None, channel_name='', ip=None, is_test=False)</code>","text":"<p>Initializes a new instance of the TrackingBatch class.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>JWT token used to identify the agent. Request this from the Admin App.</p> required <code>name</code> <code>str</code> <p>Name of this execution.</p> required <code>dataframe</code> <p>Pandas DataFrame containing the data to track.</p> required <code>period</code> <code>str</code> <p>Period of this execution in ISO format (e.g., '2021-01-01T00:00:00Z').</p> required <code>client_id_column_name</code> <code>str</code> <p>Name of the column with client ID.</p> required <code>product_id_column_name</code> <code>str</code> <p>Name of the column with product ID.</p> required <code>score_value_column_name</code> <code>str</code> <p>Name of the column with score value.</p> <code>None</code> <code>score_group_column_name</code> <code>str</code> <p>Name of the column with score group.</p> <code>None</code> <code>score_cluster_column_name</code> <code>str</code> <p>Name of the column with score cluster.</p> <code>None</code> <code>channel_id_column_name</code> <code>str</code> <p>Name of the column with channel ID.</p> <code>None</code> <code>channel_name_column_name</code> <code>str</code> <p>Name of the column with channel name.</p> <code>None</code> <code>session_id_column_name</code> <code>str</code> <p>Name of the column with session ID.</p> <code>None</code> <code>session_name_column_name</code> <code>str</code> <p>Name of the column with session name.</p> <code>None</code> <code>user_id_column_name</code> <code>str</code> <p>Name of the column with user ID.</p> <code>None</code> <code>user_name_column_name</code> <code>str</code> <p>Name of the column with user name.</p> <code>None</code> <code>app_id_column_name</code> <code>str</code> <p>Name of the column with app ID.</p> <code>None</code> <code>app_name_column_name</code> <code>str</code> <p>Name of the column with app name.</p> <code>None</code> <code>ip_column_name</code> <code>str</code> <p>Name of the column with IP address.</p> <code>None</code> <code>external_id_column_name</code> <code>str</code> <p>Name of the column with external ID.</p> <code>None</code> <code>app_id</code> <code>str</code> <p>ID of the app making the call.</p> <code>None</code> <code>app_name</code> <code>str</code> <p>Name of the app making the call.</p> <code>''</code> <code>user_id</code> <code>str</code> <p>ID of the external user.</p> <code>None</code> <code>user_name</code> <code>str</code> <p>Name of the external user.</p> <code>''</code> <code>session_id</code> <code>str</code> <p>ID of the user or application session.</p> <code>None</code> <code>session_name</code> <code>str</code> <p>Name of the session.</p> <code>''</code> <code>channel_id</code> <code>str</code> <p>ID of the communication channel (e.g., 'web', 'chat', 'whatsapp').</p> <code>None</code> <code>channel_name</code> <code>str</code> <p>Name of the communication channel.</p> <code>''</code> <code>ip</code> <code>str</code> <p>IP address of the user or application.</p> <code>None</code> <code>is_test</code> <code>bool</code> <p>True if this call is for testing purposes.</p> <code>False</code> Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def __init__(\n    self,\n    token: str,\n    name: str,\n    dataframe,\n    period: str,\n    client_id_column_name: str,\n    product_id_column_name: str,\n    score_value_column_name: Optional[str] = None,\n    score_group_column_name: Optional[str] = None,\n    score_cluster_column_name: Optional[str] = None,\n    channel_id_column_name: Optional[str] = None,\n    channel_name_column_name: Optional[str] = None,\n    session_id_column_name: Optional[str] = None,\n    session_name_column_name: Optional[str] = None,\n    user_id_column_name: Optional[str] = None,\n    user_name_column_name: Optional[str] = None,\n    app_id_column_name: Optional[str] = None,\n    app_name_column_name: Optional[str] = None,\n    ip_column_name: Optional[str] = None,\n    external_id_column_name: Optional[str] = None,\n    app_id: Optional[str] = None,\n    app_name: str = \"\",\n    user_id: Optional[str] = None,\n    user_name: str = \"\",\n    session_id: Optional[str] = None,\n    session_name: str = \"\",\n    channel_id: Optional[str] = None,\n    channel_name: str = \"\",\n    ip: Optional[str] = None,\n    is_test: bool = False,\n):\n    \"\"\"\n    Initializes a new instance of the TrackingBatch class.\n\n    Args:\n        token (str): JWT token used to identify the agent. Request this from the Admin App.\n        name (str): Name of this execution.\n        dataframe: Pandas DataFrame containing the data to track.\n        period (str): Period of this execution in ISO format (e.g., '2021-01-01T00:00:00Z').\n        client_id_column_name (str): Name of the column with client ID.\n        product_id_column_name (str): Name of the column with product ID.\n        score_value_column_name (str, optional): Name of the column with score value.\n        score_group_column_name (str, optional): Name of the column with score group.\n        score_cluster_column_name (str, optional): Name of the column with score cluster.\n        channel_id_column_name (str, optional): Name of the column with channel ID.\n        channel_name_column_name (str, optional): Name of the column with channel name.\n        session_id_column_name (str, optional): Name of the column with session ID.\n        session_name_column_name (str, optional): Name of the column with session name.\n        user_id_column_name (str, optional): Name of the column with user ID.\n        user_name_column_name (str, optional): Name of the column with user name.\n        app_id_column_name (str, optional): Name of the column with app ID.\n        app_name_column_name (str, optional): Name of the column with app name.\n        ip_column_name (str, optional): Name of the column with IP address.\n        external_id_column_name (str, optional): Name of the column with external ID.\n        app_id (str, optional): ID of the app making the call.\n        app_name (str, optional): Name of the app making the call.\n        user_id (str, optional): ID of the external user.\n        user_name (str, optional): Name of the external user.\n        session_id (str, optional): ID of the user or application session.\n        session_name (str, optional): Name of the session.\n        channel_id (str, optional): ID of the communication channel (e.g., 'web', 'chat', 'whatsapp').\n        channel_name (str, optional): Name of the communication channel.\n        ip (str, optional): IP address of the user or application.\n        is_test (bool, optional): True if this call is for testing purposes.\n    \"\"\"\n    self.name = name\n    self.hf = HuemulFunctions()\n    self.dataframe = dataframe\n    self.client_id_column_name = client_id_column_name\n    self.product_id_column_name = product_id_column_name\n    self.score_value_column_name = score_value_column_name\n    self.score_group_column_name = score_group_column_name\n    self.score_cluster_column_name = score_cluster_column_name\n    self.channel_id_column_name = channel_id_column_name\n    self.channel_name_column_name = channel_name_column_name\n    self.session_id_column_name = session_id_column_name\n    self.session_name_column_name = session_name_column_name\n    self.user_id_column_name = user_id_column_name\n    self.user_name_column_name = user_name_column_name\n    self.app_id_column_name = app_id_column_name\n    self.app_name_column_name = app_name_column_name\n    self.ip_column_name = ip_column_name\n    self.external_id_column_name = external_id_column_name\n    self.period = period\n\n    if dataframe is None:\n        raise Exception(\"DataFrame is empty\")\n    if len(dataframe) == 0:\n        raise Exception(\"DataFrame is empty (length is 0)\")\n    if score_value_column_name is None and score_group_column_name is None and score_cluster_column_name is None:\n        raise Exception(\n            \"At least one of 'score_value_column_name', 'score_group_column_name', or 'score_cluster_column_name' must be provided\"\n        )\n    if period is None or period == \"\":\n        raise Exception(\"Period is empty\")\n\n    # Decode JWT token\n    self.token_info = TokenInfo(token=token)\n\n    if not self.token_info.is_service_account:\n        raise Exception(\n            \"This token is not a service account. Only service accounts can execute tracking\"\n        )\n\n    if not self.token_info.agent_deploy_id:\n        raise Exception(\"agentDeployId is empty.\")\n\n    if not self.token_info.service_account_can_tracking:\n        raise Exception(\"This service account can't execute tracking\")\n\n    self.agent_deploy_id = self.token_info.agent_deploy_id\n    self.connection = Connect(\n        AuthModel(\n            jwt_token=token,\n            url_service=self.token_info.service_account_url_backend,\n            org_id=self.token_info.org_id,\n        )\n    )\n\n    # User information\n    self.enola_sender = EnolaSenderModel(\n        app_id=app_id,\n        app_name=app_name,\n        user_id=user_id,\n        user_name=user_name,\n        session_id=session_id,\n        session_name=session_name,\n        channel_id=channel_id,\n        channel_name=channel_name,\n        ip=ip,\n        external_id=\"\",\n        batch_id=\"\",\n        client_id=\"\",\n        product_id=\"\",\n    )\n\n    # If is empty or not exist assign false\n    self.is_test = is_test\n\n    # Save steps and information\n    self.batch_id = \"\"\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_custom_info","title":"<code>add_custom_info(key, value)</code>","text":"<p>Adds custom information to tracking.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the custom information.</p> required <code>value</code> <p>The value associated with the key.</p> required Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_custom_info(self, key: str, value) -&gt; None:\n    \"\"\"\n    Adds custom information to tracking.\n\n    Args:\n        key (str): The key for the custom information.\n        value: The value associated with the key.\n    \"\"\"\n    self.first_step.info_list.append(Info(key, value))\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_data_received","title":"<code>add_data_received(name, data, type)</code>","text":"<p>Adds data received from the user.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data.</p> required <code>data</code> <p>The data content.</p> required <code>type</code> <code>DataType</code> <p>The type of data received.</p> required Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_data_received(self, name: str, data, type: DataType) -&gt; None:\n    \"\"\"\n    Adds data received from the user.\n\n    Args:\n        name (str): The name of the data.\n        data: The data content.\n        type (DataType): The type of data received.\n    \"\"\"\n    self.first_step.agent_data_list.append(\n        DataListModel(value=data, name=name, data_type=type, kind=KindType.RECEIVER)\n    )\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_data_send","title":"<code>add_data_send(name, data, type)</code>","text":"<p>Adds data to send to the user.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data.</p> required <code>data</code> <p>The data content.</p> required <code>type</code> <code>DataType</code> <p>The type of data being sent.</p> required Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_data_send(self, name: str, data, type: DataType) -&gt; None:\n    \"\"\"\n    Adds data to send to the user.\n\n    Args:\n        name (str): The name of the data.\n        data: The data content.\n        type (DataType): The type of data being sent.\n    \"\"\"\n    self.first_step.agent_data_list.append(\n        DataListModel(value=data, name=name, data_type=type, kind=KindType.SENDER)\n    )\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_error","title":"<code>add_error(id, message, kind)</code>","text":"<p>Registers an error to tracking.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The error identifier.</p> required <code>message</code> <code>str</code> <p>The error message.</p> required <code>kind</code> <code>ErrOrWarnKind</code> <p>The kind of error.</p> required Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_error(self, id: str, message: str, kind: ErrOrWarnKind) -&gt; None:\n    \"\"\"\n    Registers an error to tracking.\n\n    Args:\n        id (str): The error identifier.\n        message (str): The error message.\n        kind (ErrOrWarnKind): The kind of error.\n    \"\"\"\n    self.first_step.add_error(id=id, message=message, kind=kind)\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_extra_info","title":"<code>add_extra_info(key, value)</code>","text":"<p>Adds extra information to tracking, this can be used to test or debug.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the extra information.</p> required <code>value</code> <p>The value associated with the key.</p> required Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_extra_info(self, key: str, value) -&gt; None:\n    \"\"\"\n    Adds extra information to tracking, this can be used to test or debug.\n\n    Args:\n        key (str): The key for the extra information.\n        value: The value associated with the key.\n    \"\"\"\n    self.first_step.add_extra_info(key=key, value=value)\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_tag","title":"<code>add_tag(key, value)</code>","text":"<p>Adds a tag to tracking, this tag is used to search in Enola App.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The tag key.</p> required <code>value</code> <p>The tag value.</p> required Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_tag(self, key: str, value) -&gt; None:\n    \"\"\"\n    Adds a tag to tracking, this tag is used to search in Enola App.\n\n    Args:\n        key (str): The tag key.\n        value: The tag value.\n    \"\"\"\n    self.first_step.add_tag(key=key, value=value)\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_warning","title":"<code>add_warning(id, message, kind)</code>","text":"<p>Registers a warning to tracking.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The warning identifier.</p> required <code>message</code> <code>str</code> <p>The warning message.</p> required <code>kind</code> <code>ErrOrWarnKind</code> <p>The kind of warning.</p> required Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_warning(self, id: str, message: str, kind: ErrOrWarnKind) -&gt; None:\n    \"\"\"\n    Registers a warning to tracking.\n\n    Args:\n        id (str): The warning identifier.\n        message (str): The warning message.\n        kind (ErrOrWarnKind): The kind of warning.\n    \"\"\"\n    self.first_step.add_warning(id=id, message=message, kind=kind)\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.execute","title":"<code>execute(batch_size=200)</code>","text":"<p>Registers the tracking batch in the Enola server.</p> <p>Parameters:</p> Name Type Description Default <code>batch_size</code> <code>int</code> <p>Number of records to send per batch. Defaults to 200.</p> <code>200</code> <p>Returns:</p> Type Description <code>List[TrackingResponseModel]</code> <p>List[TrackingResponseModel]: List of tracking response models returned by the server.</p> Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def execute(self, batch_size: int = 200) -&gt; List[TrackingResponseModel]:\n    \"\"\"\n    Registers the tracking batch in the Enola server.\n\n    Args:\n        batch_size (int, optional): Number of records to send per batch. Defaults to 200.\n\n    Returns:\n        List[TrackingResponseModel]: List of tracking response models returned by the server.\n    \"\"\"\n\n    # Create batch\n    if self.batch_id == \"\":\n        print(f\"{self.name}: sending to server, create Batch... \")\n        tracking_batch_model = TrackingBatchHeadModel(\n            enola_sender=self.enola_sender,\n            period=self.period,\n            total_rows=len(self.dataframe),\n            name=self.name,\n            is_test=self.is_test,\n        )\n\n        tracking_batch = create_tracking_batch_head(\n            tracking_batch_model=tracking_batch_model,\n            connection=self.connection,\n            raise_error_if_fail=False,\n        )\n        self.batch_id = tracking_batch.batch_id\n        self.enola_sender.batch_id = self.batch_id\n\n    # Start cycle to send all data\n    print(f\"{self.name}: sending to server, upload... \")\n    # Show results\n    if self.batch_id == \"\":\n        print(f\"{self.name}: finish with error, batch_id is empty\")\n        return []\n\n    totalRows = len(self.dataframe)\n    listToSend: List[TrackingModel] = []\n    resultsList: List[TrackingResponseModel] = []\n    # Iterate over the dataframe\n    count_rows = 0\n    for index, row in self.dataframe.iterrows():\n\n        # Create step\n        step = Step(\n            name=self.name if (self.name != \"\") else \"Prediction\",\n            message_input=\"\",\n        )\n\n        # Add data to step in extra info\n        for column in self.dataframe.columns:\n            step.add_extra_info(column, row[column])\n\n        if (\n            self.score_cluster_column_name\n            and self.score_cluster_column_name in self.dataframe.columns\n        ):\n            step.score_cluster = row[self.score_cluster_column_name]\n            step.date_start = self.period\n            step.date_end = self.period\n        elif self.score_cluster_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column score_cluster_column_name '{self.score_cluster_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column score_cluster_column_name '{self.score_cluster_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.score_group_column_name\n            and self.score_group_column_name in self.dataframe.columns\n        ):\n            step.score_group = row[self.score_group_column_name]\n            step.date_start = self.period\n            step.date_end = self.period\n        elif self.score_group_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column score_group_column_name '{self.score_group_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column score_group_column_name '{self.score_group_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.score_value_column_name\n            and self.score_value_column_name in self.dataframe.columns\n        ):\n            step.score_value = row[self.score_value_column_name]\n            step.date_start = self.period\n            step.date_end = self.period\n        elif self.score_value_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column score_value_column_name '{self.score_value_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column score_value_column_name '{self.score_value_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.client_id_column_name\n            and self.client_id_column_name in self.dataframe.columns\n        ):\n            self.enola_sender.client_id = row[self.client_id_column_name]\n        elif self.client_id_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column client_id_column_name '{self.client_id_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column client_id_column_name '{self.client_id_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.product_id_column_name\n            and self.product_id_column_name in self.dataframe.columns\n        ):\n            step.product_id = row[self.product_id_column_name]\n        elif self.product_id_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column product_id_column_name '{self.product_id_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column product_id_column_name '{self.product_id_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.channel_id_column_name\n            and self.channel_id_column_name in self.dataframe.columns\n        ):\n            self.enola_sender.channel_id = row[self.channel_id_column_name]\n        elif self.channel_id_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column channel_id_column_name '{self.channel_id_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column channel_id_column_name '{self.channel_id_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.channel_name_column_name\n            and self.channel_name_column_name in self.dataframe.columns\n        ):\n            self.enola_sender.channel_name = row[self.channel_name_column_name]\n        elif self.channel_name_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column channel_name_column_name '{self.channel_name_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column channel_name_column_name '{self.channel_name_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.session_id_column_name\n            and self.session_id_column_name in self.dataframe.columns\n        ):\n            self.enola_sender.session_id = row[self.session_id_column_name]\n        elif self.session_id_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column session_id_column_name '{self.session_id_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column session_id_column_name '{self.session_id_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.session_name_column_name\n            and self.session_name_column_name in self.dataframe.columns\n        ):\n            self.enola_sender.session_name = row[self.session_name_column_name]\n        elif self.session_name_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column session_name_column_name '{self.session_name_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column session_name_column_name '{self.session_name_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.user_id_column_name\n            and self.user_id_column_name in self.dataframe.columns\n        ):\n            self.enola_sender.user_id = row[self.user_id_column_name]\n        elif self.user_id_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column user_id_column_name '{self.user_id_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column user_id_column_name '{self.user_id_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.user_name_column_name\n            and self.user_name_column_name in self.dataframe.columns\n        ):\n            self.enola_sender.user_name = row[self.user_name_column_name]\n        elif self.user_name_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column user_name_column_name '{self.user_name_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column user_name_column_name '{self.user_name_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.app_id_column_name\n            and self.app_id_column_name in self.dataframe.columns\n        ):\n            self.enola_sender.app_id = row[self.app_id_column_name]\n        elif self.app_id_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column app_id_column_name '{self.app_id_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column app_id_column_name '{self.app_id_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.app_name_column_name\n            and self.app_name_column_name in self.dataframe.columns\n        ):\n            self.enola_sender.app_name = row[self.app_name_column_name]\n        elif self.app_name_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column app_name_column_name '{self.app_name_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column app_name_column_name '{self.app_name_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.ip_column_name\n            and self.ip_column_name in self.dataframe.columns\n        ):\n            self.enola_sender.ip = row[self.ip_column_name]\n        elif self.ip_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column ip_column_name '{self.ip_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column ip_column_name '{self.ip_column_name}' not found in dataframe\"\n            )\n\n        if (\n            self.external_id_column_name\n            and self.external_id_column_name in self.dataframe.columns\n        ):\n            self.enola_sender.external_id = row[self.external_id_column_name]\n        elif self.external_id_column_name:\n            self.connection.huemul_logging.log_message_error(\n                message=f\"{self.name}: column external_id_column_name '{self.external_id_column_name}' not found in dataframe\"\n            )\n            raise Exception(\n                f\"{self.name}: column external_id_column_name '{self.external_id_column_name}' not found in dataframe\"\n            )\n\n        step.step_type = StepType.SCORE\n        step.successfull = True\n        step.set_score(\n            value=step.score_value,\n            group=step.score_group,\n            cluster=step.score_cluster,\n            date=step.date_start,\n        )\n\n        # Create tracking model\n        tracking_model = TrackingModel(\n            isTest=self.is_test,\n            enola_sender=self.enola_sender,\n            enola_id_prev=\"\",\n            steps=1,\n            step_list=[step],\n        )\n\n        # Add to list\n        listToSend.append(tracking_model)\n\n        # Send in batches\n        if len(listToSend) == batch_size or count_rows == totalRows - 1:\n            # Send to Enola\n            tracking_batch = create_tracking(\n                tracking_list_model=listToSend,\n                connection=self.connection,\n                raise_error_if_fail=False,\n            )\n\n            if not tracking_batch.successfull:\n                print(f\"{self.name}: finish with error, batch_id is empty\")\n                return []\n\n            resultsList.extend(tracking_batch.tracking_list)\n            self.connection.huemul_logging.log_message_info(\n                message=f\"{self.name} sent {len(resultsList)} of {totalRows}...\"\n            )\n\n            # Clean and continue\n            listToSend = []\n\n        count_rows += 1\n\n    self.connection.huemul_logging.log_message_info(\n        message=f\"{self.name} finish OK with batch_id: {self.batch_id}\"\n    )\n\n    return resultsList\n</code></pre>"}]}