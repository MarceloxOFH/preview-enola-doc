{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Enola AI Documentation","text":"<p>This documentation covers the modules and packages of the Enola AI project.</p>"},{"location":"reference/enola.step/","title":"Step","text":""},{"location":"reference/enola_types/","title":"Enola Types","text":""},{"location":"reference/enola_types/#enola.enola_types.EnolaSenderModel","title":"<code>EnolaSenderModel</code>","text":"<p>EnolaSenderModel</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class EnolaSenderModel:\n    \"\"\"\n    EnolaSenderModel\n    \"\"\"\n    def __init__ (self, \n                app_id: str, \n                app_name: str, \n                user_id: str, \n                user_name: str, \n                session_id: str, \n                session_name: str, \n                channel_id: str, \n                channel_name: str, \n                client_id: str,\n                product_id: str,\n                external_id: str,\n                batch_id: str,\n                  ip: str):\n        self.app_id=app_id\n        self.app_name=app_name\n        self.user_id=user_id\n        self.user_name=user_name\n        self.session_id=session_id\n        self.session_name=session_name\n        self.channel_id=channel_id\n        self.channel_name=channel_name\n        self.client_id=client_id\n        self.product_id=product_id\n        self.external_id=external_id\n        self.batch_id=batch_id\n        self.ip=ip\n\n    def __getitem__(self, key):\n        return self.__dict__[key]\n\n    def __getattr__(self, key):\n        return self.__dict__[key]\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ErrOrWarnKind","title":"<code>ErrOrWarnKind</code>","text":"<p>               Bases: <code>Enum</code></p> <p>EXTERNAL: external agent call generate an unexpected error or warning</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class ErrOrWarnKind(Enum):\n    \"\"\"\n    EXTERNAL: external agent call generate an unexpected error or warning\n    \"\"\"\n    EXTERNAL = \"EXTERNAL\"\n    \"\"\"\n    INTERNAL_CONTROLLED: internal agent call generate an unexpected error or warning\n    \"\"\"\n    INTERNAL_CONTROLLED = \"INTERNAL_CONTROLLED\"\n    \"\"\"\n    INTERNAL_TOUSER: controlled error or warning to send to user\n    \"\"\"\n    INTERNAL_TOUSER = \"INTERNAL_TOUSER\"\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.ErrOrWarnKind.EXTERNAL","title":"<code>EXTERNAL = 'EXTERNAL'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>INTERNAL_CONTROLLED: internal agent call generate an unexpected error or warning</p>"},{"location":"reference/enola_types/#enola.enola_types.ErrOrWarnKind.INTERNAL_CONTROLLED","title":"<code>INTERNAL_CONTROLLED = 'INTERNAL_CONTROLLED'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>INTERNAL_TOUSER: controlled error or warning to send to user</p>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationDetailModel","title":"<code>EvaluationDetailModel</code>","text":"<p>EvaluationDetailModel</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class EvaluationDetailModel:\n    \"\"\"\n    EvaluationDetailModel\n    \"\"\"\n    def __init__(self, eval_id: str, comment: str, value: float=None, level: int=None):\n        self.eval_id = eval_id\n        self.value = value\n        self.level = level\n        self.comment = comment\n\n    def __getitem__(self, key):\n        return self.__dict__[key]\n\n    def __getattr__(self, key):\n        return self.__dict__[key]\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.EvaluationModel","title":"<code>EvaluationModel</code>","text":"<p>EvaluationModel</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class EvaluationModel:\n    \"\"\"\n    EvaluationModel\n    \"\"\"\n    def __init__(self, enola_id: str, eval_type: EvalType, enola_sender: EnolaSenderModel, result_score: ResultScore = None, result_llm: ResultLLM =None):\n        self.enola_id = enola_id\n        self.eval_type = eval_type.value\n        self.evals: List[EvaluationDetailModel] = []\n        self.enola_sender = enola_sender\n        self.result_score = result_score\n        self.result_llm = result_llm\n\n    def add_eval(self, eval: EvaluationDetailModel):\n        self.evals.append(eval)\n\n    def to_json(self):\n        results_json = None\n        if (self.result_score != None):\n            results_json = self.result_score.to_json()\n        elif (self.result_llm != None):\n            results_json = self.result_llm.to_json()\n\n        result = {\n            \"enolaId\": self.enola_id,\n            \"evalType\": self.eval_type, # \"AUTO\"\n            \"sender\": {\n                \"app_id\": self.enola_sender.app_id,\n                \"app_name\": self.enola_sender.app_name,\n                \"user_id\": self.enola_sender.user_id,\n                \"user_name\": self.enola_sender.user_name,\n                \"session_id\": self.enola_sender.session_id,\n                \"session_name\": self.enola_sender.session_name,\n                \"channel_id\": self.enola_sender.channel_id,\n                \"channel_name\": self.enola_sender.channel_name,\n                \"ip\": self.enola_sender.ip\n            },\n            \"results\": results_json,       \n            \"evals\": {\n                item.eval_id: {\n                    \"value\": item.value,\n                    \"level\": item.level,\n                    \"comment\": item.comment\n                }\n                for item in self.evals\n            }\n        }\n        return result;\n\n    def __getitem__(self, key):\n        return self.__dict__[key]\n\n    def __getattr__(self, key):\n        return self.__dict__[key]\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Step","title":"<code>Step</code>","text":"Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class Step:\n    def __init__(self, name: str, message_input: str = \"\"):\n        self.hf = HuemulFunctions()\n        self.name = name\n        self.enola_id = \"\"\n        self.agent_deploy_id = \"\"\n        self.step_id = \"\"\n        self.message_input = message_input\n        self.message_output = \"\"\n        self.num_iterations = 0\n        self.step_id_prev = \"\"\n        self.date_start = self.hf.get_date_for_api()\n        self.date_end = self.date_start\n        #self.result_list = []\n        self.agent_data_list = [] #only for first step\n        self.errOrWarn_list = []\n        self.extra_info_list = []\n        self.file_info_list = []\n        self.step_api_data_list = []\n        self.step_type:StepType = StepType.OTHER\n\n        self.successfull = False\n        self.num_errors = 0\n        self.num_warnings = 0\n\n        self.score_value=0\n        self.score_group=\"\"\n        self.score_cluster=\"\"\n\n        self.video = StepVideo()\n        self.audio = StepAudio()\n        self.image = StepImage()\n        self.doc = StepDoc()\n        self.token = StepToken()\n        self.cost = StepCost()\n        self.income_total = 0\n        self.duration_in_ms = 0\n\n    def set_score(self, value: int, group: str, cluster: str, date: str = \"\"):\n        \"\"\"\n        Set score for step\n        value: score value\n        group: score group\n        cluster: score cluster\n        date: date of score in ISO &amp; UTC format (example: yyyy-MM-ddTHH:mm:ss:SSSz). Empty for current date\n        \"\"\"\n        self.score_value = value\n        self.score_group = group\n        self.score_cluster = cluster\n        if (date != \"\"):\n            self.date_start = date\n            self.date_end = date\n\n\n    def add_api_data(self, bodyToSend: str, payloadReceived: str, name: str, method: str, url: str, description: str = \"\", headerToSend: str = \"\"):\n        self.step_api_data_list.append(ApiDataModel(name=name, method=method, url=url, body=bodyToSend, header=headerToSend, payload=payloadReceived, description=description)) \n        #{\"body\": bodyToSend, \"header\": headerToSend, \"payload\": payloadReceived})\n\n    def add_file_link(self, name: str, url: str, type: str, size_kb: int, description: str = \"\"):\n        self.file_info_list.append(FileInfoModel(name=name, url=url, type=type, sizeKb=size_kb, description=description))\n        #{\"name\": name, \"url\": url, \"type\": type, \"size\": size})\n\n    def add_tag(self, key: str, value):\n        self.extra_info_list.append(Info(type=\"tag\", key=key, value=value))\n\n    def add_extra_info(self, key: str, value):\n        self.extra_info_list.append(Info(type=\"info\", key=key, value=value))\n\n    def add_error(self, id: str, message: str, kind: ErrOrWarnKind):\n        self.num_errors += 1\n        self.errOrWarn_list.append(ErrorOrWarnModel(id=id, message=message, error_type=ErrorType.ERROR, kind=kind))\n\n    def add_warning(self, id: str, message: str, kind: ErrOrWarnKind):\n        self.num_warnings += 1\n        self.errOrWarn_list.append(ErrorOrWarnModel(id=id, message=message, error_type=ErrorType.ERROR, kind=kind))\n\n    def to_json(self):\n        return {\n            \"stepId\": self.step_id,\n            \"stepIdPrev\": self.step_id_prev,\n            \"stepDateStart\": self.date_start,\n            \"stepDateEnd\": self.date_end,\n            \"agentDeployId\": self.agent_deploy_id,\n            \"agentExecName\": self.name,\n            \"agentExecDurationMs\": self.duration_in_ms,\n            \"agentExecSuccessfull\": self.successfull,\n            \"agentExecNumErrors\": self.num_errors,\n            \"agentExecNumWarnings\": self.num_warnings,\n            \"agentExecNumVideos\": self.video.num_videos,\n            \"agentExecSecVideos\": self.video.sec_videos,\n            \"agentExecSizeAudio\": self.video.size_videos,\n            \"agentExecNumAudio\": self.audio.num_audio,\n            \"agentExecSecAudio\": self.audio.sec_audio,\n            \"agentExecSizeVideos\": self.video.size_videos,\n            \"agentExecNumImages\": self.image.num_images,\n            \"agentExecSizeImages\": self.image.size_images,\n            \"agentExecNumDocs\": self.doc.num_docs,\n            \"agentExecNumPages\": self.doc.num_pages,\n            \"agentExecSizeDocs\": self.doc.size_docs,\n            \"agentExecNumChar\": self.doc.num_char + self.token.num_char,\n            \"agentExecTokenInput\": self.token.token_input,\n            \"agentExecTokenOutput\": self.token.token_output,\n            \"agentExecTokenTotal\": self.token.token_total,\n            \"agentExecCostTokenInput\": self.cost.token_input,\n            \"agentExecCostTokenOutput\": self.cost.token_output,\n            \"agentExecCostTokenTotal\": self.cost.token_total,\n            \"agentExecCostVideos\": self.cost.videos,\n            \"agentExecCostAudio\": self.cost.audio,\n            \"agentExecCostImages\": self.cost.images,\n            \"agentExecCostDocs\": self.cost.docs,\n            \"agentExecCostInfra\": self.cost.infra,\n            \"agentExecCostOthers\": self.cost.others,\n            \"agentExecCostTotal\": self.cost.total,\n            \"agentExecIncomeTotal\": self.income_total,\n            \"agentExecScoreValue\": self.score_value,\n            \"agentExecScoreGroup\": self.score_group,\n            \"agentExecScoreCluster\": self.score_cluster,\n            \"agentExecType\": self.step_type.value,\n\n            \"agentExecMessageInput\": self.message_input,\n            \"agentExecMessageOutput\": self.message_output,\n            \"agentExecCliNumIter\": self.num_iterations,\n\n            \"agentData\": list(map(lambda x: x.to_json(), self.agent_data_list)),\n            \"errorOrWarning\": list(map(lambda x: x.to_json(), self.errOrWarn_list)),\n            \"extraInfo\": list(map(lambda x: x.to_json(), self.extra_info_list)),\n            \"fileInfo\": list(map(lambda x: x.to_json(), self.file_info_list)),\n            \"stepApiData\": list(map(lambda x: x.to_json(), self.step_api_data_list)),\n        }\n\n    def __str__(self):\n        return f'Step: {self.description}, Duration: {self.duration} seconds'\n\n    def __getitem__(self, key):\n        return self.__dict__[key]\n\n    def __getattr__(self, key):\n        return self.__dict__[key]\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.Step.set_score","title":"<code>set_score(value, group, cluster, date='')</code>","text":"<p>Set score for step value: score value group: score group cluster: score cluster date: date of score in ISO &amp; UTC format (example: yyyy-MM-ddTHH:mm:ss:SSSz). Empty for current date</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>def set_score(self, value: int, group: str, cluster: str, date: str = \"\"):\n    \"\"\"\n    Set score for step\n    value: score value\n    group: score group\n    cluster: score cluster\n    date: date of score in ISO &amp; UTC format (example: yyyy-MM-ddTHH:mm:ss:SSSz). Empty for current date\n    \"\"\"\n    self.score_value = value\n    self.score_group = group\n    self.score_cluster = cluster\n    if (date != \"\"):\n        self.date_start = date\n        self.date_end = date\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingBatchHeadModel","title":"<code>TrackingBatchHeadModel</code>","text":"<p>TrackingBatchHeadModel</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class TrackingBatchHeadModel:\n    \"\"\"\n    TrackingBatchHeadModel\n    \"\"\"\n    def __init__(self, name: str, period: str, total_rows: int, is_test: bool, enola_sender: EnolaSenderModel):\n        self.enola_sender = enola_sender\n        self.name = name\n        self.period = period\n        self.total_rows = total_rows\n        self.is_test = is_test\n\n    def to_json(self):\n        return {\n            \"agentExecBatchCliAppId\": self.enola_sender.app_id,\n            \"agentExecBatchCliAppName\": self.enola_sender.app_name,\n            \"agentExecBatchCliUserId\": self.enola_sender.user_id,\n            \"agentExecBatchCliUserName\": self.enola_sender.user_name,\n            \"agentExecBatchCliSessionId\": self.enola_sender.session_id,\n            \"agentExecBatchCliChannel\": self.enola_sender.channel_id,\n            \"agentExecBatchCliChannelName\": self.enola_sender.channel_name,\n            \"agentExecBatchCliSessionName\": self.enola_sender.session_name,\n            \"agentExecBatchCliIP\": self.enola_sender.ip,\n            \"agentExecBatchName\": self.name,\n            \"agentExecBatchPeriodData\": self.period,\n            \"agentExecBatchIsTest\": self.is_test,\n            \"agentExecBatchNumRowsTotal\": self.total_rows\n        }\n\n    def __getitem__(self, key):\n        return self.__dict__[key]\n\n    def __getattr__(self, key):\n        return self.__dict__[key]\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/enola_types/#enola.enola_types.TrackingModel","title":"<code>TrackingModel</code>","text":"<p>TrackingModel</p> Source code in <code>src\\enola\\enola_types.py</code> <pre><code>class TrackingModel:\n    \"\"\"\n    TrackingModel\n    \"\"\"\n    def __init__(self, isTest: bool, step_list: List[Step], steps: int, enola_id_prev: str, enola_sender: EnolaSenderModel):\n        self.enola_sender = enola_sender\n\n        self.isTest = isTest\n        #step_list es una lista, generar un arreglo ejecutando el metodo to_json de cada elemento de la lista con map\n        self.step_list = step_list\n        self.steps = steps\n        self.enola_id_prev = enola_id_prev\n\n    def to_json(self):\n        return {\n            \"app_id\": self.enola_sender.app_id,\n            \"app_name\": self.enola_sender.app_name,\n            \"user_id\": self.enola_sender.user_id,\n            \"user_name\": self.enola_sender.user_name,\n            \"session_id\": self.enola_sender.session_id,\n            \"channel_id\": self.enola_sender.channel_id,\n            \"session_name\": self.enola_sender.session_name,\n            \"client_id\": self.enola_sender.client_id,\n            \"product_id\": self.enola_sender.product_id,\n            \"agentExecBatchId\": self.enola_sender.batch_id,\n            \"ip\": self.enola_sender.ip,\n            \"code_api\": self.enola_sender.external_id,\n            \"isTest\": self.isTest,\n            \"step_list\": list(map(lambda x: x.to_json(), self.step_list)),\n            \"steps\": self.steps,\n            \"enola_id_prev\": self.enola_id_prev\n        }\n\n    def __getitem__(self, key):\n        return self.__dict__[key]\n\n    def __getattr__(self, key):\n        return self.__dict__[key]\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/evaluation/","title":"Evaluation","text":""},{"location":"reference/evaluation/#enola.evaluation.Evaluation","title":"<code>Evaluation</code>","text":"Source code in <code>src\\enola\\evaluation.py</code> <pre><code>class Evaluation:\n    def __init__(self, token, eval_type: EvalType=EvalType.AUTO, result_score:ResultScore=None, result_llm:ResultLLM=None, app_id=None, user_id=None, session_id=None, channel_id=None, ip=None, app_name:str=\"\", user_name:str=\"\", session_name:str=\"\", channel_name:str=\"\"):\n        \"\"\"\n        Start Evaluation Execution\n\n        token: jwt token, this is used to identify the agent, request from Admin App\n        eval_type: type of evaluation, AUTO (ML or AI evaluator), USER (final user), INTERNAL (internal expert)\n        result_score: reaactual results of score\n        result_llm: actual results of llm\n        app_id: id of app, this is used to identify the app who is calling\n        app_name: name of app, this is used to identify the app who is calling\n        user_id: id of external user, this is used to identify the user who is calling\n        user_name: name of external user, this is used to identify the user who is calling\n        session_id: id of session of user or application, this is used to identify the session who is calling\n        channel_id: web, chat, whatsapp, etc, this is used to identify the channel who is calling\n        channel_name: web, chat, whatsapp, etc, this is used to identify the channel who is calling\n        ip: ip of user or application, this is used to identify the ip who is calling\n        \"\"\"\n        self.hf = HuemulFunctions()\n        self.eval_type = eval_type\n        self.result_score = result_score\n        self.result_llm = result_llm\n\n        #Connection data\n\n        #decodificar jwt\n        self.token_info = TokenInfo(token=token)\n\n        if (self.token_info.is_service_account == False):\n            raise Exception(\"This token is not a service account. Only service accounts can execute evaluations.\")\n\n        if (self.token_info.is_service_account == True and self.token_info.service_account_can_evaluate == False):\n            raise Exception(\"Service Account can't evaluate\")\n\n\n        self.connection = Connect(AuthModel(jwt_token=token, url_service=self.token_info.service_account_url, org_id=self.token_info.org_id))\n\n\n        #user information\n        self.enola_sender = EnolaSenderModel(\n            app_id=app_id, \n            app_name=app_name, \n            user_id=user_id, \n            user_name=user_name, \n            session_id=session_id, \n            session_name=session_name, \n            channel_id=channel_id, \n            channel_name=channel_name, \n            batch_id=\"\",\n            client_id=\"\",\n            external_id=\"\",\n            product_id=\"\",\n            ip=ip\n            )\n\n        #current date\n        self.date_start = self.hf.get_date_for_api()\n        self.executions = []\n\n        #save steps and informations\n\n    ########################################################################################\n    ###############    E V A L U A T I O N     M E T H O D S     ###########################\n    ########################################################################################\n\n\n    def execution_exists(self, enola_id: str):\n        \"\"\"\n        Check if execution exists\n        enola_id: id of enola\n        \"\"\"\n        for item in self.executions:\n            if item.enola_id == enola_id:\n                return item\n        return None\n\n    def add_evaluation(self, enola_id: str, eval_id: str, value: float, comment: str):\n        \"\"\"\n        Add Evaluation by value\n        enola_id: id of enola\n        eval_id: id of evaluation\n        value: value of evaluation\n        comment: comment of evaluation\n        \"\"\"\n\n        eval = EvaluationDetailModel(eval_id=eval_id, value=value, comment=comment)\n        #check if enola_id exists (append eval), if not, create new enola_id\n        execution = self.execution_exists(enola_id)\n\n\n        if (execution is None):\n            execution = EvaluationModel(enola_id, eval_type=self.eval_type, enola_sender = self.enola_sender, result_score=self.result_score, result_llm=self.result_llm)\n            self.executions.append(execution)\n\n        execution.add_eval(eval)\n\n    def add_evaluation_by_level(self, enola_id: str, eval_id: str, level: int, comment: str):\n        \"\"\"\n        Add Evaluation by level\n        enola_id: id of enola\n        eval_id: id of evaluation\n        level: 1 to 5\n        comment: comment of evaluation\n        \"\"\"\n\n        eval = EvaluationDetailModel(eval_id=eval_id, level=level, comment=comment)\n        #check if enola_id exists (append eval), if not, create new enola_id\n        execution = self.execution_exists(enola_id)\n\n\n        if (execution is None):\n            execution = EvaluationModel(enola_id, eval_type=self.eval_type, enola_sender = self.enola_sender)\n            self.executions.append(execution)\n\n        execution.add_eval(eval)\n\n    def execute(self):\n        \"\"\"\n        Execute Evaluations\n        \"\"\"\n        final_result: EvaluationResultModel = EvaluationResultModel(\n            total_evals=len(self.executions), \n            total_errors=0, \n            total_success=0, \n            errors=[]\n        )\n\n        for item in self.executions:\n            result = create_evaluation(evaluation_model=item, connection=self.connection)\n            if not result.successfull:\n                print(result.errors)\n                print(result.message)\n                final_result.errors.append(result.message)\n\n        return final_result\n\n    def __getitem__(self, key):\n        return self.__dict__[key]\n\n    def __getattr__(self, key):\n        return self.__dict__[key]\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/evaluation/#enola.evaluation.Evaluation.__init__","title":"<code>__init__(token, eval_type=EvalType.AUTO, result_score=None, result_llm=None, app_id=None, user_id=None, session_id=None, channel_id=None, ip=None, app_name='', user_name='', session_name='', channel_name='')</code>","text":"<p>Start Evaluation Execution</p> <p>token: jwt token, this is used to identify the agent, request from Admin App eval_type: type of evaluation, AUTO (ML or AI evaluator), USER (final user), INTERNAL (internal expert) result_score: reaactual results of score result_llm: actual results of llm app_id: id of app, this is used to identify the app who is calling app_name: name of app, this is used to identify the app who is calling user_id: id of external user, this is used to identify the user who is calling user_name: name of external user, this is used to identify the user who is calling session_id: id of session of user or application, this is used to identify the session who is calling channel_id: web, chat, whatsapp, etc, this is used to identify the channel who is calling channel_name: web, chat, whatsapp, etc, this is used to identify the channel who is calling ip: ip of user or application, this is used to identify the ip who is calling</p> Source code in <code>src\\enola\\evaluation.py</code> <pre><code>def __init__(self, token, eval_type: EvalType=EvalType.AUTO, result_score:ResultScore=None, result_llm:ResultLLM=None, app_id=None, user_id=None, session_id=None, channel_id=None, ip=None, app_name:str=\"\", user_name:str=\"\", session_name:str=\"\", channel_name:str=\"\"):\n    \"\"\"\n    Start Evaluation Execution\n\n    token: jwt token, this is used to identify the agent, request from Admin App\n    eval_type: type of evaluation, AUTO (ML or AI evaluator), USER (final user), INTERNAL (internal expert)\n    result_score: reaactual results of score\n    result_llm: actual results of llm\n    app_id: id of app, this is used to identify the app who is calling\n    app_name: name of app, this is used to identify the app who is calling\n    user_id: id of external user, this is used to identify the user who is calling\n    user_name: name of external user, this is used to identify the user who is calling\n    session_id: id of session of user or application, this is used to identify the session who is calling\n    channel_id: web, chat, whatsapp, etc, this is used to identify the channel who is calling\n    channel_name: web, chat, whatsapp, etc, this is used to identify the channel who is calling\n    ip: ip of user or application, this is used to identify the ip who is calling\n    \"\"\"\n    self.hf = HuemulFunctions()\n    self.eval_type = eval_type\n    self.result_score = result_score\n    self.result_llm = result_llm\n\n    #Connection data\n\n    #decodificar jwt\n    self.token_info = TokenInfo(token=token)\n\n    if (self.token_info.is_service_account == False):\n        raise Exception(\"This token is not a service account. Only service accounts can execute evaluations.\")\n\n    if (self.token_info.is_service_account == True and self.token_info.service_account_can_evaluate == False):\n        raise Exception(\"Service Account can't evaluate\")\n\n\n    self.connection = Connect(AuthModel(jwt_token=token, url_service=self.token_info.service_account_url, org_id=self.token_info.org_id))\n\n\n    #user information\n    self.enola_sender = EnolaSenderModel(\n        app_id=app_id, \n        app_name=app_name, \n        user_id=user_id, \n        user_name=user_name, \n        session_id=session_id, \n        session_name=session_name, \n        channel_id=channel_id, \n        channel_name=channel_name, \n        batch_id=\"\",\n        client_id=\"\",\n        external_id=\"\",\n        product_id=\"\",\n        ip=ip\n        )\n\n    #current date\n    self.date_start = self.hf.get_date_for_api()\n    self.executions = []\n</code></pre>"},{"location":"reference/evaluation/#enola.evaluation.Evaluation.add_evaluation","title":"<code>add_evaluation(enola_id, eval_id, value, comment)</code>","text":"<p>Add Evaluation by value enola_id: id of enola eval_id: id of evaluation value: value of evaluation comment: comment of evaluation</p> Source code in <code>src\\enola\\evaluation.py</code> <pre><code>def add_evaluation(self, enola_id: str, eval_id: str, value: float, comment: str):\n    \"\"\"\n    Add Evaluation by value\n    enola_id: id of enola\n    eval_id: id of evaluation\n    value: value of evaluation\n    comment: comment of evaluation\n    \"\"\"\n\n    eval = EvaluationDetailModel(eval_id=eval_id, value=value, comment=comment)\n    #check if enola_id exists (append eval), if not, create new enola_id\n    execution = self.execution_exists(enola_id)\n\n\n    if (execution is None):\n        execution = EvaluationModel(enola_id, eval_type=self.eval_type, enola_sender = self.enola_sender, result_score=self.result_score, result_llm=self.result_llm)\n        self.executions.append(execution)\n\n    execution.add_eval(eval)\n</code></pre>"},{"location":"reference/evaluation/#enola.evaluation.Evaluation.add_evaluation_by_level","title":"<code>add_evaluation_by_level(enola_id, eval_id, level, comment)</code>","text":"<p>Add Evaluation by level enola_id: id of enola eval_id: id of evaluation level: 1 to 5 comment: comment of evaluation</p> Source code in <code>src\\enola\\evaluation.py</code> <pre><code>def add_evaluation_by_level(self, enola_id: str, eval_id: str, level: int, comment: str):\n    \"\"\"\n    Add Evaluation by level\n    enola_id: id of enola\n    eval_id: id of evaluation\n    level: 1 to 5\n    comment: comment of evaluation\n    \"\"\"\n\n    eval = EvaluationDetailModel(eval_id=eval_id, level=level, comment=comment)\n    #check if enola_id exists (append eval), if not, create new enola_id\n    execution = self.execution_exists(enola_id)\n\n\n    if (execution is None):\n        execution = EvaluationModel(enola_id, eval_type=self.eval_type, enola_sender = self.enola_sender)\n        self.executions.append(execution)\n\n    execution.add_eval(eval)\n</code></pre>"},{"location":"reference/evaluation/#enola.evaluation.Evaluation.execute","title":"<code>execute()</code>","text":"<p>Execute Evaluations</p> Source code in <code>src\\enola\\evaluation.py</code> <pre><code>def execute(self):\n    \"\"\"\n    Execute Evaluations\n    \"\"\"\n    final_result: EvaluationResultModel = EvaluationResultModel(\n        total_evals=len(self.executions), \n        total_errors=0, \n        total_success=0, \n        errors=[]\n    )\n\n    for item in self.executions:\n        result = create_evaluation(evaluation_model=item, connection=self.connection)\n        if not result.successfull:\n            print(result.errors)\n            print(result.message)\n            final_result.errors.append(result.message)\n\n    return final_result\n</code></pre>"},{"location":"reference/evaluation/#enola.evaluation.Evaluation.execution_exists","title":"<code>execution_exists(enola_id)</code>","text":"<p>Check if execution exists enola_id: id of enola</p> Source code in <code>src\\enola\\evaluation.py</code> <pre><code>def execution_exists(self, enola_id: str):\n    \"\"\"\n    Check if execution exists\n    enola_id: id of enola\n    \"\"\"\n    for item in self.executions:\n        if item.enola_id == enola_id:\n            return item\n    return None\n</code></pre>"},{"location":"reference/get_executions/","title":"Get Executions","text":""},{"location":"reference/get_executions/#enola.get_executions.GetExecutions","title":"<code>GetExecutions</code>","text":"Source code in <code>src\\enola\\get_executions.py</code> <pre><code>class GetExecutions:\n    def __init__(self, token: str, raise_error_if_fail = True):\n        \"\"\"\n        Start Executions Execution\n\n        token: jwt token, this is used to identify the agent, request from Admin App\n        \"\"\"\n        self.raise_error_if_fail = raise_error_if_fail\n        self.num_rows_acum = 0\n        self.num_rows = 0\n        self.continue_execution = False\n        self.hf = HuemulFunctions()\n        #Connection data\n\n        #get token info\n        self.token_info = TokenInfo(token=token)\n\n        if (self.token_info.is_service_account == True and self.token_info.service_account_can_get_executions == False):\n            raise Exception(\"Service Account Token is not allowed to get executions\")\n\n        self.connection = Connect(AuthModel(jwt_token=token, url_service=self.token_info.service_account_url_backend, org_id=self.token_info.org_id))\n\n    def get_next_page(self):\n        if (self.continue_execution == False):\n            raise Exception(\"No more data to show.\")\n\n        self.execution_query_model.page_number += 1\n        enola_result = self.__run_query()\n\n        #show results\n        return enola_result\n\n    def get_page_number(self):\n        return self.execution_query_model.page_number\n\n\n    def query(self, \n                 date_from:str,\n                 date_to:str,\n                 chamber_id_list:list = [], \n                 agent_id_list:list = [], \n                 agent_deploy_id_list:list = [],\n                 user_id_list:list = [],\n                 session_id_list:list = [],\n                 channel_id_list:list = [],\n                 data_filter_list:list = [],\n                 eval_id_user: ExecutionEvalFilter = None,\n                 eval_id_internal: ExecutionEvalFilter = None,\n                 eval_id_auto: ExecutionEvalFilter = None,\n                 environment_id:Environtment = None,\n                 is_test_plan: bool= None,\n                 finished:bool = None,\n                 limit:int=100, \n                 include_tags:bool=False,\n                 include_data:bool=False,\n                 include_errors:bool=False,\n                 include_evals:bool=False,\n                 ) -&gt; ExecutionModel:\n        \"\"\"\n        Get Items by Chamber\n\n        date_from: str, date from\n        date_to: str, date to\n        chamber_id: list, chamber id\n        agent_id: list, agent id\n        agent_deploy_id: list, agent deploy id\n        user_id: list, user id\n        session_id: list, session id\n        channel_id: list, channel id\n        data_filter: list, data filter\n        eval_id_user: ExecutionEvalFilter, eval id user\n        eval_id_internal: ExecutionEvalFilter, eval id internal\n        eval_id_auto: ExecutionEvalFilter, eval id auto\n        environment_id: Environtment, environment id\n        is_test_plan: bool, is test plan\n        finished: bool, finished\n        limit: int, 100 is default limit\n        include_tags: bool, include tags\n        include_data: bool, include data\n        include_errors: bool, include errors\n        include_evals: bool, include evals\n        \"\"\"\n\n        if (self.token_info.agent_deploy_id != None and self.token_info.agent_deploy_id != \"\" and self.token_info.agent_deploy_id != \"0\"):\n            if (len(agent_deploy_id_list) &gt; 1):\n                raise Exception(\"Service Account Token is not allowed to access more than one agent_deploy_id\", self.token_info.agent_deploy_id)\n            if (len(agent_deploy_id_list) == 1):\n                if (self.token_info.agent_deploy_id != agent_deploy_id_list[0]):\n                    raise Exception(\"Service Account Token is not allowed to access only one agent_deploy_id\", self.token_info.agent_deploy_id)\n            else:\n                agent_deploy_id_list = [self.token_info.agent_deploy_id]\n\n\n        if (chamber_id_list == [] and agent_id_list == [] and agent_deploy_id_list == []):\n            raise Exception(\"chamber_id or agent_id or agent_deploy_id must be filled.\")\n\n        self.num_rows_acum = 0\n        self.num_rows = 0\n        self.continue_execution = True\n\n        self.execution_query_model = ExecutionQueryModel(\n            date_from=date_from,\n            date_to=date_to,\n            chamber_id_list=chamber_id_list,\n            agent_id_list=agent_id_list,\n            agent_deploy_id_list=agent_deploy_id_list,\n            user_id_list=user_id_list,\n            session_id_list=session_id_list,\n            channel_id_list=channel_id_list,\n            data_filter_list=data_filter_list,\n            eval_id_user=eval_id_user,\n            eval_id_internal=eval_id_internal,\n            eval_id_auto=eval_id_auto,\n            environment_id=environment_id,\n            is_test_plan=is_test_plan,\n            finished=finished,\n            limit=limit,\n            page_number=0,\n            include_tags=include_tags,\n            include_data=include_data,\n            include_errors=include_errors,\n            include_evals=include_evals\n        )\n\n    def __run_query(self) -&gt; ExecutionModel:\n        \"\"\"\n        Run Query, use self.execution_query_model\n        \"\"\"\n        enola_result = get_execution(execution_query_model=self.execution_query_model, connection=self.connection, raise_error_if_fail=self.raise_error_if_fail)\n\n        self.num_rows = len(enola_result.data)\n\n        self.continue_execution = False\n        if (self.num_rows == self.execution_query_model.limit and self.num_rows != 0):\n            self.continue_execution = True\n\n        self.num_rows_acum += self.num_rows\n\n        return enola_result\n\n    def __getitem__(self, key):\n        return self.__dict__[key]\n\n    def __getattr__(self, key):\n        return self.__dict__[key]\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/get_executions/#enola.get_executions.GetExecutions.__init__","title":"<code>__init__(token, raise_error_if_fail=True)</code>","text":"<p>Start Executions Execution</p> <p>token: jwt token, this is used to identify the agent, request from Admin App</p> Source code in <code>src\\enola\\get_executions.py</code> <pre><code>def __init__(self, token: str, raise_error_if_fail = True):\n    \"\"\"\n    Start Executions Execution\n\n    token: jwt token, this is used to identify the agent, request from Admin App\n    \"\"\"\n    self.raise_error_if_fail = raise_error_if_fail\n    self.num_rows_acum = 0\n    self.num_rows = 0\n    self.continue_execution = False\n    self.hf = HuemulFunctions()\n    #Connection data\n\n    #get token info\n    self.token_info = TokenInfo(token=token)\n\n    if (self.token_info.is_service_account == True and self.token_info.service_account_can_get_executions == False):\n        raise Exception(\"Service Account Token is not allowed to get executions\")\n\n    self.connection = Connect(AuthModel(jwt_token=token, url_service=self.token_info.service_account_url_backend, org_id=self.token_info.org_id))\n</code></pre>"},{"location":"reference/get_executions/#enola.get_executions.GetExecutions.__run_query","title":"<code>__run_query()</code>","text":"<p>Run Query, use self.execution_query_model</p> Source code in <code>src\\enola\\get_executions.py</code> <pre><code>def __run_query(self) -&gt; ExecutionModel:\n    \"\"\"\n    Run Query, use self.execution_query_model\n    \"\"\"\n    enola_result = get_execution(execution_query_model=self.execution_query_model, connection=self.connection, raise_error_if_fail=self.raise_error_if_fail)\n\n    self.num_rows = len(enola_result.data)\n\n    self.continue_execution = False\n    if (self.num_rows == self.execution_query_model.limit and self.num_rows != 0):\n        self.continue_execution = True\n\n    self.num_rows_acum += self.num_rows\n\n    return enola_result\n</code></pre>"},{"location":"reference/get_executions/#enola.get_executions.GetExecutions.query","title":"<code>query(date_from, date_to, chamber_id_list=[], agent_id_list=[], agent_deploy_id_list=[], user_id_list=[], session_id_list=[], channel_id_list=[], data_filter_list=[], eval_id_user=None, eval_id_internal=None, eval_id_auto=None, environment_id=None, is_test_plan=None, finished=None, limit=100, include_tags=False, include_data=False, include_errors=False, include_evals=False)</code>","text":"<p>Get Items by Chamber</p> <p>date_from: str, date from date_to: str, date to chamber_id: list, chamber id agent_id: list, agent id agent_deploy_id: list, agent deploy id user_id: list, user id session_id: list, session id channel_id: list, channel id data_filter: list, data filter eval_id_user: ExecutionEvalFilter, eval id user eval_id_internal: ExecutionEvalFilter, eval id internal eval_id_auto: ExecutionEvalFilter, eval id auto environment_id: Environtment, environment id is_test_plan: bool, is test plan finished: bool, finished limit: int, 100 is default limit include_tags: bool, include tags include_data: bool, include data include_errors: bool, include errors include_evals: bool, include evals</p> Source code in <code>src\\enola\\get_executions.py</code> <pre><code>def query(self, \n             date_from:str,\n             date_to:str,\n             chamber_id_list:list = [], \n             agent_id_list:list = [], \n             agent_deploy_id_list:list = [],\n             user_id_list:list = [],\n             session_id_list:list = [],\n             channel_id_list:list = [],\n             data_filter_list:list = [],\n             eval_id_user: ExecutionEvalFilter = None,\n             eval_id_internal: ExecutionEvalFilter = None,\n             eval_id_auto: ExecutionEvalFilter = None,\n             environment_id:Environtment = None,\n             is_test_plan: bool= None,\n             finished:bool = None,\n             limit:int=100, \n             include_tags:bool=False,\n             include_data:bool=False,\n             include_errors:bool=False,\n             include_evals:bool=False,\n             ) -&gt; ExecutionModel:\n    \"\"\"\n    Get Items by Chamber\n\n    date_from: str, date from\n    date_to: str, date to\n    chamber_id: list, chamber id\n    agent_id: list, agent id\n    agent_deploy_id: list, agent deploy id\n    user_id: list, user id\n    session_id: list, session id\n    channel_id: list, channel id\n    data_filter: list, data filter\n    eval_id_user: ExecutionEvalFilter, eval id user\n    eval_id_internal: ExecutionEvalFilter, eval id internal\n    eval_id_auto: ExecutionEvalFilter, eval id auto\n    environment_id: Environtment, environment id\n    is_test_plan: bool, is test plan\n    finished: bool, finished\n    limit: int, 100 is default limit\n    include_tags: bool, include tags\n    include_data: bool, include data\n    include_errors: bool, include errors\n    include_evals: bool, include evals\n    \"\"\"\n\n    if (self.token_info.agent_deploy_id != None and self.token_info.agent_deploy_id != \"\" and self.token_info.agent_deploy_id != \"0\"):\n        if (len(agent_deploy_id_list) &gt; 1):\n            raise Exception(\"Service Account Token is not allowed to access more than one agent_deploy_id\", self.token_info.agent_deploy_id)\n        if (len(agent_deploy_id_list) == 1):\n            if (self.token_info.agent_deploy_id != agent_deploy_id_list[0]):\n                raise Exception(\"Service Account Token is not allowed to access only one agent_deploy_id\", self.token_info.agent_deploy_id)\n        else:\n            agent_deploy_id_list = [self.token_info.agent_deploy_id]\n\n\n    if (chamber_id_list == [] and agent_id_list == [] and agent_deploy_id_list == []):\n        raise Exception(\"chamber_id or agent_id or agent_deploy_id must be filled.\")\n\n    self.num_rows_acum = 0\n    self.num_rows = 0\n    self.continue_execution = True\n\n    self.execution_query_model = ExecutionQueryModel(\n        date_from=date_from,\n        date_to=date_to,\n        chamber_id_list=chamber_id_list,\n        agent_id_list=agent_id_list,\n        agent_deploy_id_list=agent_deploy_id_list,\n        user_id_list=user_id_list,\n        session_id_list=session_id_list,\n        channel_id_list=channel_id_list,\n        data_filter_list=data_filter_list,\n        eval_id_user=eval_id_user,\n        eval_id_internal=eval_id_internal,\n        eval_id_auto=eval_id_auto,\n        environment_id=environment_id,\n        is_test_plan=is_test_plan,\n        finished=finished,\n        limit=limit,\n        page_number=0,\n        include_tags=include_tags,\n        include_data=include_data,\n        include_errors=include_errors,\n        include_evals=include_evals\n    )\n</code></pre>"},{"location":"reference/tracking/","title":"Tracking","text":""},{"location":"reference/tracking/#enola.tracking.Tracking","title":"<code>Tracking</code>","text":"<p>The <code>Tracking</code> class provides methods to start and manage execution tracking in the Enola system.</p> <p>This class allows you to:</p> <ul> <li>Initialize a tracking session.</li> <li>Add data received from or sent to the user.</li> <li>Register custom information, errors, warnings, and steps.</li> <li>Execute the tracking and send the data to the Enola server.</li> </ul> <p>Example usage:</p> <pre><code>tracking = Tracking(\n    token='your_jwt_token',\n    name='ExecutionName',\n    message_input='User input message',\n    app_id='App123',\n    user_id='User456',\n    is_test=False\n)\n</code></pre> Source code in <code>src\\enola\\tracking.py</code> <pre><code>class Tracking:\n    \"\"\"\n    The `Tracking` class provides methods to start and manage execution tracking in the Enola system.\n\n    This class allows you to:\n\n    - Initialize a tracking session.\n    - Add data received from or sent to the user.\n    - Register custom information, errors, warnings, and steps.\n    - Execute the tracking and send the data to the Enola server.\n\n    **Example usage:**\n\n    ```python\n    tracking = Tracking(\n        token='your_jwt_token',\n        name='ExecutionName',\n        message_input='User input message',\n        app_id='App123',\n        user_id='User456',\n        is_test=False\n    )\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        token: str,\n        name: str,\n        app_id: Optional[str] = None,\n        user_id: Optional[str] = None,\n        session_id: Optional[str] = None,\n        channel_id: Optional[str] = None,\n        ip: Optional[str] = None,\n        external_id: Optional[str] = None,\n        is_test: bool = False,\n        message_input: str = \"\",\n        enola_id_prev: str = \"\",\n        app_name: str = \"\",\n        user_name: str = \"\",\n        session_name: str = \"\",\n        channel_name: str = \"\",\n        client_id: str = \"\",\n        product_id: str = \"\",\n    ):\n        \"\"\"\n        Initializes a new `Tracking` instance to start tracking an execution.\n\n        Args:\n            token (str): JWT token used to identify the agent (request from Admin App).\n            name (str): Name of this execution.\n            app_id (str, optional): ID of the app that is calling.\n            user_id (str, optional): External user ID.\n            session_id (str, optional): ID of the user or application's session.\n            channel_id (str, optional): Communication channel (e.g., 'web', 'chat', 'whatsapp').\n            ip (str, optional): IP address of the user or application.\n            external_id (str, optional): External unique record identifier.\n            is_test (bool, optional): True if this call is for testing purposes.\n            message_input (str, optional): Message received from the user or to explain the execution.\n            enola_id_prev (str, optional): ID of the previous call to link agent sequences.\n            app_name (str, optional): Name of the app.\n            user_name (str, optional): Name of the user.\n            session_name (str, optional): Name of the session.\n            channel_name (str, optional): Name of the channel.\n            client_id (str, optional): Client ID.\n            product_id (str, optional): Product ID.\n        \"\"\"\n        self.name = name\n        self.enola_id_prev = enola_id_prev\n        self.enola_id = \"\"  # Obtained after execution\n        self.agent_deploy_id = \"\"\n        self.message_input = message_input\n        self.message_output = \"\"\n        self.num_iteratons = 0\n        self.hf = HuemulFunctions()\n        self.url_evaluation_post = None\n        self.url_evaluation_def_get = None\n\n        # This execution information\n        self.tracking_status = \"\"\n        # Connection data\n\n        # Decode JWT token\n        self.token_info = TokenInfo(token=token)\n\n        if not self.token_info.is_service_account:\n            raise Exception(\n                \"This token is not a service account. Only service accounts can execute tracking\"\n            )\n\n        if not self.token_info.agent_deploy_id:\n            raise Exception(\"agentDeployId is empty.\")\n\n        if not self.token_info.service_account_can_tracking:\n            raise Exception(\"This service account can't execute tracking\")\n\n        self.agent_deploy_id = self.token_info.agent_deploy_id\n        self.connection = Connect(\n            AuthModel(\n                jwt_token=token,\n                url_service=self.token_info.service_account_url,\n                org_id=self.token_info.org_id,\n            )\n        )\n\n        # User information\n        self.enola_sender = EnolaSenderModel(\n            app_id=app_id,\n            batch_id=None,\n            app_name=app_name,\n            user_id=user_id,\n            user_name=user_name,\n            session_id=session_id,\n            session_name=session_name,\n            channel_id=channel_id,\n            channel_name=channel_name,\n            ip=ip,\n            external_id=external_id,\n            client_id=client_id,\n            product_id=product_id,\n        )\n\n        # If is empty or not exist assign false\n        self.is_test = is_test\n\n        # Save steps and information\n        self.step_list: List[Step] = []\n        self.steps = 0\n        self.first_step = self.new_step(self.name, message_input=self.message_input)\n\n    ########################################################################################\n    ###############    A G E N T   M E T H O D S     #######################################\n    ########################################################################################\n\n    def add_data_received(self, name: str, data: Any, type: DataType) -&gt; None:\n        \"\"\"\n        Adds data received from the user.\n\n        Args:\n            name (str): The name of the data.\n            data (Any): The data content.\n            type (DataType): The type of data received.\n        \"\"\"\n        self.first_step.agent_data_list.append(\n            DataListModel(\n                value=data, name=name, data_type=type, kind=KindType.RECEIVER\n            )\n        )\n\n    def add_data_send(self, name: str, data: Any, type: DataType) -&gt; None:\n        \"\"\"\n        Adds data to send to the user.\n\n        Args:\n            name (str): The name of the data.\n            data (Any): The data content.\n            type (DataType): The type of data being sent.\n        \"\"\"\n        self.first_step.agent_data_list.append(\n            DataListModel(value=data, name=name, data_type=type, kind=KindType.SENDER)\n        )\n\n    def add_custom_info(self, key: str, value: Any) -&gt; None:\n        \"\"\"\n        Adds custom information to tracking.\n\n        Args:\n            key (str): The key for the custom information.\n            value (Any): The value associated with the key.\n        \"\"\"\n        self.first_step.info_list.append(Info(key, value))\n\n    def add_file_link(\n        self, name: str, url: str, type: str, size_kb: int\n    ) -&gt; None:\n        \"\"\"\n        Adds a file link to tracking.\n\n        Args:\n            name (str): The name of the file.\n            url (str): The URL of the file.\n            type (str): The type of the file.\n            size_kb (int): The size of the file in kilobytes.\n        \"\"\"\n        self.first_step.add_file_link(\n            name=name, url=url, type=type, size_kb=size_kb\n        )\n\n    def add_tag(self, key: str, value: Any) -&gt; None:\n        \"\"\"\n        Adds a tag to tracking, this tag is used to search in Enola App.\n\n        Args:\n            key (str): The tag key.\n            value (Any): The tag value.\n        \"\"\"\n        self.first_step.add_tag(key=key, value=value)\n\n    def add_extra_info(self, key: str, value: Any) -&gt; None:\n        \"\"\"\n        Adds extra information to tracking, this can be used to test or debug.\n\n        Args:\n            key (str): The key for the extra information.\n            value (Any): The value associated with the key.\n        \"\"\"\n        self.first_step.add_extra_info(key=key, value=value)\n\n    def add_error(self, id: str, message: str, kind: ErrOrWarnKind) -&gt; None:\n        \"\"\"\n        Registers an error to tracking.\n\n        Args:\n            id (str): The error identifier.\n            message (str): The error message.\n            kind (ErrOrWarnKind): The kind of error.\n        \"\"\"\n        self.first_step.add_error(id=id, message=message, kind=kind)\n\n    def add_warning(self, id: str, message: str, kind: ErrOrWarnKind) -&gt; None:\n        \"\"\"\n        Registers a warning to tracking.\n\n        Args:\n            id (str): The warning identifier.\n            message (str): The warning message.\n            kind (ErrOrWarnKind): The kind of warning.\n        \"\"\"\n        self.first_step.add_warning(id=id, message=message, kind=kind)\n\n    def execute(\n        self,\n        successfull: bool,\n        message_output: str = \"\",\n        num_iteratons: int = 0,\n        score_value: float = 0,\n        score_group: str = \"\",\n        score_cluster: str = \"\",\n        score_date: str = \"\",\n        external_id: str = \"\",\n    ) -&gt; bool:\n        \"\"\"\n        Registers tracking in the Enola server.\n\n        Args:\n            successfull (bool): True for your Agent execution OK, false for error in your Agent execution.\n            message_output (str, optional): Message to user or to explain the execution results.\n            num_iteratons (int, optional): Number of iterations.\n            score_value (float, optional): Score value.\n            score_group (str, optional): Score group.\n            score_cluster (str, optional): Score cluster.\n            score_date (str, optional): Date of score in ISO &amp; UTC format (e.g., 'yyyy-MM-ddTHH:mm:ss:SSSz'). Empty for current date.\n            external_id (str, optional): External unique identifier.\n\n        Returns:\n            bool: True if execution was successful, False otherwise.\n        \"\"\"\n        self.first_step.num_iterations = num_iteratons\n        if external_id != \"\":\n            self.enola_sender.external_id = external_id\n\n        self.close_step_others(\n            step=self.first_step,\n            successfull=successfull,\n            others_cost=0,\n            step_id=\"AGENT\",\n            message_output=message_output,\n        )\n        self.first_step.set_score(\n            value=score_value, group=score_group, cluster=score_cluster, date=score_date\n        )\n\n        # Register in server\n        print(f\"{self.name}: sending to server... \")\n        tracking_model = TrackingModel(\n            enola_id_prev=self.enola_id_prev,\n            enola_sender=self.enola_sender,\n            isTest=self.is_test,\n            step_list=self.step_list,\n            steps=self.steps,\n        )\n\n        enola_result = create_tracking(\n            tracking_model=tracking_model,\n            connection=self.connection,\n            raise_error_if_fail=True,\n        )\n        # Show results\n        if enola_result.successfull:\n            # Obtain Enola ID and evaluation URLs\n            self.enola_id = enola_result.enola_id\n            self.agent_deploy_id = enola_result.agent_deploy_id\n            self.url_evaluation_post = enola_result.url_evaluation_post\n            self.url_evaluation_def_get = enola_result.url_evaluation_def_get\n\n            print(f\"{self.name}: finish OK! \")\n\n            return True\n        else:\n            print(f\"{self.name}: finish with error: {enola_result.message}\")\n            self.tracking_status = enola_result.message\n\n            return False\n\n    ########################################################################################\n    ###############    S T E P   I N F O     ###############################################\n    ########################################################################################\n\n    def new_step(self, name: str, message_input: str = \"\") -&gt; Step:\n        \"\"\"\n        Starts a new step.\n\n        Args:\n            name (str): Name of this step.\n            message_input (str, optional): Message received from user or to explain the execution.\n\n        Returns:\n            Step: The newly created step object.\n        \"\"\"\n        self.steps += 1\n        return Step(name=name, message_input=message_input)\n\n    def close_step_token(\n        self,\n        step: Step,\n        successfull: bool,\n        message_output: str = \"\",\n        token_input_num: int = 0,\n        token_output_num: int = 0,\n        token_total_num: int = 0,\n        token_input_cost: float = 0,\n        token_output_cost: float = 0,\n        token_total_cost: float = 0,\n        enola_id: str = \"\",\n        agent_deploy_id: str = \"\",\n        step_id: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Closes a step with token information.\n\n        Args:\n            step (Step): The step to close.\n            successfull (bool): True if the step was successful, False otherwise.\n            message_output (str, optional): Message to user or to explain the execution results.\n            token_input_num (int, optional): Number of input tokens.\n            token_output_num (int, optional): Number of output tokens.\n            token_total_num (int, optional): Total number of tokens.\n            token_input_cost (float, optional): Cost of input tokens.\n            token_output_cost (float, optional): Cost of output tokens.\n            token_total_cost (float, optional): Total cost of tokens.\n            enola_id (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n            agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n            step_id (str, optional): ID of this step, you can use it to link with external calls.\n        \"\"\"\n        step.enola_id = enola_id\n        step.agent_deploy_id = agent_deploy_id\n        step.step_id = step_id\n        step.message_output = message_output\n        step.step_type = StepType.TOKEN\n        step.token.token_input = token_input_num\n        step.token.token_output = token_output_num\n        step.token.token_total = token_total_num\n        step.cost.token_input = token_input_cost\n        step.cost.token_output = token_output_cost\n        step.cost.token_total = token_total_cost\n\n        step.date_end = self.hf.get_date_for_api()\n        step.duration_in_ms = self.hf.get_dif_ms(\n            step.date_start, step.date_end\n        )\n        step.successfull = successfull\n\n        self.step_list.append(step)\n\n    # Similar methods for close_step_video, close_step_audio, close_step_image, close_step_doc, close_step_others, close_step_score can be updated similarly.\n\n    def __str__(self) -&gt; str:\n        return f\"Agent/Model: {self.name}, Steps: {self.steps}\"\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def __getattr__(self, key: str) -&gt; Any:\n        return self.__dict__[key]\n\n    def get(self, key: str, default: Optional[Any] = None) -&gt; Any:\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.__init__","title":"<code>__init__(token, name, app_id=None, user_id=None, session_id=None, channel_id=None, ip=None, external_id=None, is_test=False, message_input='', enola_id_prev='', app_name='', user_name='', session_name='', channel_name='', client_id='', product_id='')</code>","text":"<p>Initializes a new <code>Tracking</code> instance to start tracking an execution.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>JWT token used to identify the agent (request from Admin App).</p> required <code>name</code> <code>str</code> <p>Name of this execution.</p> required <code>app_id</code> <code>str</code> <p>ID of the app that is calling.</p> <code>None</code> <code>user_id</code> <code>str</code> <p>External user ID.</p> <code>None</code> <code>session_id</code> <code>str</code> <p>ID of the user or application's session.</p> <code>None</code> <code>channel_id</code> <code>str</code> <p>Communication channel (e.g., 'web', 'chat', 'whatsapp').</p> <code>None</code> <code>ip</code> <code>str</code> <p>IP address of the user or application.</p> <code>None</code> <code>external_id</code> <code>str</code> <p>External unique record identifier.</p> <code>None</code> <code>is_test</code> <code>bool</code> <p>True if this call is for testing purposes.</p> <code>False</code> <code>message_input</code> <code>str</code> <p>Message received from the user or to explain the execution.</p> <code>''</code> <code>enola_id_prev</code> <code>str</code> <p>ID of the previous call to link agent sequences.</p> <code>''</code> <code>app_name</code> <code>str</code> <p>Name of the app.</p> <code>''</code> <code>user_name</code> <code>str</code> <p>Name of the user.</p> <code>''</code> <code>session_name</code> <code>str</code> <p>Name of the session.</p> <code>''</code> <code>channel_name</code> <code>str</code> <p>Name of the channel.</p> <code>''</code> <code>client_id</code> <code>str</code> <p>Client ID.</p> <code>''</code> <code>product_id</code> <code>str</code> <p>Product ID.</p> <code>''</code> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def __init__(\n    self,\n    token: str,\n    name: str,\n    app_id: Optional[str] = None,\n    user_id: Optional[str] = None,\n    session_id: Optional[str] = None,\n    channel_id: Optional[str] = None,\n    ip: Optional[str] = None,\n    external_id: Optional[str] = None,\n    is_test: bool = False,\n    message_input: str = \"\",\n    enola_id_prev: str = \"\",\n    app_name: str = \"\",\n    user_name: str = \"\",\n    session_name: str = \"\",\n    channel_name: str = \"\",\n    client_id: str = \"\",\n    product_id: str = \"\",\n):\n    \"\"\"\n    Initializes a new `Tracking` instance to start tracking an execution.\n\n    Args:\n        token (str): JWT token used to identify the agent (request from Admin App).\n        name (str): Name of this execution.\n        app_id (str, optional): ID of the app that is calling.\n        user_id (str, optional): External user ID.\n        session_id (str, optional): ID of the user or application's session.\n        channel_id (str, optional): Communication channel (e.g., 'web', 'chat', 'whatsapp').\n        ip (str, optional): IP address of the user or application.\n        external_id (str, optional): External unique record identifier.\n        is_test (bool, optional): True if this call is for testing purposes.\n        message_input (str, optional): Message received from the user or to explain the execution.\n        enola_id_prev (str, optional): ID of the previous call to link agent sequences.\n        app_name (str, optional): Name of the app.\n        user_name (str, optional): Name of the user.\n        session_name (str, optional): Name of the session.\n        channel_name (str, optional): Name of the channel.\n        client_id (str, optional): Client ID.\n        product_id (str, optional): Product ID.\n    \"\"\"\n    self.name = name\n    self.enola_id_prev = enola_id_prev\n    self.enola_id = \"\"  # Obtained after execution\n    self.agent_deploy_id = \"\"\n    self.message_input = message_input\n    self.message_output = \"\"\n    self.num_iteratons = 0\n    self.hf = HuemulFunctions()\n    self.url_evaluation_post = None\n    self.url_evaluation_def_get = None\n\n    # This execution information\n    self.tracking_status = \"\"\n    # Connection data\n\n    # Decode JWT token\n    self.token_info = TokenInfo(token=token)\n\n    if not self.token_info.is_service_account:\n        raise Exception(\n            \"This token is not a service account. Only service accounts can execute tracking\"\n        )\n\n    if not self.token_info.agent_deploy_id:\n        raise Exception(\"agentDeployId is empty.\")\n\n    if not self.token_info.service_account_can_tracking:\n        raise Exception(\"This service account can't execute tracking\")\n\n    self.agent_deploy_id = self.token_info.agent_deploy_id\n    self.connection = Connect(\n        AuthModel(\n            jwt_token=token,\n            url_service=self.token_info.service_account_url,\n            org_id=self.token_info.org_id,\n        )\n    )\n\n    # User information\n    self.enola_sender = EnolaSenderModel(\n        app_id=app_id,\n        batch_id=None,\n        app_name=app_name,\n        user_id=user_id,\n        user_name=user_name,\n        session_id=session_id,\n        session_name=session_name,\n        channel_id=channel_id,\n        channel_name=channel_name,\n        ip=ip,\n        external_id=external_id,\n        client_id=client_id,\n        product_id=product_id,\n    )\n\n    # If is empty or not exist assign false\n    self.is_test = is_test\n\n    # Save steps and information\n    self.step_list: List[Step] = []\n    self.steps = 0\n    self.first_step = self.new_step(self.name, message_input=self.message_input)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_custom_info","title":"<code>add_custom_info(key, value)</code>","text":"<p>Adds custom information to tracking.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the custom information.</p> required <code>value</code> <code>Any</code> <p>The value associated with the key.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_custom_info(self, key: str, value: Any) -&gt; None:\n    \"\"\"\n    Adds custom information to tracking.\n\n    Args:\n        key (str): The key for the custom information.\n        value (Any): The value associated with the key.\n    \"\"\"\n    self.first_step.info_list.append(Info(key, value))\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_data_received","title":"<code>add_data_received(name, data, type)</code>","text":"<p>Adds data received from the user.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data.</p> required <code>data</code> <code>Any</code> <p>The data content.</p> required <code>type</code> <code>DataType</code> <p>The type of data received.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_data_received(self, name: str, data: Any, type: DataType) -&gt; None:\n    \"\"\"\n    Adds data received from the user.\n\n    Args:\n        name (str): The name of the data.\n        data (Any): The data content.\n        type (DataType): The type of data received.\n    \"\"\"\n    self.first_step.agent_data_list.append(\n        DataListModel(\n            value=data, name=name, data_type=type, kind=KindType.RECEIVER\n        )\n    )\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_data_send","title":"<code>add_data_send(name, data, type)</code>","text":"<p>Adds data to send to the user.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data.</p> required <code>data</code> <code>Any</code> <p>The data content.</p> required <code>type</code> <code>DataType</code> <p>The type of data being sent.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_data_send(self, name: str, data: Any, type: DataType) -&gt; None:\n    \"\"\"\n    Adds data to send to the user.\n\n    Args:\n        name (str): The name of the data.\n        data (Any): The data content.\n        type (DataType): The type of data being sent.\n    \"\"\"\n    self.first_step.agent_data_list.append(\n        DataListModel(value=data, name=name, data_type=type, kind=KindType.SENDER)\n    )\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_error","title":"<code>add_error(id, message, kind)</code>","text":"<p>Registers an error to tracking.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The error identifier.</p> required <code>message</code> <code>str</code> <p>The error message.</p> required <code>kind</code> <code>ErrOrWarnKind</code> <p>The kind of error.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_error(self, id: str, message: str, kind: ErrOrWarnKind) -&gt; None:\n    \"\"\"\n    Registers an error to tracking.\n\n    Args:\n        id (str): The error identifier.\n        message (str): The error message.\n        kind (ErrOrWarnKind): The kind of error.\n    \"\"\"\n    self.first_step.add_error(id=id, message=message, kind=kind)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_extra_info","title":"<code>add_extra_info(key, value)</code>","text":"<p>Adds extra information to tracking, this can be used to test or debug.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the extra information.</p> required <code>value</code> <code>Any</code> <p>The value associated with the key.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_extra_info(self, key: str, value: Any) -&gt; None:\n    \"\"\"\n    Adds extra information to tracking, this can be used to test or debug.\n\n    Args:\n        key (str): The key for the extra information.\n        value (Any): The value associated with the key.\n    \"\"\"\n    self.first_step.add_extra_info(key=key, value=value)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_file_link","title":"<code>add_file_link(name, url, type, size_kb)</code>","text":"<p>Adds a file link to tracking.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the file.</p> required <code>url</code> <code>str</code> <p>The URL of the file.</p> required <code>type</code> <code>str</code> <p>The type of the file.</p> required <code>size_kb</code> <code>int</code> <p>The size of the file in kilobytes.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_file_link(\n    self, name: str, url: str, type: str, size_kb: int\n) -&gt; None:\n    \"\"\"\n    Adds a file link to tracking.\n\n    Args:\n        name (str): The name of the file.\n        url (str): The URL of the file.\n        type (str): The type of the file.\n        size_kb (int): The size of the file in kilobytes.\n    \"\"\"\n    self.first_step.add_file_link(\n        name=name, url=url, type=type, size_kb=size_kb\n    )\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_tag","title":"<code>add_tag(key, value)</code>","text":"<p>Adds a tag to tracking, this tag is used to search in Enola App.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The tag key.</p> required <code>value</code> <code>Any</code> <p>The tag value.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_tag(self, key: str, value: Any) -&gt; None:\n    \"\"\"\n    Adds a tag to tracking, this tag is used to search in Enola App.\n\n    Args:\n        key (str): The tag key.\n        value (Any): The tag value.\n    \"\"\"\n    self.first_step.add_tag(key=key, value=value)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.add_warning","title":"<code>add_warning(id, message, kind)</code>","text":"<p>Registers a warning to tracking.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The warning identifier.</p> required <code>message</code> <code>str</code> <p>The warning message.</p> required <code>kind</code> <code>ErrOrWarnKind</code> <p>The kind of warning.</p> required Source code in <code>src\\enola\\tracking.py</code> <pre><code>def add_warning(self, id: str, message: str, kind: ErrOrWarnKind) -&gt; None:\n    \"\"\"\n    Registers a warning to tracking.\n\n    Args:\n        id (str): The warning identifier.\n        message (str): The warning message.\n        kind (ErrOrWarnKind): The kind of warning.\n    \"\"\"\n    self.first_step.add_warning(id=id, message=message, kind=kind)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.close_step_token","title":"<code>close_step_token(step, successfull, message_output='', token_input_num=0, token_output_num=0, token_total_num=0, token_input_cost=0, token_output_cost=0, token_total_cost=0, enola_id='', agent_deploy_id='', step_id='')</code>","text":"<p>Closes a step with token information.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>Step</code> <p>The step to close.</p> required <code>successfull</code> <code>bool</code> <p>True if the step was successful, False otherwise.</p> required <code>message_output</code> <code>str</code> <p>Message to user or to explain the execution results.</p> <code>''</code> <code>token_input_num</code> <code>int</code> <p>Number of input tokens.</p> <code>0</code> <code>token_output_num</code> <code>int</code> <p>Number of output tokens.</p> <code>0</code> <code>token_total_num</code> <code>int</code> <p>Total number of tokens.</p> <code>0</code> <code>token_input_cost</code> <code>float</code> <p>Cost of input tokens.</p> <code>0</code> <code>token_output_cost</code> <code>float</code> <p>Cost of output tokens.</p> <code>0</code> <code>token_total_cost</code> <code>float</code> <p>Total cost of tokens.</p> <code>0</code> <code>enola_id</code> <code>str</code> <p>If this step was a call to another Enola agent, this is the ID of that agent.</p> <code>''</code> <code>agent_deploy_id</code> <code>str</code> <p>Include this if you want to link this step to another agent of another company.</p> <code>''</code> <code>step_id</code> <code>str</code> <p>ID of this step, you can use it to link with external calls.</p> <code>''</code> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def close_step_token(\n    self,\n    step: Step,\n    successfull: bool,\n    message_output: str = \"\",\n    token_input_num: int = 0,\n    token_output_num: int = 0,\n    token_total_num: int = 0,\n    token_input_cost: float = 0,\n    token_output_cost: float = 0,\n    token_total_cost: float = 0,\n    enola_id: str = \"\",\n    agent_deploy_id: str = \"\",\n    step_id: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Closes a step with token information.\n\n    Args:\n        step (Step): The step to close.\n        successfull (bool): True if the step was successful, False otherwise.\n        message_output (str, optional): Message to user or to explain the execution results.\n        token_input_num (int, optional): Number of input tokens.\n        token_output_num (int, optional): Number of output tokens.\n        token_total_num (int, optional): Total number of tokens.\n        token_input_cost (float, optional): Cost of input tokens.\n        token_output_cost (float, optional): Cost of output tokens.\n        token_total_cost (float, optional): Total cost of tokens.\n        enola_id (str, optional): If this step was a call to another Enola agent, this is the ID of that agent.\n        agent_deploy_id (str, optional): Include this if you want to link this step to another agent of another company.\n        step_id (str, optional): ID of this step, you can use it to link with external calls.\n    \"\"\"\n    step.enola_id = enola_id\n    step.agent_deploy_id = agent_deploy_id\n    step.step_id = step_id\n    step.message_output = message_output\n    step.step_type = StepType.TOKEN\n    step.token.token_input = token_input_num\n    step.token.token_output = token_output_num\n    step.token.token_total = token_total_num\n    step.cost.token_input = token_input_cost\n    step.cost.token_output = token_output_cost\n    step.cost.token_total = token_total_cost\n\n    step.date_end = self.hf.get_date_for_api()\n    step.duration_in_ms = self.hf.get_dif_ms(\n        step.date_start, step.date_end\n    )\n    step.successfull = successfull\n\n    self.step_list.append(step)\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.execute","title":"<code>execute(successfull, message_output='', num_iteratons=0, score_value=0, score_group='', score_cluster='', score_date='', external_id='')</code>","text":"<p>Registers tracking in the Enola server.</p> <p>Parameters:</p> Name Type Description Default <code>successfull</code> <code>bool</code> <p>True for your Agent execution OK, false for error in your Agent execution.</p> required <code>message_output</code> <code>str</code> <p>Message to user or to explain the execution results.</p> <code>''</code> <code>num_iteratons</code> <code>int</code> <p>Number of iterations.</p> <code>0</code> <code>score_value</code> <code>float</code> <p>Score value.</p> <code>0</code> <code>score_group</code> <code>str</code> <p>Score group.</p> <code>''</code> <code>score_cluster</code> <code>str</code> <p>Score cluster.</p> <code>''</code> <code>score_date</code> <code>str</code> <p>Date of score in ISO &amp; UTC format (e.g., 'yyyy-MM-ddTHH:mm:ss:SSSz'). Empty for current date.</p> <code>''</code> <code>external_id</code> <code>str</code> <p>External unique identifier.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if execution was successful, False otherwise.</p> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def execute(\n    self,\n    successfull: bool,\n    message_output: str = \"\",\n    num_iteratons: int = 0,\n    score_value: float = 0,\n    score_group: str = \"\",\n    score_cluster: str = \"\",\n    score_date: str = \"\",\n    external_id: str = \"\",\n) -&gt; bool:\n    \"\"\"\n    Registers tracking in the Enola server.\n\n    Args:\n        successfull (bool): True for your Agent execution OK, false for error in your Agent execution.\n        message_output (str, optional): Message to user or to explain the execution results.\n        num_iteratons (int, optional): Number of iterations.\n        score_value (float, optional): Score value.\n        score_group (str, optional): Score group.\n        score_cluster (str, optional): Score cluster.\n        score_date (str, optional): Date of score in ISO &amp; UTC format (e.g., 'yyyy-MM-ddTHH:mm:ss:SSSz'). Empty for current date.\n        external_id (str, optional): External unique identifier.\n\n    Returns:\n        bool: True if execution was successful, False otherwise.\n    \"\"\"\n    self.first_step.num_iterations = num_iteratons\n    if external_id != \"\":\n        self.enola_sender.external_id = external_id\n\n    self.close_step_others(\n        step=self.first_step,\n        successfull=successfull,\n        others_cost=0,\n        step_id=\"AGENT\",\n        message_output=message_output,\n    )\n    self.first_step.set_score(\n        value=score_value, group=score_group, cluster=score_cluster, date=score_date\n    )\n\n    # Register in server\n    print(f\"{self.name}: sending to server... \")\n    tracking_model = TrackingModel(\n        enola_id_prev=self.enola_id_prev,\n        enola_sender=self.enola_sender,\n        isTest=self.is_test,\n        step_list=self.step_list,\n        steps=self.steps,\n    )\n\n    enola_result = create_tracking(\n        tracking_model=tracking_model,\n        connection=self.connection,\n        raise_error_if_fail=True,\n    )\n    # Show results\n    if enola_result.successfull:\n        # Obtain Enola ID and evaluation URLs\n        self.enola_id = enola_result.enola_id\n        self.agent_deploy_id = enola_result.agent_deploy_id\n        self.url_evaluation_post = enola_result.url_evaluation_post\n        self.url_evaluation_def_get = enola_result.url_evaluation_def_get\n\n        print(f\"{self.name}: finish OK! \")\n\n        return True\n    else:\n        print(f\"{self.name}: finish with error: {enola_result.message}\")\n        self.tracking_status = enola_result.message\n\n        return False\n</code></pre>"},{"location":"reference/tracking/#enola.tracking.Tracking.new_step","title":"<code>new_step(name, message_input='')</code>","text":"<p>Starts a new step.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of this step.</p> required <code>message_input</code> <code>str</code> <p>Message received from user or to explain the execution.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>Step</code> <code>Step</code> <p>The newly created step object.</p> Source code in <code>src\\enola\\tracking.py</code> <pre><code>def new_step(self, name: str, message_input: str = \"\") -&gt; Step:\n    \"\"\"\n    Starts a new step.\n\n    Args:\n        name (str): Name of this step.\n        message_input (str, optional): Message received from user or to explain the execution.\n\n    Returns:\n        Step: The newly created step object.\n    \"\"\"\n    self.steps += 1\n    return Step(name=name, message_input=message_input)\n</code></pre>"},{"location":"reference/tracking_batch/","title":"Tracking Batch","text":""},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch","title":"<code>TrackingBatch</code>","text":"Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>class TrackingBatch:\n    def __init__(self, \n                 token, \n                 name, \n                 dataframe, \n                 period: str, \n                 client_id_column_name:str, \n                 product_id_column_name:str, \n                 score_value_column_name: str, \n                 score_group_column_name:str, \n                 score_cluster_column_name:str,  \n                 channel_id_column_name:str=None,\n                 channel_name_column_name:str=None,\n                 session_id_column_name:str=None,\n                 session_name_column_name:str=None,\n                 user_id_column_name:str=None,\n                 user_name_column_name:str=None,\n                 app_id_column_name:str=None,\n                 app_name_column_name:str=None,\n                 ip_column_name:str=None,\n                 external_id_column_name:str=None,\n                 app_id=None, \n                 app_name:str=\"\",\n                 user_id=None, \n                 user_name:str=\"\", \n                 session_id=None, \n                 session_name:str=\"\", \n                 channel_id=None, \n                 channel_name:str=\"\", \n                 ip=None, \n                 is_test=False):\n        \"\"\"\n        Start tracking Batch Execution\n\n        token: jwt token, this is used to identify the agent, request from Admin App\n        name: name of this execution\n        dataframe: dataframe to track\n        period: period of this execution in iso-format (2021-01-01T00:00:00Z)\n        client_id_column_name: name of column with client id\n        product_id_column_name: name of column with product id\n        score_value_column_name: name of column with score value\n        score_group_column_name: name of column with score group\n        score_cluster_column_name: name of column with score cluster\n        channel_id_column_name: name of column with channel id\n        channel_name_column_name: name of column with channel name\n        session_id_column_name: name of column with session id\n        session_name_column_name: name of column with session name\n        user_id_column_name: name of column with user id\n        user_name_column_name: name of column with user name\n        app_id_column_name: name of column with app id\n        app_name_column_name: name of column with app name\n        ip_column_name: name of column with ip\n        app_id: id of app, this is used to identify the app who is calling\n        app_name: name of app, this is used to identify the app who is calling\n        user_id: id of external user, this is used to identify the user who is calling\n        user_name: name of external user, this is used to identify the user who is calling\n        session_id: id of session of user or application, this is used to identify the session who is calling\n        session_name: name of session of user or application, this is used to identify the session who is calling\n        channel_id: web, chat, whatsapp, etc, this is used to identify the channel who is calling\n        channel_name: web, chat, whatsapp, etc, this is used to identify the channel who is calling\n        ip: ip of user or application, this is used to identify the ip who is calling\n        is_test: true if this call is for testing purposes\n        \"\"\"\n        self.name = name\n        self.hf = HuemulFunctions()\n        self.dataframe = dataframe\n        self.client_id_column_name = client_id_column_name\n        self.product_id_column_name = product_id_column_name\n        self.score_value_column_name = score_value_column_name\n        self.score_group_column_name = score_group_column_name\n        self.score_cluster_column_name = score_cluster_column_name\n        self.channel_id_column_name = channel_id_column_name\n        self.channel_name_column_name = channel_name_column_name\n        self.session_id_column_name = session_id_column_name\n        self.session_name_column_name = session_name_column_name\n        self.user_id_column_name = user_id_column_name\n        self.user_name_column_name = user_name_column_name\n        self.app_id_column_name = app_id_column_name\n        self.app_name_column_name = app_name_column_name\n        self.ip_column_name = ip_column_name\n        self.external_id_column_name = external_id_column_name\n        self.period = period\n\n\n        if (dataframe is None):\n            raise Exception(\"dataframe is empty\")\n        if (len(dataframe) == 0):\n            raise Exception(\"dataframe is empty (len 0)\")\n        if (score_value_column_name is None):\n            raise Exception(\"score_value_column_name is empty\")\n        if (score_value_column_name == \"\" and score_group_column_name == \"\" and score_cluster_column_name == \"\"):\n            raise Exception(\"some of score_value_column_name, score_group_column_name or score_cluster_column_name must be filled\")\n        if (period is None):\n            raise Exception(\"period is empty\")\n        if (period == \"\"):\n            raise Exception(\"period is empty\")\n\n        #decodificar jwt\n        self.token_info = TokenInfo(token=token)\n\n        if (self.token_info.is_service_account == False):\n            raise Exception(\"This token is not a service account. Only service accounts can execute tracking\")\n\n        if not self.token_info.agent_deploy_id:\n            raise Exception(\"agentDeployId is empty.\")\n\n        if (self.token_info.service_account_can_tracking == False):\n            raise Exception(\"This service account can't execute tracking\")\n\n\n        self.agent_deploy_id = self.token_info.agent_deploy_id\n        self.connection = Connect(AuthModel(jwt_token=token, url_service=self.token_info.service_account_url_backend, org_id=self.token_info.org_id))\n\n        #user information\n        self.enola_sender = EnolaSenderModel(\n            app_id=app_id, \n            app_name=app_name, \n            user_id=user_id, \n            user_name=user_name, \n            session_id=session_id, \n            session_name=session_name, \n            channel_id=channel_id, \n            channel_name=channel_name, \n            ip=ip, \n            external_id=\"\", \n            batch_id=\"\",\n            client_id=\"\",\n            product_id=\"\",\n            )\n\n        #if is empty or not exist assign false\n        self.is_test = is_test\n\n        #save steps and informations\n        self.batch_id = \"\"\n\n    ########################################################################################\n    ###############    A G E N T   M E T H O D S     #######################################\n    ########################################################################################\n\n\n    def add_data_received(self, name:str, data, type:DataType):\n        \"\"\"\n        add data received from user\n        \"\"\"\n        self.first_step.agent_data_list.append(DataListModel(value=data, name=name, data_type=type, kind=KindType.RECEIVER)) \n\n    def add_data_send(self, name:str, data, type:DataType):\n        \"\"\"\n        add data to send to user\n        \"\"\"\n        self.first_step.agent_data_list.append(DataListModel(value=data, name=name, data_type=type, kind=KindType.SENDER)) \n\n    def add_custom_info(self, key, value):\n        \"\"\"\n        add custom information to tracking\n        \"\"\"\n        self.first_step.info_list.append(Info(key, value))\n\n    def add_tag(self, key: str, value):\n        \"\"\"\n        add tag to tracking, this tag is used to search in Enola App\n        \"\"\"\n        self.first_step.add_tag(key=key, value=value)\n\n    def add_extra_info(self, key: str, value):\n        \"\"\"\n        add extra information to tracking, this can be used to test or debug\n        \"\"\"\n        self.first_step.add_extra_info(key=key, value=value)\n\n    def add_error(self, id: str, message: str, kind: ErrOrWarnKind):\n        \"\"\"\n        register error to tracking\n        \"\"\"\n        self.first_step.add_error(id=id, message=message, kind=kind)\n\n    def add_warning(self, id: str, message: str, kind: ErrOrWarnKind):\n        \"\"\"\n        register warning to tracking\n        \"\"\"\n        self.first_step.add_warning(id=id, message=message, kind=kind)\n\n\n    def execute(self, batch_size=200) -&gt; List[TrackingResponseModel]:\n        \"\"\"\n        register tracking batch in Enola server\n        \"\"\"\n\n        #create batch\n        if (self.batch_id == \"\"):\n            print(f'{self.name}: sending to server, create Batch... ')\n            tracking_batch_model = TrackingBatchHeadModel(\n                enola_sender=self.enola_sender, \n                period=self.period,\n                total_rows=len(self.dataframe),\n                name=self.name, \n                is_test=self.is_test)\n\n            tracking_batch = create_tracking_batch_head(tracking_batch_model=tracking_batch_model, connection=self.connection, raise_error_if_fail=False)\n            self.batch_id = tracking_batch.batch_id\n            self.enola_sender.batch_id = self.batch_id\n\n        #start cycle to send all data\n        print(f'{self.name}: sending to server, upload... ')\n        #show results\n        if (self.batch_id == \"\"):\n            print(f'{self.name}: finish with error, batch_id is empty')\n            return []\n\n        totalRows = len(self.dataframe)\n        listToSend = []\n        resultsList = []\n        #recorrer la lista\n        count_rows = 0\n        for (index, row) in self.dataframe.iterrows():\n\n            #create step\n            step = Step(\n                    name=self.name if (self.name != \"\") else \"Prediction\",\n                    message_input=\"\",\n                )\n\n            #add data to step in extra info\n            for column in self.dataframe.columns:\n                step.add_extra_info(column, row[column])\n\n            if (self.score_cluster_column_name in self.dataframe.columns):\n                step.score_cluster = row[self.score_cluster_column_name]\n                step.date_start = self.period\n                step.date_start = self.period\n            elif (self.score_cluster_column_name != \"\" and self.score_cluster_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column score_cluster_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column score_cluster_column_name{self.product_id_column_name} not found in dataframe ')\n\n            if (self.score_group_column_name in self.dataframe.columns):\n                step.score_group = row[self.score_group_column_name]\n                step.date_start = self.period\n                step.date_start = self.period\n            elif (self.score_group_column_name != \"\" and self.score_group_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column score_group_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column score_group_column_name {self.product_id_column_name} not found in dataframe ')\n\n            if (self.score_value_column_name in self.dataframe.columns):\n                step.score_value = row[self.score_value_column_name]\n                step.date_start = self.period\n                step.date_start = self.period\n            elif (self.score_value_column_name != \"\" and self.score_value_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column score_value_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column score_value_column_name {self.product_id_column_name} not found in dataframe ')\n\n            if (self.client_id_column_name in self.dataframe.columns):\n                self.enola_sender.client_id = row[self.client_id_column_name]\n            elif (self.client_id_column_name != \"\" and  self.client_id_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column client_id_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column client_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n            if (self.product_id_column_name in self.dataframe.columns):\n                step.product_id = row[self.product_id_column_name]\n            elif (self.product_id_column_name != \"\" and  self.product_id_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column product_id_column_name{self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column product_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n            if (self.channel_id_column_name in self.dataframe.columns):\n                self.enola_sender.channel_id = row[self.channel_id_column_name]\n            elif (self.channel_id_column_name != \"\" and self.channel_id_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column channel_id_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column channel_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n            if (self.channel_name_column_name in self.dataframe.columns):\n                self.enola_sender.channel_name = row[self.channel_name_column_name]\n            elif (self.channel_name_column_name != \"\"  and self.channel_name_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column channel_name_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column channel_name_column_name {self.product_id_column_name} not found in dataframe ')\n\n            if (self.session_id_column_name in self.dataframe.columns):\n                self.enola_sender.session_id = row[self.session_id_column_name]\n            elif (self.session_id_column_name != \"\"  and self.session_id_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column session_id_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column session_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n            if (self.session_name_column_name in self.dataframe.columns):\n                self.enola_sender.session_name = row[self.session_name_column_name]\n            elif (self.session_name_column_name != \"\" and  self.session_name_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column session_name_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column session_name_column_name {self.product_id_column_name} not found in dataframe ')\n\n            if (self.user_id_column_name in self.dataframe.columns):\n                self.enola_sender.user_id = row[self.user_id_column_name]\n            elif (self.user_id_column_name != \"\" and  self.user_id_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column user_id_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column user_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n            if (self.user_name_column_name in self.dataframe.columns):\n                self.enola_sender.user_name = row[self.user_name_column_name]\n            elif (self.user_name_column_name != \"\" and  self.user_name_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column user_name_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column user_name_column_name {self.product_id_column_name} not found in dataframe ')\n\n            if (self.app_id_column_name in self.dataframe.columns):\n                self.enola_sender.app_id = row[self.app_id_column_name]\n            elif (self.app_id_column_name != \"\" and  self.app_id_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column app_id_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column app_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n            if (self.app_name_column_name in self.dataframe.columns):\n                self.enola_sender.app_name = row[self.app_name_column_name]\n            elif (self.app_name_column_name != \"\" and  self.app_name_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column app_name_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column app_name_column_name{self.product_id_column_name} not found in dataframe ')\n\n            if (self.ip_column_name in self.dataframe.columns):\n                self.enola_sender.ip = row[self.ip_column_name]\n            elif (self.ip_column_name != \"\" and  self.ip_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column ip_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column ip_column_name {self.product_id_column_name} not found in dataframe ')\n\n            if (self.external_id_column_name in self.dataframe.columns):\n                self.enola_sender.external_id = row[self.external_id_column_name]\n            elif (self.external_id_column_name != \"\" and  self.external_id_column_name != None):\n                self.connection.huemul_logging.log_message_error(message = f'{self.name}: column external_id_column_name {self.product_id_column_name} not found in dataframe ')\n                raise Exception(f'{self.name}: column external_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n\n            step.step_type = StepType.SCORE\n            step.successfull = True\n            step.set_score(\n                value=step.score_value, \n                group=step.score_group, \n                cluster=step.score_cluster, \n                date=step.date_start\n                )\n\n            #crear registro con el mismo metodo del real-time\n            tracking_model = TrackingModel(\n                isTest=self.is_test,\n                enola_sender=self.enola_sender,\n                enola_id_prev=\"\",\n                steps=1,\n                step_list=[step]\n            )\n\n            #add to list\n            listToSend.append(tracking_model)\n\n            #agregarlo al arreglo de envio\n            if (len(listToSend) == batch_size or count_rows == totalRows-1):\n                #send to enola\n                tracking_batch = create_tracking (tracking_list_model=listToSend, connection=self.connection, raise_error_if_fail=False)\n\n                if (tracking_batch.successfull == False):\n                    print(f'{self.name}: finish with error, batch_id is empty')\n                    return []\n\n                resultsList.extend(tracking_batch.tracking_list)\n                self.connection.huemul_logging.log_message_info(message = f\"{self.name} sent {len(resultsList)} of {totalRows}...\")\n\n                #clean and continue\n                listToSend = []\n\n            count_rows += 1\n\n\n\n        #self.connection.huemul_logging.log_message_info(message = f'{self.name}: finish OK! ')\n        self.connection.huemul_logging.log_message_info(message = f\"{self.name} finish OK with batch_id: {self.batch_id}\")\n\n        return resultsList\n\n\n        #finish OK\n\n\n\n\n\n    def __str__(self):\n        return f'Agent/Model: {self.name}, Steps: {self.steps}'\n\n    def __getitem__(self, key):\n        return self.__dict__[key]\n\n    def __getattr__(self, key):\n        return self.__dict__[key]\n\n    def get(self, key, default=None):\n        return self.__dict__.get(key, default)\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.__init__","title":"<code>__init__(token, name, dataframe, period, client_id_column_name, product_id_column_name, score_value_column_name, score_group_column_name, score_cluster_column_name, channel_id_column_name=None, channel_name_column_name=None, session_id_column_name=None, session_name_column_name=None, user_id_column_name=None, user_name_column_name=None, app_id_column_name=None, app_name_column_name=None, ip_column_name=None, external_id_column_name=None, app_id=None, app_name='', user_id=None, user_name='', session_id=None, session_name='', channel_id=None, channel_name='', ip=None, is_test=False)</code>","text":"<p>Start tracking Batch Execution</p> <p>token: jwt token, this is used to identify the agent, request from Admin App name: name of this execution dataframe: dataframe to track period: period of this execution in iso-format (2021-01-01T00:00:00Z) client_id_column_name: name of column with client id product_id_column_name: name of column with product id score_value_column_name: name of column with score value score_group_column_name: name of column with score group score_cluster_column_name: name of column with score cluster channel_id_column_name: name of column with channel id channel_name_column_name: name of column with channel name session_id_column_name: name of column with session id session_name_column_name: name of column with session name user_id_column_name: name of column with user id user_name_column_name: name of column with user name app_id_column_name: name of column with app id app_name_column_name: name of column with app name ip_column_name: name of column with ip app_id: id of app, this is used to identify the app who is calling app_name: name of app, this is used to identify the app who is calling user_id: id of external user, this is used to identify the user who is calling user_name: name of external user, this is used to identify the user who is calling session_id: id of session of user or application, this is used to identify the session who is calling session_name: name of session of user or application, this is used to identify the session who is calling channel_id: web, chat, whatsapp, etc, this is used to identify the channel who is calling channel_name: web, chat, whatsapp, etc, this is used to identify the channel who is calling ip: ip of user or application, this is used to identify the ip who is calling is_test: true if this call is for testing purposes</p> Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def __init__(self, \n             token, \n             name, \n             dataframe, \n             period: str, \n             client_id_column_name:str, \n             product_id_column_name:str, \n             score_value_column_name: str, \n             score_group_column_name:str, \n             score_cluster_column_name:str,  \n             channel_id_column_name:str=None,\n             channel_name_column_name:str=None,\n             session_id_column_name:str=None,\n             session_name_column_name:str=None,\n             user_id_column_name:str=None,\n             user_name_column_name:str=None,\n             app_id_column_name:str=None,\n             app_name_column_name:str=None,\n             ip_column_name:str=None,\n             external_id_column_name:str=None,\n             app_id=None, \n             app_name:str=\"\",\n             user_id=None, \n             user_name:str=\"\", \n             session_id=None, \n             session_name:str=\"\", \n             channel_id=None, \n             channel_name:str=\"\", \n             ip=None, \n             is_test=False):\n    \"\"\"\n    Start tracking Batch Execution\n\n    token: jwt token, this is used to identify the agent, request from Admin App\n    name: name of this execution\n    dataframe: dataframe to track\n    period: period of this execution in iso-format (2021-01-01T00:00:00Z)\n    client_id_column_name: name of column with client id\n    product_id_column_name: name of column with product id\n    score_value_column_name: name of column with score value\n    score_group_column_name: name of column with score group\n    score_cluster_column_name: name of column with score cluster\n    channel_id_column_name: name of column with channel id\n    channel_name_column_name: name of column with channel name\n    session_id_column_name: name of column with session id\n    session_name_column_name: name of column with session name\n    user_id_column_name: name of column with user id\n    user_name_column_name: name of column with user name\n    app_id_column_name: name of column with app id\n    app_name_column_name: name of column with app name\n    ip_column_name: name of column with ip\n    app_id: id of app, this is used to identify the app who is calling\n    app_name: name of app, this is used to identify the app who is calling\n    user_id: id of external user, this is used to identify the user who is calling\n    user_name: name of external user, this is used to identify the user who is calling\n    session_id: id of session of user or application, this is used to identify the session who is calling\n    session_name: name of session of user or application, this is used to identify the session who is calling\n    channel_id: web, chat, whatsapp, etc, this is used to identify the channel who is calling\n    channel_name: web, chat, whatsapp, etc, this is used to identify the channel who is calling\n    ip: ip of user or application, this is used to identify the ip who is calling\n    is_test: true if this call is for testing purposes\n    \"\"\"\n    self.name = name\n    self.hf = HuemulFunctions()\n    self.dataframe = dataframe\n    self.client_id_column_name = client_id_column_name\n    self.product_id_column_name = product_id_column_name\n    self.score_value_column_name = score_value_column_name\n    self.score_group_column_name = score_group_column_name\n    self.score_cluster_column_name = score_cluster_column_name\n    self.channel_id_column_name = channel_id_column_name\n    self.channel_name_column_name = channel_name_column_name\n    self.session_id_column_name = session_id_column_name\n    self.session_name_column_name = session_name_column_name\n    self.user_id_column_name = user_id_column_name\n    self.user_name_column_name = user_name_column_name\n    self.app_id_column_name = app_id_column_name\n    self.app_name_column_name = app_name_column_name\n    self.ip_column_name = ip_column_name\n    self.external_id_column_name = external_id_column_name\n    self.period = period\n\n\n    if (dataframe is None):\n        raise Exception(\"dataframe is empty\")\n    if (len(dataframe) == 0):\n        raise Exception(\"dataframe is empty (len 0)\")\n    if (score_value_column_name is None):\n        raise Exception(\"score_value_column_name is empty\")\n    if (score_value_column_name == \"\" and score_group_column_name == \"\" and score_cluster_column_name == \"\"):\n        raise Exception(\"some of score_value_column_name, score_group_column_name or score_cluster_column_name must be filled\")\n    if (period is None):\n        raise Exception(\"period is empty\")\n    if (period == \"\"):\n        raise Exception(\"period is empty\")\n\n    #decodificar jwt\n    self.token_info = TokenInfo(token=token)\n\n    if (self.token_info.is_service_account == False):\n        raise Exception(\"This token is not a service account. Only service accounts can execute tracking\")\n\n    if not self.token_info.agent_deploy_id:\n        raise Exception(\"agentDeployId is empty.\")\n\n    if (self.token_info.service_account_can_tracking == False):\n        raise Exception(\"This service account can't execute tracking\")\n\n\n    self.agent_deploy_id = self.token_info.agent_deploy_id\n    self.connection = Connect(AuthModel(jwt_token=token, url_service=self.token_info.service_account_url_backend, org_id=self.token_info.org_id))\n\n    #user information\n    self.enola_sender = EnolaSenderModel(\n        app_id=app_id, \n        app_name=app_name, \n        user_id=user_id, \n        user_name=user_name, \n        session_id=session_id, \n        session_name=session_name, \n        channel_id=channel_id, \n        channel_name=channel_name, \n        ip=ip, \n        external_id=\"\", \n        batch_id=\"\",\n        client_id=\"\",\n        product_id=\"\",\n        )\n\n    #if is empty or not exist assign false\n    self.is_test = is_test\n\n    #save steps and informations\n    self.batch_id = \"\"\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_custom_info","title":"<code>add_custom_info(key, value)</code>","text":"<p>add custom information to tracking</p> Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_custom_info(self, key, value):\n    \"\"\"\n    add custom information to tracking\n    \"\"\"\n    self.first_step.info_list.append(Info(key, value))\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_data_received","title":"<code>add_data_received(name, data, type)</code>","text":"<p>add data received from user</p> Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_data_received(self, name:str, data, type:DataType):\n    \"\"\"\n    add data received from user\n    \"\"\"\n    self.first_step.agent_data_list.append(DataListModel(value=data, name=name, data_type=type, kind=KindType.RECEIVER)) \n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_data_send","title":"<code>add_data_send(name, data, type)</code>","text":"<p>add data to send to user</p> Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_data_send(self, name:str, data, type:DataType):\n    \"\"\"\n    add data to send to user\n    \"\"\"\n    self.first_step.agent_data_list.append(DataListModel(value=data, name=name, data_type=type, kind=KindType.SENDER)) \n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_error","title":"<code>add_error(id, message, kind)</code>","text":"<p>register error to tracking</p> Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_error(self, id: str, message: str, kind: ErrOrWarnKind):\n    \"\"\"\n    register error to tracking\n    \"\"\"\n    self.first_step.add_error(id=id, message=message, kind=kind)\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_extra_info","title":"<code>add_extra_info(key, value)</code>","text":"<p>add extra information to tracking, this can be used to test or debug</p> Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_extra_info(self, key: str, value):\n    \"\"\"\n    add extra information to tracking, this can be used to test or debug\n    \"\"\"\n    self.first_step.add_extra_info(key=key, value=value)\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_tag","title":"<code>add_tag(key, value)</code>","text":"<p>add tag to tracking, this tag is used to search in Enola App</p> Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_tag(self, key: str, value):\n    \"\"\"\n    add tag to tracking, this tag is used to search in Enola App\n    \"\"\"\n    self.first_step.add_tag(key=key, value=value)\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.add_warning","title":"<code>add_warning(id, message, kind)</code>","text":"<p>register warning to tracking</p> Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def add_warning(self, id: str, message: str, kind: ErrOrWarnKind):\n    \"\"\"\n    register warning to tracking\n    \"\"\"\n    self.first_step.add_warning(id=id, message=message, kind=kind)\n</code></pre>"},{"location":"reference/tracking_batch/#enola.tracking_batch.TrackingBatch.execute","title":"<code>execute(batch_size=200)</code>","text":"<p>register tracking batch in Enola server</p> Source code in <code>src\\enola\\tracking_batch.py</code> <pre><code>def execute(self, batch_size=200) -&gt; List[TrackingResponseModel]:\n    \"\"\"\n    register tracking batch in Enola server\n    \"\"\"\n\n    #create batch\n    if (self.batch_id == \"\"):\n        print(f'{self.name}: sending to server, create Batch... ')\n        tracking_batch_model = TrackingBatchHeadModel(\n            enola_sender=self.enola_sender, \n            period=self.period,\n            total_rows=len(self.dataframe),\n            name=self.name, \n            is_test=self.is_test)\n\n        tracking_batch = create_tracking_batch_head(tracking_batch_model=tracking_batch_model, connection=self.connection, raise_error_if_fail=False)\n        self.batch_id = tracking_batch.batch_id\n        self.enola_sender.batch_id = self.batch_id\n\n    #start cycle to send all data\n    print(f'{self.name}: sending to server, upload... ')\n    #show results\n    if (self.batch_id == \"\"):\n        print(f'{self.name}: finish with error, batch_id is empty')\n        return []\n\n    totalRows = len(self.dataframe)\n    listToSend = []\n    resultsList = []\n    #recorrer la lista\n    count_rows = 0\n    for (index, row) in self.dataframe.iterrows():\n\n        #create step\n        step = Step(\n                name=self.name if (self.name != \"\") else \"Prediction\",\n                message_input=\"\",\n            )\n\n        #add data to step in extra info\n        for column in self.dataframe.columns:\n            step.add_extra_info(column, row[column])\n\n        if (self.score_cluster_column_name in self.dataframe.columns):\n            step.score_cluster = row[self.score_cluster_column_name]\n            step.date_start = self.period\n            step.date_start = self.period\n        elif (self.score_cluster_column_name != \"\" and self.score_cluster_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column score_cluster_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column score_cluster_column_name{self.product_id_column_name} not found in dataframe ')\n\n        if (self.score_group_column_name in self.dataframe.columns):\n            step.score_group = row[self.score_group_column_name]\n            step.date_start = self.period\n            step.date_start = self.period\n        elif (self.score_group_column_name != \"\" and self.score_group_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column score_group_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column score_group_column_name {self.product_id_column_name} not found in dataframe ')\n\n        if (self.score_value_column_name in self.dataframe.columns):\n            step.score_value = row[self.score_value_column_name]\n            step.date_start = self.period\n            step.date_start = self.period\n        elif (self.score_value_column_name != \"\" and self.score_value_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column score_value_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column score_value_column_name {self.product_id_column_name} not found in dataframe ')\n\n        if (self.client_id_column_name in self.dataframe.columns):\n            self.enola_sender.client_id = row[self.client_id_column_name]\n        elif (self.client_id_column_name != \"\" and  self.client_id_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column client_id_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column client_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n        if (self.product_id_column_name in self.dataframe.columns):\n            step.product_id = row[self.product_id_column_name]\n        elif (self.product_id_column_name != \"\" and  self.product_id_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column product_id_column_name{self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column product_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n        if (self.channel_id_column_name in self.dataframe.columns):\n            self.enola_sender.channel_id = row[self.channel_id_column_name]\n        elif (self.channel_id_column_name != \"\" and self.channel_id_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column channel_id_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column channel_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n        if (self.channel_name_column_name in self.dataframe.columns):\n            self.enola_sender.channel_name = row[self.channel_name_column_name]\n        elif (self.channel_name_column_name != \"\"  and self.channel_name_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column channel_name_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column channel_name_column_name {self.product_id_column_name} not found in dataframe ')\n\n        if (self.session_id_column_name in self.dataframe.columns):\n            self.enola_sender.session_id = row[self.session_id_column_name]\n        elif (self.session_id_column_name != \"\"  and self.session_id_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column session_id_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column session_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n        if (self.session_name_column_name in self.dataframe.columns):\n            self.enola_sender.session_name = row[self.session_name_column_name]\n        elif (self.session_name_column_name != \"\" and  self.session_name_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column session_name_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column session_name_column_name {self.product_id_column_name} not found in dataframe ')\n\n        if (self.user_id_column_name in self.dataframe.columns):\n            self.enola_sender.user_id = row[self.user_id_column_name]\n        elif (self.user_id_column_name != \"\" and  self.user_id_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column user_id_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column user_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n        if (self.user_name_column_name in self.dataframe.columns):\n            self.enola_sender.user_name = row[self.user_name_column_name]\n        elif (self.user_name_column_name != \"\" and  self.user_name_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column user_name_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column user_name_column_name {self.product_id_column_name} not found in dataframe ')\n\n        if (self.app_id_column_name in self.dataframe.columns):\n            self.enola_sender.app_id = row[self.app_id_column_name]\n        elif (self.app_id_column_name != \"\" and  self.app_id_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column app_id_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column app_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n        if (self.app_name_column_name in self.dataframe.columns):\n            self.enola_sender.app_name = row[self.app_name_column_name]\n        elif (self.app_name_column_name != \"\" and  self.app_name_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column app_name_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column app_name_column_name{self.product_id_column_name} not found in dataframe ')\n\n        if (self.ip_column_name in self.dataframe.columns):\n            self.enola_sender.ip = row[self.ip_column_name]\n        elif (self.ip_column_name != \"\" and  self.ip_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column ip_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column ip_column_name {self.product_id_column_name} not found in dataframe ')\n\n        if (self.external_id_column_name in self.dataframe.columns):\n            self.enola_sender.external_id = row[self.external_id_column_name]\n        elif (self.external_id_column_name != \"\" and  self.external_id_column_name != None):\n            self.connection.huemul_logging.log_message_error(message = f'{self.name}: column external_id_column_name {self.product_id_column_name} not found in dataframe ')\n            raise Exception(f'{self.name}: column external_id_column_name {self.product_id_column_name} not found in dataframe ')\n\n\n        step.step_type = StepType.SCORE\n        step.successfull = True\n        step.set_score(\n            value=step.score_value, \n            group=step.score_group, \n            cluster=step.score_cluster, \n            date=step.date_start\n            )\n\n        #crear registro con el mismo metodo del real-time\n        tracking_model = TrackingModel(\n            isTest=self.is_test,\n            enola_sender=self.enola_sender,\n            enola_id_prev=\"\",\n            steps=1,\n            step_list=[step]\n        )\n\n        #add to list\n        listToSend.append(tracking_model)\n\n        #agregarlo al arreglo de envio\n        if (len(listToSend) == batch_size or count_rows == totalRows-1):\n            #send to enola\n            tracking_batch = create_tracking (tracking_list_model=listToSend, connection=self.connection, raise_error_if_fail=False)\n\n            if (tracking_batch.successfull == False):\n                print(f'{self.name}: finish with error, batch_id is empty')\n                return []\n\n            resultsList.extend(tracking_batch.tracking_list)\n            self.connection.huemul_logging.log_message_info(message = f\"{self.name} sent {len(resultsList)} of {totalRows}...\")\n\n            #clean and continue\n            listToSend = []\n\n        count_rows += 1\n\n\n\n    #self.connection.huemul_logging.log_message_info(message = f'{self.name}: finish OK! ')\n    self.connection.huemul_logging.log_message_info(message = f\"{self.name} finish OK with batch_id: {self.batch_id}\")\n\n    return resultsList\n</code></pre>"}]}